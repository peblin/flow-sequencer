// Changelog:
// - Re-structuring of controls for better usability and also to make room for more features.
//   - Default "pads" page has pads and knobs for "mode", quantization, midi ch out and step length
//   - Sequencer options page, reachable with SHIFT for setting Solo/Multi play modes, copying patterns and arming/disarming patterns
//   - New "pattern options mode", reachable by long-press/hold on SHIFT. Tap SHIFT to exit. Has velocity, strum and gate controls, as well as all CC automation/recording controls. Also has X/Y pad for sending (and recording if armed) CC values for CC commands set in slot A and B (so X/Y = A/B).
//   - Pad edit mode, reachable with HOLD on pad in default pad view
//   - Voices mode, reachable with SHIFT when a step part is active in pad edit mode.
// - "Master" mode knob that gives direct control of various rec/play modes.
// - New recording mode - record last played note when tapping a step (or tap part when holding a step)
// - Trigger mode to set sequencer position
//   - In trigger mode, hold pad to repeat it until released
// - Transpose mode moved to mode knob
// - CC automation slots A to D mapped to AU parameters "User 0" to "User 3"
//   - Map knobs for Flow in e.g. Velocity Keyboard, set Midi Control in AUM. Then configure per pattern which midi CC each slot maps to.
// - Midi CC 115-118 maps to slots A to D, for use in the same way as AU parameters
// - CC slots configuration moved to new pattern options mode
// - CC rec mode moved to pattern options
// - fix: "Copy Pattern" would not copy midi slots, strum or velocity knob settings. 
// - fix: deleting a part/step would not erase all values.

// TODO:
// - Document what labels on pads actually mean
// - Maybe: CC passthru (or is this always?), commit quantization (or should we have a non-destrucive quantization?), nudge pattern in pad options view
// - In "pads" mode, show actual notes on pads (only first part of step will be relevant)


// Change LabelPads below to name your patterns/tracks!
@TrackLabels
  if active_pattern = 0
    LabelPads {1-Track 1}
  elseif active_pattern = 1
    LabelPads {2-Track 2}
  elseif active_pattern = 2
    LabelPads {3-Track 3}
  elseif active_pattern = 3
    LabelPads {4-Track 4}
  elseif active_pattern = 4
    LabelPads {5-Track 5}
  elseif active_pattern = 5
    LabelPads {6-Track 6}
  elseif active_pattern = 6
    LabelPads {7-Track 7}
  endif
@End

@Onload

  SetShortName {Flow} 
  ShowLayout 2
  CurrentTimerTicks = 0
  last_pulse_ticks = 0
  timer_tick_resolution = 5 // Milliseconds per tick

  Call @PadManagerOnLoad

  step_reso = 8  // Grid/parts per step
  part_reso = 1 // REMOVE? Pulses per part
  poly = 6       // Max polyphony per part
  sizeof_pattern = 16*8      // Size of storing all step parts in an array

  // -- CONSTANTS -- 
  UIMODE_PADS = 1
  UIMODE_BUTTONS = 2
  UIMODE_VOICES = 3
  UIMODE_HELP = 4
  UIMODE_PADS_OPTIONS = 5
  
  // Buttons
  BTN_MULTI_PATTERN = 0
//  // BTN_RECORD = 1
//  // BTN_QUANTIZE = 3
//  // BTN_TRANSPOSE = 4
  BTN_COPY_PATTERN = 5
  BTN_CLEAR_ALL = 6
  BTN_CLEAR_ARMED = 7
  BTN_HELP = 15

  // Knobs for pad options
  KNOB_GATE = 0
  KNOB_VELOCITY = 1
  KNOB_STRUM = 2
  BTN_MIDI = 0
 
  // Knobs for pad
  KNOB_STEP = 0
  KNOB_MIDICH = 1
  KNOB_RECMODE = 2
  KNOB_QUANT = 3
  
  // Knobs for voices
  // VKNOB_VOICE1 = 0
  // VKNOB_VOICE2 = 1
  // VKNOB_VOICE3 = 2
  // VKNOB_VOICE4 = 3
  // VKNOB_VOICE5 = 4
  // VKNOB_VOICE6 = 5
  // VKNOB_GATE = 11
  // VKNOB_VELOCITY = 12
  // VKNOB_PROBABILITY = 13
  // VKNOB_STRUM = 14
  // VKNOB_RATCHET = 15
  // VKNOB_SLOT1CC = 18
  // VKNOB_SLOT2CC = 19
  // VKNOB_SLOT3CC = 20
  // VKNOB_SLOT4CC = 21
  // VKNOB_SLOT1VAL = 7
  // VKNOB_SLOT2VAL = 8
  // VKNOB_SLOT3VAL = 9
  // VKNOB_SLOT4VAL = 10

  poly_offset = 0
  note_pos = 0
  note_part = 0
  seq_step = 0 // this is internal to IncrementSequencer, use step below as its updated in "sync" with note_part and step_part
  step = 0
  pad_edit_step = 0
  loops = 0 // number of sequencer loops run since host start
  
  // tracks total ticks since start of transport. might wrap, but that wont kill anyone....i think
  total_tickCounter = 0  

// tracks if a note was received while holding a pad - in which case we can exit pad edit mode on pad release
  pad_edit_got_note = YES
  pad_edit_hold = 0  
  pad_edit_part_pad = 0
  pad_edit_note_part = 0 

  // states for UI
  
  resetStepOnNewStep = 0
  mode_pad_edit = 0
  mode_copy_pattern = NO
  clear_confirm = NO
  if Unassigned record
    record = 1 // Rec enabled by default
    rec_mode = 1
    transpose = NO
    transposeNote = 0
    mode_multi_pattern = NO
    midi_rec_mode = 0
    play = YES
    reset_step = -1
  endif

  _res = step_reso * part_reso

  // PPQN and number of steps between parts for CC automation interpolation.
  // Array represents [1/32, 1/16, 1/8T, 1/8, 1/4, 1/2, 1 bar, 2 bars]
  PPQN = [8*_res, 4*_res, 3*_res, 2*_res, _res, _res/2, _res/4, _res/8]
  CC_interpolation_steps = [0, 0, 0, 0, 2, 4, 8, 16]

  // quantization
  QUANT_NONE = 0
  QUANT_PART = 1
  QUANT_STEP = 2
  quantize = QUANT_NONE

  // midi recording
  if Unassigned midi_rec_mode
    midi_rec_mode = 0
  endif
  MIDI_REC_OFF = 0
  MIDI_REC_WRITE = 1
  MIDI_REC_OVERDUB = 2
  
  midi_write_last_step = -1
  midi_slots = 4
  
  if Unassigned currentDivisor
    currentDivisor = 3
    count = 1
    tickCounter = 0
    gateX_knob = -1
    probability_knob = 100
    shiftDownTick = -1  // for shift HOLD mode
  endif

  call @ComputeTimes
  Call @InitSequencer

  if Unassigned last_active_pattern
    last_active_pattern = 1
  endif
  active_pattern = 0
  StartTimer 
  call @SetUIMode_Pads
@End

//  ╦╔╗╔╦╔╦╗   ┬   ╔╦╗╦╔╦╗╔═╗
//  ║║║║║ ║   ┌┼─   ║ ║║║║║╣ 
//  ╩╝╚╝╩ ╩   └┘    ╩ ╩╩ ╩╚═╝  

@IncrementSequencer
  Inc tickCounter
  Inc total_tickCounter

  if tickCounter >= countPerStep
    tickCounter = 0
    if resetStepOnNewStep = 1
      if trig_hold = NO
        resetStepOnNewStep = 0
      endif
      seq_step = reset_step
    else
      if uiMode = UIMODE_PADS
        FlashPad step
      else
        FlashUserLed 
      endif

      Inc seq_step
      if seq_step > 15
        seq_step = 0
        Inc loops
      endif
    endif
  endif
@End 

@ComputeTimes
  tickTime = QuarterNote / PPQN[currentDivisor] * part_reso 
  stepTime = tickTime * step_reso
  gate = stepTime
  countPerStep = step_reso * part_reso 
  SetMetroPPQN PPQN[currentDivisor]
@End

@OnHostStart
  seq_step = 0
  step = 0
  note_pos = 0
  note_part = 0  
  tickCounter = 0
  total_tickCounter = 0
  CurrentTimerTicks = 0  // "Optimistically" reset timer tick count on host start to reduce prob that it wraps during recording
  loops = 0
@End 

@InitSequencer
  if Unassigned polycount
    Call @ClearSequencer
    pattern_midich = [0,0,0,0,0,0,0]
  endif
@End

//  ╔╦╗╔═╗╔╦╗╦═╗╔═╗   ┬   ╔╦╗╦╔╦╗╦
//  ║║║║╣  ║ ╠╦╝║ ║  ┌┼─  ║║║║ ║║║
//  ╩ ╩╚═╝ ╩ ╩╚═╚═╝  └┘   ╩ ╩╩═╩╝╩

@OnMetroPulse_Interpolate 
//  Log {Interpolating for next val }, Interpolate_nextval, {(},Interpolate_diff,{) at }, _note_part + i, {, }, i, { parts away -> },Interpolate_dist,{ ms away. }

  _delay = Interpolate_dist / Interpolate_steps
  _increment = Interpolate_diff / Interpolate_steps
  
  for j = 1 to (Interpolate_steps - 1)
    _ival = _val + _increment * j
    SendMIDICC _ch, _cc, (Round _ival), (Round _delay * j)
//    Log {Scheduled }, _cc, {:}, (Round _ival), { at }, (Round _delay*j)
  endfor             
@End

@OnMetroPulse_CC_automation
      // CC AUTOMATION
      _slot_base = _pattern * midi_slots
      if slotA_value[_note_part] >= 0 
        _cc = pattern_CC_slot_map[_slot_base]
        _val = slotA_value[_note_part]
        SendMIDICC _ch, _cc, _val, 1
//        Log step, {:}, step_part, { CC },  _cc, {:}, _val

        Interpolate_steps = CC_interpolation_steps[currentDivisor]
        if Interpolate_steps > 0
          Interpolate_nextval = -1
          for i = 1 to step_reso
            if slotA_value[_note_part + i] >= 0 and Interpolate_nextval = -1
              Interpolate_nextval = slotA_value[_note_part + i]
              Interpolate_diff = slotA_value[_note_part+i] - slotA_value[_note_part]
              Interpolate_dist = i * tickTime
              Call @OnMetroPulse_Interpolate
            endif
          endfor
        endif
      endif
      
      if slotB_value[_note_part] >= 0
        _cc = pattern_CC_slot_map[_slot_base + 1]
        _val = slotB_value[_note_part]
        SendMIDICC _ch, _cc, slotB_value[_note_part], 2
//        Log step, {:}, step_part, { CC },  _cc, {:}, slotB_value[_note_part]
        Interpolate_steps = CC_interpolation_steps[currentDivisor]
        if Interpolate_steps > 0
          Interpolate_nextval = -1
          for i = 1 to step_reso
            if slotB_value[_note_part + i] >= 0 and Interpolate_nextval = -1
              Interpolate_nextval = slotB_value[_note_part + i]
              Interpolate_diff = slotB_value[_note_part+i] - slotB_value[_note_part]
              Interpolate_dist = i * tickTime
              Call @OnMetroPulse_Interpolate
            endif
          endfor
        endif
      endif
      
      if slotC_value[_note_part] >= 0
        _cc = pattern_CC_slot_map[_slot_base + 2]
        _val = slotC_value[_note_part]
        SendMIDICC _ch, _cc, slotC_value[_note_part], 3 
//        Log step, {:}, step_part, { CC },  _cc, {:}, slotC_value[_note_part]
        Interpolate_steps = CC_interpolation_steps[currentDivisor]
        if Interpolate_steps > 0
          Interpolate_nextval = -1
          for i = 1 to step_reso
            if slotC_value[_note_part + i] >= 0 and Interpolate_nextval = -1
              Interpolate_nextval = slotC_value[_note_part + i]
              Interpolate_diff = slotC_value[_note_part+i] - slotC_value[_note_part]
              Interpolate_dist = i * tickTime
              Call @OnMetroPulse_Interpolate
            endif
          endfor
        endif
      endif
      
      if slotD_value[_note_part] >= 0
        _cc = pattern_CC_slot_map[_slot_base + 3]
        _val = slotD_value[_note_part]      
        SendMIDICC _ch, _cc, slotD_value[_note_part], 4
//        Log step, {:}, step_part, { CC },  _cc, {:}, slotD_value[_note_part]
        Interpolate_steps = CC_interpolation_steps[currentDivisor]
        if Interpolate_steps > 0
          Interpolate_nextval = -1
          for i = 1 to step_reso
            if slotD_value[_note_part + i] >= 0 and Interpolate_nextval = -1
              Interpolate_nextval = slotD_value[_note_part + i]
              Interpolate_diff = slotD_value[_note_part+i] - slotD_value[_note_part]
              Interpolate_dist = i * tickTime
              Call @OnMetroPulse_Interpolate
            endif
          endfor
        endif
      endif
@End

@OnMetroPulse_notes
  _transposeNote = 0
  if transpose 
    _transposeNote = transposeNote
  endif

  _polycount = polycount[_note_part]
  _noteDelay = noteOnDelayTicks[_note_part] * timer_tick_resolution
  _gate = gate * (gateX[_note_part] / 100) + _noteDelay
  _vcurve = note_velocityX[_note_part]
  if _vcurve = -1 
    _vcurve = pattern_velocurve[_pattern]
  endif

  _strum = note_strum[_note_part]
  if _strum = -1
    _strum = pattern_strum[active_pattern]
  endif

  if _polycount > 5
    _v = Clip voice6_velocity[_note_part] * _vcurve, 0, 127 
    _s = 5*_strum
    SendMIDINoteOn _ch, voice6[_note_part] + _transposeNote, _v, _noteDelay + _s
    SendMIDINoteOff _ch, voice6[_note_part] + _transposeNote, 0, _gate + _s
  endif
  if _polycount > 4
    _v = Clip voice5_velocity[_note_part] * _vcurve, 0, 127 
    _s = 4*_strum
    SendMIDINoteOn _ch, voice5[_note_part] + _transposeNote, _v, 
    _noteDelay + _s
    SendMIDINoteOff _ch, voice5[_note_part] + _transposeNote, 0, _gate + _s
  endif
  if _polycount > 3
    _v = Clip voice4_velocity[_note_part] * _vcurve, 0, 127 
    _s = 3*_strum
    SendMIDINoteOn _ch, voice4[_note_part] + _transposeNote, _v, _noteDelay + _s
    SendMIDINoteOff _ch, voice4[_note_part] + _transposeNote, 0, _gate + _s
  endif
  if _polycount > 2
    _v = Clip voice3_velocity[_note_part] * _vcurve, 0, 127 
    _s = 2*_strum
    SendMIDINoteOn _ch, voice3[_note_part] + _transposeNote, _v, _noteDelay + _s
    SendMIDINoteOff _ch, voice3[_note_part] + _transposeNote, 0, _gate + _s
  endif
  if _polycount > 1
    _v = Clip voice2_velocity[_note_part] * _vcurve, 0, 127 
    _s = 1*_strum
    SendMIDINoteOn _ch, voice2[_note_part] + _transposeNote, _v, _noteDelay + _s
    SendMIDINoteOff _ch, voice2[_note_part] + _transposeNote, 0, _gate + _s
  endif
  if _polycount > 0
    _v = Clip voice1_velocity[_note_part] * _vcurve, 0, 127 
    _rpts = note_repeat[_note_part]
    _rpttime = _gate / _rpts
    _rptdelay = _noteDelay
    for _i = 1 to _rpts
//            Log _i, {:}, _rpttime, {,}, _rptdelay
      SendMIDINoteOn _ch, voice1[_note_part] + _transposeNote, _v, _rptdelay      
      SendMIDINoteOff _ch, voice1[_note_part] + _transposeNote, 0, _rpttime
      _rptdelay = _rptdelay + _rpttime          
    endfor
  endif
@End

@OnMetroPulse
  if (play = NO) and (reset_step = -1)
    Exit
  endif

  last_pulse_ticks = CurrentTimerTicks
  step = seq_step
  step_part = Round(((tickCounter+1) / countPerStep) * step_reso) - 1
  if step_part >= step_reso
    step_part = 0
    step = (step + 1) % 16
  endif
  note_part = (step * step_reso + step_part) // The note location in the wide grid

  for _pattern = 0 to 6 
    if (mode_multi_pattern = 0 and active_pattern=_pattern) or (mode_multi_pattern = 1 and playing_patterns[_pattern] = YES)
      _note_part = (_pattern * sizeof_pattern) + note_part
      _ch = pattern_midich[_pattern]

      if slotA_value[_note_part] >= 0 or slotB_value[_note_part] >= 0 or slotC_value[_note_part] >= 0 or slotD_value[_note_part] >= 0
        call @OnMetroPulse_CC_automation
      endif

      if voice1[_note_part] >= 0
        if ((Random 1, 100) <= note_probability[_note_part])
          call @OnMetroPulse_notes
        endif
      endif
    endif
  endfor

  if play <> NO
    Call @IncrementSequencer
  else
    reset_step = -1
  endif
@End

@OnMidiNoteOn
  _note_on_ticks = CurrentTimerTicks
  _el_ticks = _note_on_ticks - last_pulse_ticks
  _el_pct = (Round _el_ticks / (tickTime / timer_tick_resolution) * 100)
  nn = MIDINote
  v = MIDIVelocity
  last_nn = nn
  last_v = v

  if transpose AND mode_pad_edit <> 1 
    transposeNote = MIDINote - 48
    LabelPads {⚠️Transpose: }, transposeNote
    Exit
  endif
  
  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS) or rec_mode = 2
    SendMidiThruOnCh pattern_midich[active_pattern]
    Exit
  endif
  
  _supressMidiThru = NO
 
  if mode_pad_edit = 1
    pad_edit_got_note = YES
    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 
    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part
 
    if not Unassigned pad_edit_part_pad  // Latch and label when editing parts of step
      LabelPad pad_edit_part_pad, (NoteName nn, YES)
      LatchPad pad_edit_part_pad, 1
    endif
    _supressMidiThru = YES
  else
    _step = step
    if quantize = QUANT_STEP
      if step_part > 5  // if we are within 25% of next step then quantize to that 
        _step = (_step  + 1) % 16
        _supressMidiThru = YES
      endif
      _note_part = (active_pattern * sizeof_pattern) + _step * step_reso
    else
      if quantize = QUANT_PART and _el_pct > 50
        // if note is closer to next part, then quantize to that one
        note_part = (note_part + (Round _el_pct/100)) % (16 * step_reso)
        _supressMidiThru = YES
      endif
      _note_part = (active_pattern * sizeof_pattern) + note_part
    endif
  endif
  
  call @RecordMidiNoteOn
@End

@RecStepInput
  nn = last_nn
  v = last_v
  _note_on_ticks = last_pulse_ticks
  _supressMidiThru = YES

  call @RecordMidiNoteOn  
@End

// inputs:
// nn, v, _supressMidiThru, _note_part, _step, _note_on_ticks (set to last_pulse_ticks for quantization to part)
@RecordMidiNoteOn
  v_trans = Clip v * pattern_velocurve[active_pattern], 0, 127 

  if not _supressMidiThru
    SendMIDINoteOn pattern_midich[active_pattern], nn, v_trans 
    // SendMidiThruOnCh pattern_midich[active_pattern]
  endif

  _poly_offset = polycount[_note_part]
 
  if _poly_offset = 0
    voice1[_note_part] = nn
    voice1_velocity[_note_part] = v
  elseif _poly_offset = 1
    voice2[_note_part] = nn
    voice2_velocity[_note_part] = v
  elseif _poly_offset = 2
    voice3[_note_part] = nn
    voice3_velocity[_note_part] = v
  elseif _poly_offset = 3
    voice4[_note_part] = nn
    voice4_velocity[_note_part] = v
  elseif _poly_offset = 4
    voice5[_note_part] = nn
    voice5_velocity[_note_part] = v
  elseif _poly_offset = 5
    voice6[_note_part] = nn
    voice6_velocity[_note_part] = v
  endif

  if _poly_offset < 6
    Inc _poly_offset
  endif

  polycount[_note_part] = _poly_offset
  noteOnTicks[_note_part] = CurrentTimerTicks //total_tickCounter

  // record knob settings if playing with CC arm on
  if midi_rec_mode <> MIDI_REC_OFF
    note_velocityX[_note_part] = pattern_velocurve[active_pattern]
    note_strum[_note_part] = pattern_strum[active_pattern]
  endif

  if quantize = QUANT_NONE and HostRunning and not mode_pad_edit // we can only have delay if metronome is running
    noteOnDelayTicks[_note_part] = _note_on_ticks - last_pulse_ticks
  else
    noteOnDelayTicks[_note_part] = 0
  endif

  // Store part so that MidiNoteOff can reference all data of the note being played
  SetNoteState 0, nn, _note_part    
  if not mode_pad_edit
    if uiMode <> UIMODE_BUTTONS
      LabelPad _step, _poly_offset, {:}, (NoteName nn, YES) 
    endif
    LatchPad _step, 1
  endif
  last_note = nn      // for single-tap edit
  last_velocity = nn  
@End 


@OnMidiNoteOff

// TODO: Should to send explicit midi command with velocity set to gateX_knob (or "As Played") to make "midi thru" consistent with sequencer settings
  SendMidiThruOnCh pattern_midich[active_pattern]

  if not ((record and HostRunning) or mode_pad_edit = 1) or transpose or (uiMode = UIMODE_BUTTONS)
    Exit
  endif
  nn = MIDINote
  v = MIDIVelocity
  _note_part = GetNoteState 0, nn

  // Dont store anything unless state was set to <> -1. 
  if _note_part = -1
    Exit
  endif
  // Reset state to prevent OnMidiOff action when notes are played with recording off 
  SetNoteState 0, nn, -1

  _note_step = Div (_note_part - active_pattern * sizeof_pattern), step_reso
  _note_pad = _note_part - ((active_pattern * sizeof_pattern) + _note_step * step_reso)
  if _note_step < 8
    _note_pad = _note_pad + 8
  endif

  _on_ticks = noteOnTicks[_note_part]
  _off_ticks = CurrentTimerTicks // total_tickCounter
  _elapsed_ticks = _off_ticks - _on_ticks

  // Special case:
  // if transport is stopped or we have long steps (like 2 bars) we might get 0 ticks so we default to 1 step for these cases.
  // we might also get negative elapse ticks if timer wrapped around the 16-bit int limit, so we just say 100% elapsed as a safeguard
  if _elapsed_ticks <= 0
    _elapsed_pct = 100
  else
    _elapsed_pct = _elapsed_ticks * timer_tick_resolution / gate * 100
  endif

  if gateX_knob < 0
    gateX[_note_part] = _elapsed_pct  // elapsed as percentage of gate
  elseif midi_rec_mode <> MIDI_REC_OFF
    gateX[_note_part] = gateX_knob  // Set fixed gate from knob if CC arm is on 
  endif
  
  last_gatepct = gateX[_note_part]  // for step input

  if not mode_pad_edit 
    LabelPad _note_step, (NoteName nn, YES), {:}, Round(gateX[_note_part]) 
  else
    LabelPad _note_pad, {🔴}, (NoteName nn, YES), {:}, Round(gateX[_note_part]) 
  endif
@End

// REFACTOR: Uses _note_part, which is not defined here. 
@OnMidiCC
  _cc = MIDIByte2
  _val = MIDIByte3
  _slot_base = active_pattern * midi_slots

  // hardcoded midi CC map. not the prettiest, but collisions unlikely and easy to fix.
  if _cc >= 115 and _cc <= 118
    if _cc = 115
      _midi_offset = 0
    elseif _cc = 116
      _midi_offset = 1
    elseif _cc = 117
      _midi_offset = 2
    elseif _cc = 118
      _midi_offset = 3
    endif
    _cc = pattern_CC_slot_map[_slot_base + _midi_offset]
  else
    _midi_offset = -1
    if pattern_CC_slot_map[_slot_base] = _cc
      _midi_offset = 0
    elseif pattern_CC_slot_map[_slot_base + 1] = _cc
      _midi_offset = 1
    elseif pattern_CC_slot_map[_slot_base + 2] = _cc
      _midi_offset = 2
    elseif pattern_CC_slot_map[_slot_base + 3] = _cc
      _midi_offset = 3
    endif

    if _midi_offset = -1
      if pattern_CC_slot_map[_slot_base] = -1
        _midi_offset = 0
      elseif pattern_CC_slot_map[_slot_base + 1] = -1
        _midi_offset = 1
      elseif pattern_CC_slot_map[_slot_base + 2] = -1
        _midi_offset = 2
      elseif pattern_CC_slot_map[_slot_base + 3] = -1
        _midi_offset = 3
      else
        Log {OUT OF SLOTS! Not recording: }, _cc, {:}, _val
        Exit
      endif  
      pattern_CC_slot_map[_slot_base + _midi_offset] = _cc
    endif
  endif

  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS)  or transpose or midi_rec_mode = MIDI_REC_OFF
    SendMIDICC pattern_midich[active_pattern], _cc, _val
    Exit
  endif

  call @RecordMidiCC
@End

// inputs: _midi_offset, _cc, _val, _slot_base
@RecordMidiCC   
  _supressMidiThru = NO
 
  if mode_pad_edit = 1
    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 
    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part

    LabelPad pad_edit_part_pad, {CC: }, _cc, {:}, _val
    _supressMidiThru = YES
  else
    _step = step
    LabelPad _step, _cc, {: }, _val
  endif

  if not _supressMidiThru
//    SendMidiThruOnCh pattern_midich[active_pattern]
    SendMIDICC pattern_midich[active_pattern], _cc, _val
  endif

  if midi_rec_mode = MIDI_REC_WRITE and midi_write_last_step <> _step
    _step_part = (active_pattern * sizeof_pattern) + _step * step_reso // The note location for the pad being edited.
    if _midi_offset = 0
      FillArray slotA_value[_step_part], -1, step_reso
    elseif _midi_offset = 1
      FillArray slotB_value[_step_part], -1, step_reso
    elseif _midi_offset = 2
      FillArray slotC_value[_step_part], -1, step_reso
    elseif _midi_offset = 3
      FillArray slotD_value[_step_part], -1, step_reso  
    endif
    Log {Clearing step }, _step, { at offset }, _midi_offset
    midi_write_last_step = _step
  endif

  if _midi_offset = 0
    slotA_value[_note_part] = _val
  elseif _midi_offset = 1
    slotB_value[_note_part] = _val
  elseif _midi_offset = 2
    slotC_value[_note_part] = _val
  elseif _midi_offset = 3
    slotD_value[_note_part] = _val
  endif

  _midicount = 0
  if pattern_CC_slot_map[_slot_base] > -1
    Inc _midicount
  endif
  if pattern_CC_slot_map[_slot_base +1] > -1
    Inc _midicount
  endif
  if pattern_CC_slot_map[_slot_base +2] > -1
    Inc _midicount
  endif
  if pattern_CC_slot_map[_slot_base +3] > -1
    Inc _midicount
  endif

  midicount[_note_part] = _midicount

//  Log {Recorded midi, CC: }, _cc, {:}, _val, { -> offset: }, _midi_offset, {)},{ part:}, _note_part
@End

@OnAUParameter
  // inputs: _midi_offset, _cc, _val, _slot_base
  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS)  or transpose or midi_rec_mode = MIDI_REC_OFF
    SendMIDICC pattern_midich[active_pattern], _cc, _val
    Exit
  endif

  _slot_base = active_pattern * midi_slots
  _val = GetAUParameter LastAUParameter
  if LastAUParameter = 0
    _midi_offset = 0
    _cc = pattern_CC_slot_map[_slot_base]
  elseif LastAUParameter = 1
    _midi_offset = 1
    _cc = pattern_CC_slot_map[_slot_base+1]
  elseif LastAUParameter = 2
    _midi_offset = 2
    _cc = pattern_CC_slot_map[_slot_base+2]
  elseif LastAUParameter = 3
    _midi_offset = 3
    _cc = pattern_CC_slot_map[_slot_base+3]
  endif

  Log {AU Parameter: }, LastAUParameter, { value: }, (GetAUParameter LastAUParameter), { _midi_offset: }, _midi_offset, { cc: }, _cc

  call @RecordMidiCC
@End

@OnXYChange
  _slot_base = active_pattern * midi_slots

  _val = GetXValue 
  _cc = pattern_CC_slot_map[_slot_base]
  _midi_offset = 0

  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS)  or transpose or midi_rec_mode = MIDI_REC_OFF
    SendMIDICC pattern_midich[active_pattern], _cc, _val
  else
    call @RecordMidiCC
  endif

  _val = GetYValue 
  _cc = pattern_CC_slot_map[_slot_base+1]
  _midi_offset = 1
  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS)  or transpose or midi_rec_mode = MIDI_REC_OFF
    SendMIDICC pattern_midich[active_pattern], _cc, _val
  else
    call @RecordMidiCC
  endif
@End

//  ╔═╗╦ ╦╦╔═╗╔╦╗
//  ╚═╗╠═╣║╠╣  ║ 
//  ╚═╝╩ ╩╩╚   ╩ 

@OnShiftSingleTap
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    Call @SetUIMode_Voices 
  elseif uiMode = UIMODE_VOICES
    Call @SetUIMode_Pads
  elseif uiMode = UIMODE_PADS
    Call @SetUIMode_Buttons
  elseif uiMode = UIMODE_BUTTONS
    Call @SetUIMode_Pads
  elseif uiMode = UIMODE_HELP
    Call @SetUIMode_Buttons
  elseif uiMode = UIMODE_PADS_OPTIONS
    Call @SetUIMode_Pads
  endif
@End

@OnShiftHoldRelease
//  call @SetUIMode_Pads
@End

@OnShiftHold
  call @SetUIMode_Pads_Options
@End

@OnShiftDown
  shiftDownTick = CurrentTimerTicks
@End

@OnShiftUp
  if (CurrentTimerTicks - shiftDownTick) < padAnalyseTicks
    call @OnShiftSingleTap
  else
    call @OnShiftHoldRelease
  endif
  
  shiftDownTick = -1
@End


//  ╔═╗╔═╗╔╦╗       ╦ ╦╔═╗╦  ╔╦╗
//  ╠═╝╠═╣ ║║  ───  ╠═╣║ ║║   ║║
//  ╩  ╩ ╩═╩╝       ╩ ╩╚═╝╩═╝═╩╝

@OnPadHold
  if uiMode = UIMODE_PADS
    if rec_mode = 3
      trig_hold = YES
      resetStepOnNewStep = 1  // REFACTOR: Use only reset_step
      reset_step = pad
    else
      pad_edit_step = pad
      mode_pad_edit = 1
      pad_edit_part = 0 
      if pad < 8
        pad_edit_part_pad = 8  // used for latching pad in UI. "hold to edit" always edits first part of step
      else
        pad_edit_part_pad = 0
      endif
      pad_edit_got_note = NO
      pad_edit_hold = 1
      LabelPad pad, {Editing...} 
      Call @UpdateGUI
    endif
  elseif uiMode = UIMODE_PADS_OPTIONS
    if pad = BTN_MIDI
      LabelPad BTN_MIDI, {✅Cleared}
      Call @ClearActivePatternMidi
    endif
  elseif uiMode = UIMODE_BUTTONS
    if pad = BTN_CLEAR_ALL
      LabelPad BTN_CLEAR_ALL, {✅Cleared}
      Call @ClearSequencer
    elseif pad = BTN_CLEAR_ARMED
      LabelPad BTN_CLEAR_ARMED, {✅Cleared}
      Call @ClearActivePattern
    elseif pad >= 8 and pad <= 14
      if mode_multi_pattern
        _pattern = pad - 8
        active_pattern = _pattern
        LatchPad pad, playing_patterns[_pattern]
      endif

    Call @UpdateGUI

    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
   endif
  endif
@End

//  ╔═╗╔═╗╔╦╗       ╔═╗╦╔╗╔╔═╗╦  ╔═╗  ╔╦╗╔═╗╔═╗
//  ╠═╝╠═╣ ║║  ───  ╚═╗║║║║║ ╦║  ║╣    ║ ╠═╣╠═╝
//  ╩  ╩ ╩═╩╝       ╚═╝╩╝╚╝╚═╝╩═╝╚═╝   ╩ ╩ ╩╩  

@OnPadSingleTap // param: pad
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    if rec_mode = 2
      if (pad_edit_step > 7 AND pad > 7) OR (pad_edit_step <= 7 AND pad <= 7)  // pad and tapped pad are on the same row  
        Exit
      else  
        _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad % step_reso)
        _step = pad_edit_step
        LabelPad pad, (NoteName last_nn, YES) 
        LatchPad pad, YES 
        Call @RecStepInput
      endif
    else
      Call @OnPadSingleTap_InPadEdit
    endif
  elseif uiMode = UIMODE_PADS  // pads
    if rec_mode < 2
      Call @EnterPadEditMode
    elseif rec_mode = 2
      _step = LastPad
      _note_part = (active_pattern * sizeof_pattern) + _step * step_reso
      Call @RecStepInput
    elseif rec_mode = 3
      resetStepOnNewStep = 1  // REFACTOR: Use only reset_step
      reset_step = LastPad
    elseif rec_mode = 5
      play = NO
      reset_step = LastPad
      seq_step = LastPad
      tickCounter = 0
      call @OnMetroPulse    
    endif
  elseif uiMode = UIMODE_PADS_OPTIONS
    Call @OnPadSingleTap_PadOptions

  elseif uiMode = UIMODE_BUTTONS and mode_copy_pattern = YES
    Call @OnPadSingleTap_InCopyPattern

  elseif uiMode = UIMODE_BUTTONS
    Call @OnPadSingleTap_Buttons

  endif
@End

@OnPadSingleTap_InPadEdit
  if (pad_edit_step > 7 AND pad > 7) OR (pad_edit_step <= 7 AND pad <= 7)  // pad and tapped pad are on the same row  
    mode_pad_edit = 0
    Call @UpdateGUI
  else  
    _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
    if voice1[_note_part] > -1
      LabelPad pad_edit_part_pad, {🔵}, (NoteName voice1[_note_part], YES), {:}, (Round gateX[_note_part])
    else
      LabelPad pad_edit_part_pad, {⚪️}
    endif

    pad_edit_part = pad % step_reso // Only step_reso parts
    pad_edit_part_pad = pad // for UI usage like latching pad etc during edit
    pad_edit_got_note = NO

    _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)

    pad_edit_note_part = _note_part // used for Voices mode

    if voice1[_note_part] > -1
      LabelPad pad_edit_part_pad, {🔴}, (NoteName voice1[_note_part], YES), {:}, gateX[_note_part]
    else
      LabelPad pad_edit_part_pad, {🔴}
    endif
    LabelPads {⚠️ Editing }, pad_edit_step, {:} , pad_edit_part, {  ℹ️ SHIFT for voices }
  endif
@End

@EnterPadEditMode
  mode_pad_edit = 1
  pad_edit_step = pad
  pad_edit_part = 0
  pad_edit_got_note = NO
  if pad < 8
    pad_edit_part_pad = 8 // for UI usage like latching pad etc during edit
  else
    pad_edit_part_pad = 0
  endif

  _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
  pad_edit_note_part = _note_part // used for Voices mode
  
  Call @UpdateGUI
@End

@OnPadSingleTap_InCopyPattern
  mode_copy_pattern = NO
  if pad < 8
    exit
  endif
  _pattern = pad - 8
  _src_pattern_pos = active_pattern * sizeof_pattern
  _dest_pattern_pos = _pattern * sizeof_pattern

  Call @CopyPattern
  LabelPad _pattern + 8, {P}, active_pattern+1, {CPY, ARM}
  LatchPad active_pattern+8, 0
  LatchPad _pattern + 8, 1
  active_pattern = _pattern  // Auto-arm after copy
@End

@OnPadSingleTap_PadOptions
  if pad = BTN_MIDI
    midi_rec_mode = (midi_rec_mode + 1) % 3

    if midi_rec_mode = MIDI_REC_OFF
      LabelPad BTN_MIDI, {CC rec ⚪}
    elseif midi_rec_mode = MIDI_REC_WRITE
      LabelPad BTN_MIDI, {CC rec 🔴}
    elseif midi_rec_mode = MIDI_REC_OVERDUB
      LabelPad BTN_MIDI, {CC rec 🅾️}
    endif

    if midi_rec_mode = MIDI_REC_OFF
      LabelPads {CC ⚪ OFF}
    elseif midi_rec_mode = MIDI_REC_WRITE
      LabelPads {CC 🔴 WRITE }
    elseif midi_rec_mode = MIDI_REC_OVERDUB
      LabelPads {CC 🅾️ OVERDUB}
    endif
  endif
@End

@OnPadSingleTap_Buttons  
//  if pad = BTN_TRANSPOSE
//    transpose = not transpose
//    LabelPad BTN_TRANSPOSE, { Transpose: }, transpose
//    LabelPads {⚠️Transpose: }, transpose

  if pad = BTN_CLEAR_ALL
    LabelPads {⚠️ Hold Clear All pad to clear all patterns ⚠️}
    LabelPad BTN_CLEAR_ALL, {️⚠️hold=clr}

️  elseif pad = BTN_CLEAR_ARMED
    LabelPads {⚠️ Hold Clear Armed pad to clear current pattern ⚠️}
    LabelPad BTN_CLEAR_ALL, {️⚠️hold=clr}
  
  elseif pad = 1  // Track options
    call @SetUIMode_Pads_Options

//  elseif pad = BTN_RECORD
//    record = not record
//    Call @UpdateGUI

 // elseif pad = BTN_QUANTIZE
 //   quantize = (quantize + 1) % 3
 //   Call @UpdateGUI

  elseif pad = BTN_COPY_PATTERN
    LabelPads { Select pattern to copy active pattern to }
    mode_copy_pattern = YES

  elseif pad = BTN_MULTI_PATTERN
      mode_multi_pattern = not mode_multi_pattern
      if mode_multi_pattern
        LabelPads { Select patterns to play simultaneously }
        LabelPad BTN_MULTI_PATTERN, {Multi: ON}
      else
        LabelPads { Single pattern arm mode }
        LabelPad BTN_MULTI_PATTERN, {Multi: OFF}
      endif
      Call @UpdateGUI

  elseif pad = BTN_HELP
    Call @SetUIMode_Help

  elseif pad >= 8 and pad <= 14     // Pattern ARM. Future proof with upper bound ;)
    if mode_multi_pattern
      _pattern = pad - 8
      active_pattern = _pattern
      _current_state = playing_patterns[_pattern]
      _new_state = not _current_state

      playing_patterns[_pattern] = _new_state
      LatchPad pad, playing_patterns[_pattern]
    else
      last_active_pattern = active_pattern
      active_pattern = pad-8
    endif

    Call @UpdateGUI

    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
  endif
@End

//  ╔═╗╔═╗╔╦╗       ╔╦╗╔═╗╦ ╦╔╗ ╦  ╔═╗  ╔╦╗╔═╗╔═╗
//  ╠═╝╠═╣ ║║  ───   ║║║ ║║ ║╠╩╗║  ║╣    ║ ╠═╣╠═╝
//  ╩  ╩ ╩═╩╝       ═╩╝╚═╝╚═╝╚═╝╩═╝╚═╝   ╩ ╩ ╩╩  

@OnPadDoubleTap
  if uiMode = UIMODE_BUTTONS or uiMode = UIMODE_PADS_OPTIONS
    Exit
  endif
  if mode_pad_edit = 1 
    del_step_part = pad % 8
    del_step = pad_edit_step
    del_step_pos = del_step * step_reso + del_step_part // The note location in the wide grid

    _del_note_part = (active_pattern * sizeof_pattern) + del_step_pos

    polycount[_del_note_part] = 0
    voice1[_del_note_part] = -1
    voice2[_del_note_part] = -1
    voice3[_del_note_part] = -1
    voice4[_del_note_part] = -1
    voice5[_del_note_part] = -1
    voice6[_del_note_part] = -1
    velocity[_del_note_part] = 100
    gateX[_del_note_part] = 100
    note_velocityX[_del_note_part] = 100
    note_probability[_del_note_part] = 100
    note_repeat[_del_note_part] = 1    
    note_strum[_del_note_part] = 0
    slotA_value[_del_note_part] = -1
    slotB_value[_del_note_part] = -1
    slotC_value[_del_note_part] = -1
    slotD_value[_del_note_part] = -1
    LatchPad pad, 0
    LabelPad pad, { }
  else
    del_step = pad
    del_note_part = del_step * step_reso // The note location in the wide grid

    for po = 0 to step_reso - 1
      _del_note_part = (active_pattern * sizeof_pattern) + (del_note_part + po) 
      polycount[_del_note_part] = 0
      voice1[_del_note_part] = -1
      voice2[_del_note_part] = -1
      voice3[_del_note_part] = -1
      voice4[_del_note_part] = -1
      voice5[_del_note_part] = -1
      voice6[_del_note_part] = -1
      velocity[_del_note_part] = 100
      note_velocityX[_del_note_part] = 100
      note_probability[_del_note_part] = 100
      gateX[_del_note_part] = 100
      note_repeat[_del_note_part] = 1
      note_strum[_del_note_part] = 0
      slotA_value[_del_note_part] = -1
      slotB_value[_del_note_part] = -1
      slotC_value[_del_note_part] = -1
      slotD_value[_del_note_part] = -1
    endfor
  
    LatchPad del_step, 0
    LabelPad del_step, { }
  endif
@End

//  ╦╔═╔╗╔╔═╗╔╗ ╔═╗
//  ╠╩╗║║║║ ║╠╩╗╚═╗
//  ╩ ╩╝╚╝╚═╝╚═╝╚═╝

@OnKnobChange
  if uiMode = UIMODE_PADS 
    call @OnKnobChange_Pads
  elseif uiMode = UIMODE_PADS_OPTIONS
    call @OnKnobChange_PadOptions
  elseif uiMode = UIMODE_BUTTONS
    call @OnKnobChange_Buttons
  elseif uiMode = UIMODE_VOICES
    call @OnKnobChange_Voices
  endif
@End

@OnKnobChange_Voices
  _part = pad_edit_note_part
  _value = GetKnobValue LastKnob
  _voice = LastKnob + 1
 
  if polycount[_part] < _voice and _voice <= 6
    polycount[_part] = _voice
  endif
  
  if LastKnob = 0
    voice1[_part] = _value
    LabelKnob 0, (NoteName _value, YES)
  elseif LastKnob = 1
    voice2[_part] = _value
    LabelKnob 1, (NoteName _value, YES)
  elseif LastKnob = 2
    voice3[_part] = _value
    LabelKnob 2, (NoteName _value, YES)
  elseif LastKnob = 3
    voice4[_part] = _value
    LabelKnob 3, (NoteName _value, YES)
  elseif LastKnob = 4
    voice5[_part] = _value
    LabelKnob 4, (NoteName _value, YES)
  elseif LastKnob = 5
    voice6[_part] = _value
    LabelKnob 5, (NoteName _value, YES)
  elseif LastKnob = 11  // gate. knob is mapped linearly from 0-100% for the first 1/4 of the slider, then from 100-1600 for the "upper" 75%.
    _ntx = _value
    if _ntx <= 32
      _ntx = Round(_ntx * 3.125)
    else
      _ntx = Round(((_ntx-32) / 95) * 1500) + 100
    endif
    gateX[_part] = _ntx
    LabelKnobs _ntx, {%}
    
  elseif LastKnob = 14 
    _p = Round(_value / 127 * 100)
    note_probability[_part] = _p
    LabelKnobs _p, {%}
  
  elseif LastKnob = 15
    _rpts = (Round (TranslateScale _value, 1, 127, 1, 6))
    note_repeat[_part] = _rpts
    LabelKnobs _rpts 

  elseif LastKnob = 12 
    _vxknob = _value
    if _vxknob = 0
      _vx = -1
    elseif _vxknob < 60
      _vx = TranslateScale _vxknob, 1, 60, 0, 1
    elseif _vxknob > 68
      _vx = TranslateScale _vxknob, 69, 127, 1, 10
    else
      _vx = 1.0
    endif
    note_velocityX[_part] = _vx
    if _vx >= 0
      LabelKnobs (Round _vx * 100), {%}
    else
      LabelKnobs {⚠️Unset=Uses pattern velocity setting}
    endif

    _vcurve = _vx
    _n = voice1[_part]
    _n1 = _n

    _v = Clip voice1_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 0, (NoteName _n, YES), {:}, Round _v

    _n = voice2[_part]
    _v = Clip voice2_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 1, (NoteName _n, YES), {:}, Round _v

    _n = voice3[_part]
    _v = Clip voice3_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 2, (NoteName _n, YES), {:}, Round _v

    _n = voice4[_part]
    _v = Clip voice4_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 3, (NoteName _n, YES), {:}, Round _v

    _n = voice5[_part]
    _v = Clip voice5_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 4, (NoteName _n, YES), {:}, Round _v

    _n = voice6[_part]
    _v = Clip voice6_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 5, (NoteName _n, YES), {:}, Round _v

  elseif LastKnob = 13
      _value = TranslateScale _value, 0, 127, 0, 200
      note_strum[_part] = _value
      LabelKnobs (Round _value), {ms}

  elseif LastKnob = 18
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots] = _value
    LabelKnob 18, {A:CC }, _value
    LabelKnobs {CC}, _value, {⚠️ Affects whole pattern! ⚠️}

  elseif LastKnob = 7
    _value = Round _value
    slotA_value[_part] = _value
    LabelKnob 7, {A: }, _value
    
  elseif LastKnob = 19
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots +1] = _value
    LabelKnob 19, {B:CC }, _value
    LabelKnobs {CC}, _value, {⚠️ Affects whole pattern! ⚠️}

  elseif LastKnob = 8
    _value = Round _value
    slotB_value[_part] = _value
    LabelKnob 8, {B: }, _value

  elseif LastKnob = 20
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots +2] = _value
    LabelKnob 20, {C:CC }, _value
    LabelKnobs {CC}, _value, {⚠️ Affects whole pattern! ⚠️}

  elseif LastKnob = 9
    _value = Round _value
    slotC_value[_part] = _value
    LabelKnob 9, {C: }, _value

  elseif LastKnob = 21
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots +3] = _value
    LabelKnob 21, {D:CC }, _value
    LabelKnobs {CC}, _value, {⚠️ Affects whole pattern! ⚠️}

  elseif LastKnob = 10
    _value = Round _value
    slotD_value[_part] = _value
    LabelKnob 10, {D: }, _value
  endif
@End

@OnKnobChange_PadOptions
  _value = GetKnobValue LastKnob

  if LastKnob = KNOB_GATE
    gateX_knob = Round((GetKnobValue KNOB_GATE) / 127 * 800)  
    if gateX_knob < 6.25
      gateX_knob = -1 // "As Played"
      LabelKnobs {As Played}
    else
      LabelKnobs gateX_knob*1.000, {%}
    endif
    if gateX_knob > 0 and mode_pad_edit = 1    // REFACTOR: use pad_edit_note_part below (and in other similar places)
      gateX[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = gateX_knob
//      Log {Recording gate change for }, pad_edit_step, {:}, pad_edit_part
    elseif gateX_knob > 0 and midi_rec_mode <> MIDI_REC_OFF
    // Record knob movement - to *next* part as the current has already sent its midi notes. 
      _np = (note_part + 1) % sizeof_pattern 
      gateX[(active_pattern * sizeof_pattern) + _np] = gateX_knob
    endif

  elseif LastKnob = KNOB_VELOCITY
    _vxknob = GetKnobValue KNOB_VELOCITY
    if _vxknob = 0
      _vx = -1
    elseif    _vxknob < 60
      _vx = TranslateScale _vxknob, 1, 60, 0, 1
    elseif _vxknob > 68
      _vx = TranslateScale _vxknob, 69, 127, 1, 10
    else
      _vx = 1.0
    endif

    if mode_pad_edit = 1
      note_velocityX[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _vx
    elseif midi_rec_mode <> MIDI_REC_OFF    // Record knob movement - to *next* part as the current has already sent its midi notes. 
      _np = (note_part + 1) % sizeof_pattern 
      note_velocityX[(active_pattern * sizeof_pattern) + _np] = _vx
    endif
    if _vx >= 0
      LabelKnobs (Round _vx * 100), {%}
    else
      LabelKnobs {As played}
    endif
    pattern_velocurve[active_pattern] = _vx

  elseif LastKnob = KNOB_STRUM
    _s = (TranslateScale (GetKnobValue KNOB_STRUM), 0, 127, 0, 200)
    pattern_strum[active_pattern] = _s
    if mode_pad_edit = 1
      note_strum[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _s
    elseif midi_rec_mode <> MIDI_REC_OFF    // Record knob movement - to *next* part as the current has already sent its midi notes. 
      _np = (note_part + 1) % sizeof_pattern 
      note_strum[(active_pattern * sizeof_pattern) + _np] = _s
    endif
    LabelKnobs (Round _s)

  elseif LastKnob = 3
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots] = _value
    LabelKnob 3, {A:CC }, _value
    LabelKnobs {CC}, _value, {⚠️ Affects whole pattern! ⚠️}

  elseif LastKnob = 4
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots +1] = _value
    LabelKnob 4, {B:CC }, _value
    LabelKnobs {CC}, _value, {⚠️ Affects whole pattern! ⚠️}

  elseif LastKnob = 8
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots +2] = _value
    LabelKnob 8, {C:CC }, _value
    LabelKnobs {CC}, _value, {⚠️ Affects whole pattern! ⚠️}

  elseif LastKnob = 9
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots +3] = _value
    LabelKnob 9, {D:CC }, _value
    LabelKnobs {CC}, _value, {⚠️ Affects whole pattern! ⚠️}
  endif
@End

@OnKnobChange_Buttons
  call @OnKnobChange_Pads
@End

@OnKnobChange_Pads
  _value = GetKnobValue LastKnob

  if LastKnob = KNOB_RECMODE
    if (Round (TranslateScale _value, 0, 127, 0, 5)) <> rec_mode
      rec_mode = Round (TranslateScale _value, 0, 127, 0, 5)

      // defaults
      play = YES
      record = NO
      transpose = NO
      FillArray padExclude, NO, 16

      if rec_mode = 0
        LabelKnob KNOB_RECMODE, {Rec off ⚪️}
        LabelKnobs {Rec off ⚪️}
      elseif rec_mode = 1
        record = YES
        LabelKnob KNOB_RECMODE, {Live 🔴}
        LabelKnobs {Live & step 🔴}
      elseif rec_mode = 2
        LabelKnob KNOB_RECMODE, {Last 🔴}
        LabelKnobs {Tap=🔴 last note}
      elseif rec_mode = 3
        LabelKnob KNOB_RECMODE, {Trig ⚪️}
        LabelKnobs {Tap=trig step ⚪️}
      elseif rec_mode = 4
        transpose = YES
        LabelKnob KNOB_RECMODE, {Transp ⚠️}
        LabelKnobs {Transpose ⚠️}
      elseif rec_mode = 5
        FillArray padExclude, YES, 16  // exclude all pads from "hold detection" by PadManager
        LabelKnob KNOB_RECMODE, {Pads}
        LabelKnobs {Pads}
      endif
    endif
  elseif LastKnob = KNOB_STEP
    currentDivisor = Round (_value / 16)
    if currentDivisor = 0
      LabelKnobs {1/32}
      LabelKnob KNOB_STEP, {1/32}
    elseif currentDivisor = 1
      LabelKnobs {1/16}
      LabelKnob KNOB_STEP, {1/16}
    elseif currentDivisor = 2
      LabelKnobs {1/8t}
      LabelKnob KNOB_STEP, {1/8t}      
    elseif currentDivisor = 3
      LabelKnobs {1/8}
      LabelKnob KNOB_STEP, {1/8}
    elseif currentDivisor = 4
      LabelKnobs {1/4}
      LabelKnob KNOB_STEP, {1/4}
    elseif currentDivisor = 5
      LabelKnobs {1/2}
      LabelKnob KNOB_STEP, {1/2}
    elseif currentDivisor = 6
      LabelKnobs {bar}
      LabelKnob KNOB_STEP, {bar}
    elseif currentDivisor = 7
      LabelKnobs {2 bar}
      LabelKnob KNOB_STEP, {2 bar}
    endif
    call @ComputeTimes

  elseif LastKnob = KNOB_MIDICH
    _midich = RoundDown(_value / 128 * 16)
    pattern_midich[active_pattern] = _midich
    LabelKnobs _midich + 1
    LabelKnob KNOB_MIDICH, {MidiCH }, _midich + 1
  
  elseif LastKnob = KNOB_QUANT
    quantize = Round (TranslateScale _value, 0, 127, 0, 2)
    if quantize = QUANT_NONE
      LabelKnobs {None}
      LabelKnob KNOB_QUANT, {Q: None} 
    elseif quantize = QUANT_PART
      LabelKnobs {Part (1/8 step)}
      LabelKnob KNOB_QUANT, {Q: Part} 
    else // QUANT_STEP
      LabelKnob KNOB_QUANT, {Q: Step}
      LabelKnobs {Step}
    endif
  endif
@End

//  ╔═╗╔═╗╔═╗╦ ╦  ╔═╗╔═╗╔╦╗╔╦╗╔═╗╦═╗╔╗╔
//  ║  ║ ║╠═╝╚╦╝  ╠═╝╠═╣ ║  ║ ║╣ ╠╦╝║║║
//  ╚═╝╚═╝╩   ╩   ╩  ╩ ╩ ╩  ╩ ╚═╝╩╚═╝╚╝
// requires
//  _pattern = CopyPattern_pattern
//  _src_pattern_pos = CopyPattern_src_pattern_pos
//  _dest_pattern_pos = CopyPattern_dest_pattern_pos
//  active_pattern
//  _pattern -- the pattern to copy to
@CopyPattern
  CopyArray voice1[_src_pattern_pos], voice1[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2[_src_pattern_pos], voice2[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3[_src_pattern_pos], voice3[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4[_src_pattern_pos], voice4[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5[_src_pattern_pos], voice5[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6[_src_pattern_pos], voice6[_dest_pattern_pos], sizeof_pattern
  CopyArray voice1_velocity[_src_pattern_pos], voice1_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2_velocity[_src_pattern_pos], voice2_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3_velocity[_src_pattern_pos], voice3_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4_velocity[_src_pattern_pos], voice4_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5_velocity[_src_pattern_pos], voice5_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6_velocity[_src_pattern_pos], voice6_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray polycount[_src_pattern_pos], polycount[_dest_pattern_pos], sizeof_pattern
  CopyArray gateX[_src_pattern_pos], gateX[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnTicks[_src_pattern_pos], noteOnTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnDelayTicks[_src_pattern_pos], noteOnDelayTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray note_probability[_src_pattern_pos], note_probability[_dest_pattern_pos], sizeof_pattern
  CopyArray note_velocityX[_src_pattern_pos], note_velocityX[_dest_pattern_pos], sizeof_pattern
  CopyArray note_strum[_src_pattern_pos], note_strum[_dest_pattern_pos], sizeof_pattern
  CopyArray note_repeat[_src_pattern_pos], note_repeat[_dest_pattern_pos], sizeof_pattern

  CopyArray midicount[_src_pattern_pos], midicount[_dest_pattern_pos], sizeof_pattern
  CopyArray slotA_value[_src_pattern_pos], slotA_value[_dest_pattern_pos], sizeof_pattern
  CopyArray slotB_value[_src_pattern_pos], slotB_value[_dest_pattern_pos], sizeof_pattern
  CopyArray slotC_value[_src_pattern_pos], slotC_value[_dest_pattern_pos], sizeof_pattern
  CopyArray slotD_value[_src_pattern_pos], slotD_value[_dest_pattern_pos], sizeof_pattern

  CopyArray pattern_CC_slot_map[active_pattern * midi_slots], pattern_CC_slot_map[_pattern * midi_slots], midi_slots
  pattern_velocurve[_pattern] = pattern_velocurve[active_pattern]
  pattern_strum[_pattern] = pattern_strum[active_pattern]

@End

//  ┌─┐┬  ┌─┐┌─┐┬─┐  ┌─┐┌─┐┌┬┐┌┬┐┌─┐┬─┐┌┐┌┌─┐
//  │  │  ├┤ ├─┤├┬┘  ├─┘├─┤ │  │ ├┤ ├┬┘│││└─┐
//  └─┘┴─┘└─┘┴ ┴┴└─  ┴  ┴ ┴ ┴  ┴ └─┘┴└─┘└┘└─┘

@ClearSequencer
  FillArray polycount, 0
  FillArray voice1, -1
  FillArray voice1_velocity, 0
  FillArray voice2, -1
  FillArray voice2_velocity, 0
  FillArray voice3, -1
  FillArray voice3_velocity, 0
  FillArray voice4, -1
  FillArray voice4_velocity, 0
  FillArray voice5, -1
  FillArray voice5_velocity, 0
  FillArray voice6, -1
  FillArray voice6_velocity, 0
  FillArray midicount, 0
  FillArray slotA_value, -1
  FillArray slotB_value, -1
  FillArray slotC_value, -1
  FillArray slotD_value, -1
  FillArray pattern_CC_slot_map, -1
  FillArray pattern_velocurve, 1.0, 8
  FillArray pattern_strum, 0, 8
  FillArray gateX, 100
  FillArray noteOnTicks, 0
  FillArray noteOnDelayTicks, 0
  FillArray note_probability, 100
  FillArray note_velocityX, -1
  FillArray note_strum, -1
  playing_patterns = [ YES, NO, NO, NO, NO, NO, NO ]
  FillArray note_repeat, 1
@End

@ClearActivePattern
  _pattern_start = active_pattern * sizeof_pattern
  FillArray polycount[_pattern_start], 0, sizeof_pattern
  FillArray voice1[_pattern_start], -1, sizeof_pattern
  FillArray voice1_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice2[_pattern_start], -1, sizeof_pattern 
  FillArray voice2_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice3[_pattern_start], -1, sizeof_pattern 
  FillArray voice3_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice4[_pattern_start], -1, sizeof_pattern 
  FillArray voice4_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice5[_pattern_start], -1, sizeof_pattern 
  FillArray voice5_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice6[_pattern_start], -1, sizeof_pattern
  FillArray voice6_velocity[_pattern_start], 0, sizeof_pattern
  FillArray gateX[_pattern_start], 100, sizeof_pattern
  FillArray noteOnTicks[_pattern_start], 0, sizeof_pattern
  FillArray noteOnDelayTicks[_pattern_start], 0, sizeof_pattern
  FillArray note_velocityX[_pattern_start], -1, sizeof_pattern
  FillArray note_strum[_pattern_start], -1, sizeof_pattern
  FillArray note_probability[_pattern_start], 100 , sizeof_pattern
  FillArray note_repeat[_pattern_start], 1, sizeof_pattern
  FillArray midicount[_pattern_start], 0, sizeof_pattern
  FillArray slotA_value[_pattern_start], -1, sizeof_pattern
  FillArray slotB_value[_pattern_start], -1, sizeof_pattern
  FillArray slotC_value[_pattern_start], -1, sizeof_pattern
  FillArray slotD_value[_pattern_start], -1, sizeof_pattern
  FillArray pattern_CC_slot_map[active_pattern * midi_slots], -1, midi_slots
  pattern_velocurve[active_pattern] = 1.0
  pattern_strum[active_pattern] = 0
@End

@ClearActivePatternMidi
  _pattern_start = active_pattern * sizeof_pattern
  FillArray midicount[_pattern_start], 0, sizeof_pattern
  FillArray slotA_value[_pattern_start], -1, sizeof_pattern
  FillArray slotB_value[_pattern_start], -1, sizeof_pattern
  FillArray slotC_value[_pattern_start], -1, sizeof_pattern
  FillArray slotD_value[_pattern_start], -1, sizeof_pattern 
@End

//   ██████╗ ██╗   ██╗██╗
//  ██╔════╝ ██║   ██║██║
//  ██║  ███╗██║   ██║██║
//  ██║   ██║██║   ██║██║
//  ╚██████╔╝╚██████╔╝██║
//   ╚═════╝  ╚═════╝ ╚═╝

@SetUIMode_Pads
  ShowLayout 2
  uiMode = UIMODE_PADS
  Call @UpdateGUI
@End

@SetUIMode_Pads_Options
  ShowLayout 0
  uiMode = UIMODE_PADS_OPTIONS
  Call @UpdateGUI
@End

@SetUIMode_Voices
  ShowLayout 1
  uiMode = UIMODE_VOICES
  Call @UpdateGUI
@End

@SetUIMode_Help
  ShowLayout 4
  uiMode = UIMODE_HELP
  Call @UpdateGUI
@End

@SetUIMode_Buttons
  ShowLayout 2
  uiMode = UIMODE_BUTTONS
  mode_copy_pattern = NO
  Call @UpdateGUI
@End

@UpdateGUI
  if uiMode = UIMODE_PADS AND mode_pad_edit = 1
    call @GUI_PadEditMode
    Call @GUI_LabelPadEditKnobs

  elseif uiMode = UIMODE_PADS
    call @GUI_PadMode
    Call @GUI_LabelPadKnobs

  elseif uiMode = UIMODE_PADS_OPTIONS
    call @GUI_PadOptionsMode
    Call @GUI_LabelPadOptionsKnobs

  elseif uiMode = UIMODE_BUTTONS
    call @GUI_ButtonMode 
    call @GUI_LabelButtonKnobs
 
  elseif uiMode = UIMODE_VOICES
     call @GUI_VoicesMode
  
  elseif uiMode = UIMODE_HELP
    call @GUI_HelpMode
  endif
@End

@GUI_HelpMode
  // Void for now
@End

@GUI_VoicesMode
  _edit_note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso) + pad_edit_part

  _n = voice1[_edit_note_part]
  _n1 = _n
  _v = voice1_velocity[_edit_note_part] 

  LabelKnob 0, (NoteName _n, YES), {:}, Round _v
  SetKnobValue 0, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice2[_edit_note_part]
  _v = voice2_velocity[_edit_note_part] 
  LabelKnob 1, (NoteName _n, YES), {:}, Round _v
  SetKnobValue 1, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice3[_edit_note_part]
  _v = voice3_velocity[_edit_note_part] 
  LabelKnob 2, (NoteName _n, YES), {:}, Round _v
  SetKnobValue 2, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice4[_edit_note_part]
  _v = voice4_velocity[_edit_note_part] 
  LabelKnob 3, (NoteName _n, YES), {:}, Round _v
  SetKnobValue 3, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice5[_edit_note_part]
  _v = voice5_velocity[_edit_note_part] 
  LabelKnob 4, (NoteName _n, YES), {:}, Round _v
  SetKnobValue 4, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice6[_edit_note_part]
  _v = voice6_velocity[_edit_note_part] 
  LabelKnob 5, (NoteName _n, YES), {:}, Round _v
  SetKnobValue 5, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  LabelKnob 11, {Gate}
  _ntx = gateX[_edit_note_part]
  if _ntx <= 100
    _ntx = Round _ntx / 3.125
  else
    _ntx = Round ((((_ntx - 100) / 1500) * 95) + 32)
  endif
  SetKnobValue 11, _ntx

  LabelKnob 14, {Probability}
  SetKnobValue 14, (TranslateScale note_probability[_edit_note_part], 0, 100, 0, 127)

  LabelKnob 15, {Ratchet}
  SetKnobValue 15, (TranslateScale note_repeat[_edit_note_part], 1, 6, 0, 127)

  LabelKnob 12, {Velocity}
  _vx = note_velocityX[_edit_note_part]
  if _vx = 1
    _vxknob = 64
  elseif _vx > 1
    _vxknob = TranslateScale _vx, 1, 10, 69, 127
  elseif _vx < 1
    _vxknob = TranslateScale _vx, 0, 1, 0, 60
  endif
  SetKnobValue 12, _vxknob
 
  LabelKnob 13, {Strum}
  SetKnobValue 13, (TranslateScale pattern_strum[active_pattern], 0, 200, 0, 127) 
 
  LabelKnob 18, {A:CC }, pattern_CC_slot_map[active_pattern*midi_slots]
  SetKnobValue 18, pattern_CC_slot_map[active_pattern*midi_slots]
  LabelKnob 19, {B:CC }, pattern_CC_slot_map[active_pattern*midi_slots +1]
  SetKnobValue 19, pattern_CC_slot_map[active_pattern*midi_slots + 1]
  LabelKnob 20, {C:CC }, pattern_CC_slot_map[active_pattern*midi_slots+2]
  SetKnobValue 20, pattern_CC_slot_map[active_pattern*midi_slots + 2]
  LabelKnob 21, {D:CC }, pattern_CC_slot_map[active_pattern*midi_slots+3]
  SetKnobValue 21, pattern_CC_slot_map[active_pattern*midi_slots + 3]

  LabelKnob 7, {A: }, slotA_value[_edit_note_part]
  SetKnobValue 7, slotA_value[_edit_note_part]

  LabelKnob 8, {B: }, slotB_value[_edit_note_part]
  SetKnobValue 8, slotB_value[_edit_note_part]

  LabelKnob 9, {C: }, slotC_value[_edit_note_part]
  SetKnobValue 9, slotC_value[_edit_note_part]

  LabelKnob 10, {D: }, slotD_value[_edit_note_part]
  SetKnobValue 10, slotD_value[_edit_note_part]

  LabelKnobs {⚠️ Voices for }, pad_edit_step, {:} , pad_edit_part, {  ⬆️ SHIFT to go back }
  LabelKnob 6, { }
  LabelKnob 16, { }
  LabelKnob 17, { }
@End

@GUI_PadMode

  for _step = 0 to 15
    _voice_cnt = 0
    _part_cnt = 0
    _po = (active_pattern * sizeof_pattern) + (_step * step_reso)
    _pc = polycount[_po+0] + polycount[_po+1] + polycount[_po+2] + polycount[_po+3] + polycount[_po+4] + polycount[_po+5] + polycount[_po+6] + polycount[_po+7]
    _mc = midicount[_po+0] + midicount[_po+1] + midicount[_po+2] + midicount[_po+3] + midicount[_po+4] + midicount[_po+5] + midicount[_po+6] + midicount[_po+7]
    
    if _pc > 0
      LatchPad _step, 1
      if _mc > 0
        LabelPad _step,polycount[_po+0],polycount[_po+1],polycount[_po+2],polycount[_po+3],polycount[_po+4],polycount[_po+5],polycount[_po+6],polycount[_po+7], { A}
      else
        LabelPad _step,polycount[_po+0],polycount[_po+1],polycount[_po+2],polycount[_po+3],polycount[_po+4],polycount[_po+5],polycount[_po+6],polycount[_po+7]
      endif
    else
      LatchPad _step, 0
      if _mc > 0
        LabelPad _step, {A}
      else
        LabelPad _step, { }
      endif
    endif
  endfor
  
  call @TrackLabels
@End

@OLD_labelpads_in_PadMode
  
 if transpose and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ ⚪️ }, { transpose: }, transpose, { Play: Multi}, { quant: }, quantize
  elseif transpose
    LabelPads  {P}, active_pattern+1,{ ⚪️ SOLO}, { transpose: }, transpose, { quant: }, quantize
  elseif record and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ 🔴 }, { Play: Multi}, { quant: }, quantize
  elseif record
    LabelPads  {P}, active_pattern+1,{ 🔴 SOLO}, { quant: }, quantize
  endif
  
@End

@GUI_PadOptionsMode
  LabelPads {Pattern Options}

  if midi_rec_mode = MIDI_REC_OFF
    LabelPad BTN_MIDI, {CC rec ⚪}
  elseif midi_rec_mode = MIDI_REC_WRITE
    LabelPad BTN_MIDI, {CC rec 🔴}
  elseif midi_rec_mode = MIDI_REC_OVERDUB
    LabelPad BTN_MIDI, {CC rec 🅾️}
  endif

  LabelPad 1, { }
  LabelPad 2, { }
  LabelPad 3, { }
  
  LabelXY {A/B Pad}
@End

@GUI_PadEditMode
  if pad_edit_step <= 7
    _pad_offset = 8
  else
    _pad_offset = 0
  endif

  for the_part = 0 to step_reso-1
    _note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso + the_part)
    _cnt = polycount[_note_part]
    _mc = midicount[_note_part]
    _pad = the_part + _pad_offset
    if _cnt > 0
      if _mc > 0
        LabelPad _pad, _cnt, {:}, (NoteName voice1[_note_part], YES), {:}, (Round gateX[_note_part]), {A}
      else
        LabelPad _pad, _cnt, {:}, (NoteName voice1[_note_part], YES), {:}, (Round gateX[_note_part])
      endif
      LatchPad _pad, 1
    else // {🔵},
      LatchPad _pad, 0
      if _mc > 0
        LabelPad _pad, {⚪️ A}
      else
        LabelPad _pad, {⚪️}, 
      endif
    endif
  endfor

  _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
  if voice1[_note_part] > -1
    LabelPad pad_edit_part_pad, {🔴}, (NoteName voice1[_note_part], YES), {:}, polycount[_note_part]
  else
    LabelPad pad_edit_part_pad, {🔴}
  endif
  LabelPad pad_edit_step, {✅ Done}
  LabelPads {⚠️ Editing }, pad_edit_step, {:} , pad_edit_part, {  ⬆️ SHIFT for voices }

@End

@GUI_ButtonMode
  for po = 0 to 15
    LabelPad po, { }
    LatchPad po, 0
  endfor
  
  LabelPad BTN_CLEAR_ALL, {Clear all}

  LabelPad 1, {Track options   (hold SHIFT)}
  LabelPad BTN_COPY_PATTERN, {Copy pattern}
  LabelPad BTN_CLEAR_ARMED, {Clear armed}
  LabelPad BTN_HELP, {ℹ️Help}

  if mode_multi_pattern  
    LabelPad BTN_MULTI_PATTERN, {Play: Multi}
    for _pattern = 0 to 6
      if playing_patterns[_pattern] = 1 // and active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { 🔵}
      else
        LabelPad _pattern + 8, {P}, _pattern+1, { ⚪}
      endif
    endfor
  else
    LabelPad BTN_MULTI_PATTERN, {Play: Solo}
    for _pattern = 0 to 6
      if active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { SOLO}
      else
        LabelPad _pattern + 8, {P}, _pattern+1
      endif
    endfor
  endif

  LatchPad 8+active_pattern, 1
  if mode_multi_pattern
    LabelPads {Tap patterns to arm and toggle ON/OFF. Long-press for arm only. ⬆️ SHIFT exits.}
  else
    LabelPads {Tap pattern to solo & arm. ⬆️ SHIFT exits.}
  endif
@End

@GUI_LabelButtonKnobs
  call @GUI_LabelPadKnobs
@End

@GUI_LabelPadKnobs
  LabelKnobs {P}, active_pattern+1, { rec params}
  
  if rec_mode = 0
    LabelKnob KNOB_RECMODE, {Rec off ⚪️}
  elseif rec_mode = 1
    LabelKnob KNOB_RECMODE, {Live 🔴}
  elseif rec_mode = 2
    LabelKnob KNOB_RECMODE, {Last 🔴}
  elseif rec_mode = 3
    LabelKnob KNOB_RECMODE, {Trig ⚪️}
  elseif rec_mode = 4
    LabelKnob KNOB_RECMODE, {Transp ⚠️}
  elseif rec_mode = 5
    LabelKnob KNOB_RECMODE, {Pads}
  endif
  SetKnobValue KNOB_RECMODE, (TranslateScale rec_mode, 0, 5, 0, 127)

  if currentDivisor = 0
    LabelKnob KNOB_STEP, {1/32}
  elseif currentDivisor = 1
    LabelKnob KNOB_STEP, {1/16}
  elseif currentDivisor = 2
    LabelKnob KNOB_STEP, {1/8t}      
  elseif currentDivisor = 3
    LabelKnob KNOB_STEP, {1/8}
  elseif currentDivisor = 4
    LabelKnob KNOB_STEP, {1/4}
  elseif currentDivisor = 5
    LabelKnob KNOB_STEP, {1/2}
  elseif currentDivisor = 6
    LabelKnob KNOB_STEP, {bar}
  elseif currentDivisor = 7
    LabelKnob KNOB_STEP, {2 bar}
  endif

  LabelKnob KNOB_MIDICH, {MidiCH }, pattern_midich[active_pattern] + 1
  SetKnobValue KNOB_MIDICH, pattern_midich[active_pattern]*8+4 

  if quantize = QUANT_NONE
    LabelKnob KNOB_QUANT, {Q: None} 
  elseif quantize = QUANT_PART
    LabelKnob KNOB_QUANT, {Q: Part} 
  else // QUANT_STEP
    LabelKnob KNOB_QUANT, {Q: Step}
  endif
  SetKnobValue KNOB_QUANT, TranslateScale quantize, 0, 2, 0, 127

@End

@GUI_LabelPadOptionsKnobs
  LabelKnobs {Pattern Option Knobs}

  LabelKnob KNOB_GATE, {Gate}
  _ntx = gateX_knob
  if _ntx <= 100
    _ntx = Round _ntx / 3.125
  else
    _ntx = Round ((((_ntx - 100) / 1500) * 95) + 32)
  endif
  SetKnobValue KNOB_GATE, _ntx

  LabelKnob KNOB_VELOCITY, {Velocity}
  _vx = pattern_velocurve[active_pattern]
  if _vx = 1
    _vxknob = 64
  elseif _vx > 1
    _vxknob = TranslateScale _vx, 1, 10, 69, 127
  elseif _vx < 1
    _vxknob = TranslateScale _vx, 0, 1, 0, 60
  endif
  SetKnobValue KNOB_VELOCITY, _vxknob

  LabelKnob KNOB_STRUM, {Strum}
  SetKnobValue KNOB_STRUM, (TranslateScale pattern_strum[active_pattern], 0, 200, 0, 127) 

  LabelKnob 3, {A:CC }, pattern_CC_slot_map[active_pattern*midi_slots]
  SetKnobValue 3, pattern_CC_slot_map[active_pattern*midi_slots]
  LabelKnob 4, {B:CC }, pattern_CC_slot_map[active_pattern*midi_slots +1]
  SetKnobValue 4, pattern_CC_slot_map[active_pattern*midi_slots + 1]
  LabelKnob 8, {C:CC }, pattern_CC_slot_map[active_pattern*midi_slots+2]
  SetKnobValue 8, pattern_CC_slot_map[active_pattern*midi_slots + 2]
  LabelKnob 9, {D:CC }, pattern_CC_slot_map[active_pattern*midi_slots+3]
  SetKnobValue 9, pattern_CC_slot_map[active_pattern*midi_slots + 3]

  LabelKnob 5, { }
  LabelKnob 6, { }
  LabelKnob 7, { }
@End

@GUI_LabelPadEditKnobs
  Call @GUI_LabelPadKnobs
  LabelKnobs pad_edit_step, {:} , pad_edit_part, { params}
@End

//  ╔═╗╔═╗╔╦╗  ╔╦╗╔═╗╔╗╔╔═╗╔═╗╔═╗╦═╗
//  ╠═╝╠═╣ ║║  ║║║╠═╣║║║╠═╣║ ╦║╣ ╠╦╝
//  ╩  ╩ ╩═╩╝  ╩ ╩╩ ╩╝╚╝╩ ╩╚═╝╚═╝╩╚═

@PadManagerOnLoad
  
  // The following vars CAN be set before @InitPadManager. 
  // If they are not defined here, they will be automatically 
  // defined with their defaults in @InitPadManager
  //
  // In the most basic use-case, just Call @InitPadManager 
  // in your OnLoad without setting any of them. 
  
  pmAnalyseTime = 200 
  // Length of double tap / tap-and-hold time window in msec
    
  pmManageTimer = YES
  // Set to NO if your script wants to controll the timer.
  // Your timer needs to run continously and with an update
  // interval faster than 50, otherwise the pad manager 
  // wont work. Also set pmTickInterval accordingly.

  pmTickInterval = timer_tick_resolution    // Update interval for the timer in msec.

  //  pmExcludePads = [7,15]
  pmExcludeCnt = 0

  // List of pad ids and length of list to be excluded from
  // analysis. For these pads OnSingleTap will be called 
  // immediately in 'OnPadDown' without the analysis delay.

  Call @InitPadManager
@End

// ========= Pad Manager V2 =========
// -ki  01.06.2019

@InitPadManager  

  // Apply defaults, if the vars are not yet defined

  if Unassigned pmAnalyseTime
    pmAnalyseTime = 200 
  endif
  if Unassigned pmManageTimer
    pmManageTimer = YES
  endif
  if Unassigned pmTickInterval
    pmTickInterval = 25
  endif
  if Unassigned pmExcludePads
    pmExcludePads = []
  endif
  if Unassigned pmExcludeCnt
    pmExcludeCnt = 0
  endif
  
  padsActiveCnt = 0  
  padMaxId = 15
  for pad = 0 to padMaxId
    Call @InitPadState
  endfor

  if pmExcludeCnt>0
    for pad = 0 to pmExcludeCnt-1
      padExclude[ pmExcludePads[pad] ] = YES
    endfor
  endif

  padAnalyseTicks = pmAnalyseTime / pmTickInterval

  if pmManageTimer
    SetTimerInterval pmTickInterval
  endif
  
  Log {PadManager started (},pmExcludeCnt,{ excluded pads, timer=}, pmTickInterval,{msec)}
@End

@InitPadState // Param: pad
  padActive[pad] = NO
  padTicks[pad] = 0
  padTaps[pad] = 0
  padHold[pad] = NO
  padExclude[pad] = NO
@End

@ReleasePadState // Param: pad
  Dec padsActiveCnt
  if pmManageTimer and padsActiveCnt = 0
//    StopTimer 
  endif
  Call @InitPadState
 @End

@OnPadDown 
  if padExclude[LastPad]
    pad = LastPad
    Call @OnPadSingleTap
  else
    if pmManageTimer and padsActiveCnt = 0
//      StartTimer 
    endif
    if not padActive[LastPad]
      Inc padsActiveCnt
      padActive[LastPad] = YES
    endif
    inc padTaps[LastPad]
  endif
@End 

@OnPadUp 
  if padTaps[LastPad] = 1 and padTicks[LastPad] < padAnalyseTicks
    padHold[LastPad] = YES
  endif
  
  resetStepOnNewStep = NO
  trig_hold = NO // always reset even though we're rarely in this mode. It's just cheaper code this way.

  if pad_edit_hold and LastPad = pad_edit_step
    pad_edit_got_note = NO
    pad_edit_hold = 0
    mode_pad_edit = 0
    Call @UpdateGUI
  endif
@End 

@OnTimer

  CurrentTimerTicks = (CurrentTimerTicks + 1) % 65534  // Wraps around every ~10 minutes
  
  if shiftDownTick <> -1 // Shift has been pressed
    if (CurrentTimerTicks - shiftDownTick) > padAnalyseTicks
      call @OnShiftHold
      shiftDownTick = -1
    endif  
  endif
  
  if padsActiveCnt = 0
    Exit
  endif

  for pad = 0 to padMaxId
    if padActive[pad]
      Inc padTicks[pad]
      if padTicks[pad] > padAnalyseTicks
        if padTaps[pad] = 1
          if padHold[pad]
            Call @OnPadSingleTap
          else
            Call @OnPadHold
          endif
        else
            Call @OnPadDoubleTap
        endif

        Call @ReleasePadState
      endif
    endif
  endfor
@End 

// <<<<<<<<< end of Pad Manager script code >>>>>

@Description
  FLOW 2.0 - 7-pattern, multi-channel, 16x8 step midi looper & sequencer for Mozaic by peblin.
  Featuring:

  - 16 steps with 8 subdivisions (parts) each
  - 6 voice polyphony per part
  - 7 patterns, with midi channel configurable per pattern
  - From 1/32 to 2 bar step length giving 1/2 to 16 bar patterns
  - Live & step recording
  - CC recording & automation with interpolation of CC values between parts
  - Ratcheting / note repetition
  - Strumming mode for chords
  - Transpose mode
  - Live recording stores note duration and timing for (almost) exact playback
  - Individual step / part editing, including voices, probability and duration
  - Note probability & duration can be set per part
  - Patterns play solo or multi - easily toggle patterns ON/OFF for live performance
  - 3 quantization modes for live recording - None (as played), per part, per step

-- Basics --

FLOW's sequencer consists of 16 steps per pattern. Each step is divided into 8 parts - so each part is 1/8 of step length. For example, setting step length using the Step knob to 1 bar, makes each part of the step a 1/8th note.

To get started, just start the host and start playing - the sequencer records whatever you play into the appropriate part and plays is back just as you played it. Double-tap to erase steps & parts, and single-tap on a step to edit its parts.

The sequencer has 4 views;
- Steps; each pad is a step. When a step has parts with notes, the pad will show the number of voices allocated per part in the step. T
- Step edit; shows one row of steps and the other row the parts of the step being edited. Accessed by tapping or holding a pad in Steps view.
- Part edit; shows faders for all voices, gate and probability of a part. Accessed by tapping ⬆️SHIFT when in step edit view.
- Control panel; top row of pads are sequencer controls, bottom row are ARM/ON/OFF toggles for the 7 patterns. Accessed by tapping SHIFT in the Steps view. Exit by tapping SHIFT again.

-- Recording --

Record into the sequencer using either live recording or step recording.

--- Live recording & Quantization ---

In this mode the sequencer records notes, velocities and (optionally) duration into the corresponding part. Live recording has three quantization modes - None, Part and Step. Set the quantisation mode by tapping the Quant button in Control Panel - it cycles between the modes.

- None; This aims to reproduce what you played as close to the original as possible. It keeps the timing of your playing by keeping track of the delay of the "note on" message to when the part started and will delay any playback with the same amount. The accuracy of the delay is 5 milliseconds for now.
- Part; This will quantize to nearest part (pushing note forward to next part if that is closer in time)
- Step; This will quantize to nearest step (pushing note forward to next step if its within 25% of the next step in time)

The sequencer has 6 voice polyphony per part, but only stores timing latency "per step", not "per voice" so any additional voices will play in sync with the first voice of the part.

--- Step recording ---

In this mode you select which step/part to edit, then play up to 6 notes for it. When editing a step, you're actually editing the first part of the step. 

The sequencer supports both "latched" and "hold pad" editing. 
- Latched; Simply tap the step you want to edit, then tap the part from all parts showing on the row above or below the chosen step. Finish recording/editing by tapping the step again, which is now labeled "✅ Done".
- Hold pad; Hold the step you want to edit, then tap the part from all parts showing on the row above or below the chosen step. Finish by releasing the held pad. 

Latched is really helpful on iPhone, while "hold pad" might be quicker on the iPad.

-- Deleting parts or full steps --

To delete a part or all parts in a step, double-tap the step or part pad. 

-- Editing part contents --

When in step edit mode, if you select a part and then press SHIFT you will enter "part edit" mode. Part edit mode shows all 6 voices, note duration and probability.

Drag faders to adjust notes. If you drag a previously unused voice it'll be added to the part - so you can for example add a seventh to a triad chord after recording. Or, tap a bass rythm and then afterwards dial in the desired notes.

It's not super-easy to hit the right note when dragging the fader - suggestions for improved UX welcome.

-- Gate --

The knob "gate" sets the default gate length both for live and step recording. Gate length is measured as "percentage of step length". Thus, a gate of 200% with the sequencer set to "1/8" will give 1/4th notes. This also means that if you change step length for the sequencer, the gate length will scale accordingly.

Note duration knob defaults to "As played", meaning that the sequencer will use your playing (converted to a percentage of step length) as duration.

When in part edit mode, you can set part duration from 5% to 1600% of one step. At 1600%, the note will be held for the whole cycle when it will trigger again.

When sequencer has CC rec enabled, changes to gate will be saved live as the sequencer plays. 

-- Probability --

The "probability" knob sets the default probability for step-sequenced parts. You can also change the part probability using either the probability knob when step recording, or the probability fader in part edit view.

-- Velocity --

The "Velocity" knob sets the default velocity scale factor when recording. Velocity scale factor can be set by part, in step edit mode as well as part edit mode. If you change the velocity scale factor in part edit mode, the faders for each voice will show the resulting velocity as fader label making it somewhat easier to understand what's happening.

Velocity scale factor is set from 0% (mute) to 1000% and will be multiplied with the recorded velocity on playback.

When sequencer has CC rec enabled, changes to velocity scale factor will be saved live as the sequencer plays.

-- Ratcheting --

In part edit mode, you can set ratcheting from 1-6. Ratcheting splits a note into 1 to 6 smaller notes, triggering over the same gate duration as the original note. So, with ratcheting set to 3 and gate at 100% you will get one note at start part, one at 1/3 of the step length and one at 2/3 of step length.

By experimenting with gate length it's very easy to make ratcheting "humanized" to create more varied fills. At the extreme, with gate length at 1600% and ratcheting set to 6 the note will trigger 6 times over the full sequencer cycle - perfect for weird ghost notes :)

-- Strumming --

You can set strum in milliseconds per pattern and/or per part (in both step and part edit modes). 

Voice playback will be strummed by delaying each voice with the strum amount multiplied with voice number (starting with 0). So, a strum value of 10ms will play voice0 at time 0, voice1 10ms later, voice2 20ms later and so on. 

By recording chords “in reverse”, ie highest note first, you can simulate both up and down strums as if it were a guitar. Strumming can also be used creatively with drums if several drum hits are on the same part - by setting the strum value they’ll be slightly separated, for a more humanized feel.

When sequencer has CC rec enabled, changes to strum will be saved live as the sequencer plays. 

-- Pattern Midi Channel --

Each pattern can have its own midi channel for sending notes. Set the channel using the Midi CH knob and enjoy.

-- Play modes --

The sequencer can play each pattern SOLOed, or multiple patterns simultaneously. Toggle play mode with the "Play" button in the Control Panel.

--- Play: Solo ---

Only one pattern plays at a time and the playing pattern is also armed for recording. Change to the desired pattern in the Control Panel.

--- Play: Multi ---

Multiple patterns can play simultaneously, either on the same midi channel or using several depending on the midi channel setting for each pattern.

Toggle patterns ON/OFF in the Control Panel. Single-tapping on a pattern will toggle it ON/OFF and make it the armed pattern. Long-pressing on a pattern (tap and hold for approx 200ms+) will arm it, but not toggle the ON/OFF state. This way you can switch between editing different playing patterns without interrupting playback.

-- CC recording --

Flow can record incoming Midi CC commands per pattern. Even "empty" patterns (ie patterns with no notes) can record CCs so it's possible to record "CC phrases" such as different filter sweeps and then trigger them by toggling the recorded patterns on and off.

Tap the "CC rec" button in the Control Panel to toggle between OFF, 🔴 WRITE and 🅾️ OVERDUB.

In WRITE mode, incoming CC values will result in the current step being cleared (only once per loop), then stored in the corresponding sequencer part. For smooth knob movements this means that incoming values will "overwrite" previously stored ones (for that CC command), if values are coming a rate of at least once every step.

In OVERDUB mode, incoming CC values are stored "as is" per part in the sequencer. This can be used creatively to yield glitchy effects when filters jump around wildly - but will give wild results. 🔥

Flow has 4 "CC slots" and can store values for up to 4 different CCs per pattern. Slots are allocated on a first come basis - so if the sequencer receives sustain, mod wheel, cutoff and resonance CCs the slots for the active pattern are full and additional CC commands will be passed thru but not stored.

TIP: Recorded CC commands and values can be seen and changed in the "part edit mode" where you'll find knobs for all 4 slots (labeled A-D). 
⚠️ Note that if you change the CC#, it'll change the CC for that slot for the whole pattern as slots are "pattern level". The value is of course per part, so no risk in changing that.

--- CC playback and interpolation ---

For patterns with step length less than 1/4, playback of recorded CCs is quantized to the last recorded CC value of each part. 

For patterns with longer steps - from 1/4 to 2 bars - Flow will interpolate CC values to "smooth" the sampled CC values. The amount of extra/interpolated values varies depending on step length - from 1 extra for 1/4th notes to 15 extra for 2 bar notes. This is very useful for long, evolving pads. 🌊

-- Transpose mode --

With transpose active, the sequencer will stop live recording and treat incoming midi notes as "pitch offset", with C3/midi note 48 as base pitch. So, playing G3 will transpose +7 semitones, while a B2 will transpose -1.

Transpose is applied to all outgoing notes - so in Play:Multi all playing patterns will be transposed. This behaviour might change in the future - suggestions welcome.

-- Copying patterns --

To copy a pattern, first make sure it's the armed pattern then press "Copy Pattern" in Control Panel. Then select the pattern to copy to. Everything except midi channel will be copied.

-- Clearing patterns --

"Clear armed" will clear the currently armed pattern, except for midi channel.
"Clear all" will clear all patterns. To prevent accidental disaster, both clear buttons requires you to long-press on the button.

- THANKS -

  Inspired by OP-Z and https://patchstorage.com/infinity
  Thanks to -ki for https://patchstorage.com/pad-manager-include and great contributions to the community
  Thanks to all members of the Audiobus Forum for inspiration and good feedback on Flow.

  And most of all thanks to Bram Bos for creating one of the most game-changing iOS music apps ever.

@End