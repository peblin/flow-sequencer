@Onload
  SetShortName {Flow} 
  ShowLayout 2
  CurrentTimerTicks = 0
  last_pulse_ticks = 0
  timer_tick_resolution = 5 // Milliseconds per tick

  Call @PadManagerOnLoad

  step_reso = 8  // Grid/parts per step
  part_reso = 1 // REMOVE? Pulses per part
  poly = 6       // Max polyphony per part
  sizeof_pattern = 16*8      // Size of storing all step parts in an array

  // -- CONSTANTS -- 

  UIMODE_PADS = 1
  UIMODE_BUTTONS = 2
  UIMODE_VOICES = 3
  UIMODE_HELP = 4

  // Buttons
  BTN_MULTI_PATTERN = 0
  BTN_RECORD = 1
  BTN_MIDI = 2
  BTN_QUANTIZE = 3
  BTN_TRANSPOSE = 4
  BTN_COPY_PATTERN = 5
  BTN_CLEAR_ALL = 6
  BTN_CLEAR_ARMED = 7
  BTN_HELP = 15

  // Knobs
  KNOB_STEP = 0
  KNOB_NOTETIME = 1
  KNOB_PROBABILITY = 2
  KNOB_MIDICH = 3
  
  poly_offset = 0
  note_pos = 0
  note_part = 0
  seq_step = 0 // this is internal to IncrementSequencer, use step below as its updated in "sync" with note_part and step_part
  step = 0
  pad_edit_step = 0
  loops = 0 // number of sequencer loops run since host start
  
  // tracks total ticks since start of transport. might wrap, but that wont kill anyone....i think
  total_tickCounter = 0  

// tracks if a note was received while holding a pad - in which case we can exit pad edit mode on pad release
  pad_edit_got_note = YES
  pad_edit_hold = 0  
  pad_edit_part_pad = 0
  pad_edit_note_part = 0 

  // states for UI
  
  resetStepOnNewStep = 0
  mode_pad_edit = 0
  mode_copy_pattern = NO
  clear_confirm = NO
  if Unassigned record
    record = 1 // Rec enabled by default
    transpose = NO
    transposeNote = 0
    mode_multi_pattern = NO
    midi_rec_mode = 0
  endif

  _res = step_reso * part_reso
  PPQN = [8*_res, 4*_res, 3*_res, 2*_res, _res, _res/2, _res/4, _res/8]

  // quantization
  QUANT_NONE = 0
  QUANT_PART = 1
  QUANT_STEP = 2
  quantize = QUANT_NONE

  // midi recording
  if Unassigned midi_rec_mode
    midi_rec_mode = 0
  endif
  MIDI_REC_OFF = 0
  MIDI_REC_WRITE = 1
  MIDI_REC_OVERDUB = 2
  
  midi_write_last_step = -1
  midi_write_last_loop = -1
  midi_slots = 4
  
  if Unassigned currentDivisor
    currentDivisor = 3
    count = 1
    tickCounter = 0
    noteTimeX_knob = -1
    probability_knob = 100
  endif

  SetKnobValue KNOB_STEP, 48          // 1/8
  SetKnobValue KNOB_NOTETIME, 0       // As played
  SetKnobValue KNOB_PROBABILITY, 127  // 100%
  SetKnobValue KNOB_MIDICH, 1         // Default Midi Channel 1

  call @ComputeTimes
  Call @InitSequencer

  if Unassigned last_active_pattern
    last_active_pattern = 1
  endif
  active_pattern = 0
  StartTimer 
  call @SetUIMode_Pads
@End

//  ╦╔╗╔╦╔╦╗   ┬   ╔╦╗╦╔╦╗╔═╗
//  ║║║║║ ║   ┌┼─   ║ ║║║║║╣ 
//  ╩╝╚╝╩ ╩   └┘    ╩ ╩╩ ╩╚═╝  

@IncrementSequencer
  Inc tickCounter
  Inc total_tickCounter

  if tickCounter >= countPerStep
    tickCounter = 0
    if resetStepOnNewStep = 1
      resetStepOnNewStep = 0
      seq_step = reset_step
    else
      Inc seq_step
      if seq_step > 15
        seq_step = 0
        Inc loops
      endif
    endif
  endif
@End 

@ComputeTimes
  tickTime = QuarterNote / PPQN[currentDivisor] * part_reso 
  stepTime = tickTime * step_reso
  noteTime = stepTime
  countPerStep = step_reso * part_reso 
  SetMetroPPQN PPQN[currentDivisor]
@End

@OnHostStart
  seq_step = 0
  step = 0
  note_pos = 0
  note_part = 0  
  tickCounter = 0
  total_tickCounter = 0
  CurrentTimerTicks = 0  // "Optimistically" reset timer tick count on host start to reduce prob that it wraps during recording
  loops = 0
@End 

@InitSequencer
  if Unassigned polycount
    Call @ClearSequencer
    pattern_midich = [0,0,0,0,0,0,0]
  endif
@End

//  ╔╦╗╔═╗╔╦╗╦═╗╔═╗   ┬   ╔╦╗╦╔╦╗╦
//  ║║║║╣  ║ ╠╦╝║ ║  ┌┼─  ║║║║ ║║║
//  ╩ ╩╚═╝ ╩ ╩╚═╚═╝  └┘   ╩ ╩╩═╩╝╩

@OnMetroPulse   
  last_pulse_ticks = CurrentTimerTicks
  step = seq_step
  step_part = Round(((tickCounter+1) / countPerStep) * step_reso) - 1
  if step_part >= step_reso
    step_part = 0
    step = (step + 1) % 16
  endif
  note_part = (step * step_reso + step_part) // The note location in the wide grid
  
  for _pattern = 0 to 6 
    if (mode_multi_pattern = 0 and active_pattern=_pattern) or (mode_multi_pattern = 1 and playing_patterns[_pattern] = YES)

      _note_part = (_pattern * sizeof_pattern) + note_part
      _ch = pattern_midich[_pattern]
      _slot_base = active_pattern * midi_slots

      _cc = pattern_CC_slot_map[_slot_base]
      if midi1_value[_note_part] >= 0 and _cc >= 0
        SendMIDICC _ch, _cc, midi1_value[_note_part], 1
        Log step, {:}, step_part, { CC },  _cc, {:}, midi1_value[_note_part]
      endif
      _cc = pattern_CC_slot_map[_slot_base + 1]
      if midi2_value[_note_part] >= 0 and _cc >= 0
        SendMIDICC _ch, _cc, midi2_value[_note_part], 2
        Log step, {:}, step_part, { CC },  _cc, {:}, midi2_value[_note_part]
      endif
      _cc = pattern_CC_slot_map[_slot_base + 2]
      if midi3_value[_note_part] >= 0 and _cc >= 0
        SendMIDICC _ch, _cc, midi3_value[_note_part], 3 
        Log step, {:}, step_part, { CC },  _cc, {:}, midi3_value[_note_part]
      endif
      _cc = pattern_CC_slot_map[_slot_base + 3]
      if midi4_value[_note_part] >= 0 and _cc >= 0
        SendMIDICC _ch, _cc, midi4_value[_note_part], 4
        Log step, {:}, step_part, { CC },  _cc, {:}, midi4_value[_note_part]
      endif

      if voice1[_note_part] >= 0 and ((Random 1, 100) <= note_probability[_note_part])
        _transposeNote = 0
        if transpose 
          _transposeNote = transposeNote
        endif

        _polycount = polycount[_note_part]
        _noteDelay = noteOnDelayTicks[_note_part] * timer_tick_resolution
        _noteTime = noteTime * (noteTimeX[_note_part] / 100) + _noteDelay

        if _polycount > 5
          SendMIDINoteOn _ch, voice6[_note_part] + _transposeNote, voice6_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice6[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 4
          SendMIDINoteOn _ch, voice5[_note_part] + _transposeNote, voice5_velocity[_note_part], _noteDelay     
          SendMIDINoteOff _ch, voice5[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 3
          SendMIDINoteOn _ch, voice4[_note_part] + _transposeNote, voice4_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice4[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 2
          SendMIDINoteOn _ch, voice3[_note_part] + _transposeNote, voice3_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice3[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 1
          SendMIDINoteOn _ch, voice2[_note_part] + _transposeNote, voice2_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice2[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 0
          SendMIDINoteOn _ch, voice1[_note_part] + _transposeNote, voice1_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice1[_note_part] + _transposeNote, 0, _noteTime
        endif
      endif
    endif
  endfor
  FlashPad step
  Call @IncrementSequencer
@End

@OnMidiNoteOn
  _note_on_ticks = CurrentTimerTicks
  _el_ticks = _note_on_ticks - last_pulse_ticks
  _el_pct = (Round _el_ticks / (tickTime / timer_tick_resolution) * 100)
  nn = MIDINote
  v = MIDIVelocity

  if transpose AND mode_pad_edit <> 1 
    transposeNote = MIDINote - 48
    LabelPads {⚠️Transpose: }, transposeNote
    Exit
  endif
  
  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS)
    SendMidiThruOnCh pattern_midich[active_pattern]
    Exit
  endif
  
  _supressMidiThru = NO
 
  if mode_pad_edit = 1
    pad_edit_got_note = YES
    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 

    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part
 
    if not Unassigned pad_edit_part_pad  // Latch and label when editing parts of step
      LabelPad pad_edit_part_pad, (NoteName nn, YES)
      LatchPad pad_edit_part_pad, 1
    endif

    _supressMidiThru = YES
  else
    _step = step
    if quantize = QUANT_STEP
      if step_part > 5  // if we are within 25% of next step then quantize to that 
        _step = (_step  + 1) % 16
        _supressMidiThru = YES
      endif
      _note_part = (active_pattern * sizeof_pattern) + _step * step_reso
    else
      if quantize = QUANT_PART and _el_pct > 50
        // if note is closer to next part, then quantize to that one
        note_part = (note_part + (Round _el_pct/100)) % (16 * step_reso)
        _supressMidiThru = YES
      endif
      _note_part = (active_pattern * sizeof_pattern) + note_part
    endif
  endif

  if not _supressMidiThru
    SendMidiThruOnCh pattern_midich[active_pattern]
  endif

  _poly_offset = polycount[_note_part]
 
  if _poly_offset = 0
    voice1[_note_part] = nn
    voice1_velocity[_note_part] = v
  elseif _poly_offset = 1
    voice2[_note_part] = nn
    voice2_velocity[_note_part] = v
  elseif _poly_offset = 2
    voice3[_note_part] = nn
    voice3_velocity[_note_part] = v
  elseif _poly_offset = 3
    voice4[_note_part] = nn
    voice4_velocity[_note_part] = v
  elseif _poly_offset = 4
    voice5[_note_part] = nn
    voice5_velocity[_note_part] = v
  elseif _poly_offset = 5
    voice6[_note_part] = nn
    voice6_velocity[_note_part] = v
  endif

  if _poly_offset < 6
    Inc _poly_offset
  endif

  polycount[_note_part] = _poly_offset
  noteOnTicks[_note_part] = CurrentTimerTicks //total_tickCounter

  if quantize = QUANT_NONE and HostRunning  // we can only have delay if metronome is running
    noteOnDelayTicks[_note_part] = _note_on_ticks - last_pulse_ticks
  else
    noteOnDelayTicks[_note_part] = 0
  endif

  // Store part so that MidiNoteOff can reference all data of the note being played
  SetNoteState 0, nn, _note_part    

  if not mode_pad_edit
    if not UIMODE_BUTTONS
      LabelPad _step, _poly_offset, {:}, (NoteName nn, YES) 
    endif
    LatchPad _step, 1
  endif
  last_note = nn      // for single-tap edit
  last_velocity = nn  
@End 

@OnMidiNoteOff

// TODO: Should to send explicit midi command with velocity set to noteTimeX_knob (or "As Played") to make "midi thru" consistent with sequencer settings
  SendMidiThruOnCh pattern_midich[active_pattern]

  if not ((record and HostRunning) or mode_pad_edit = 1) or transpose or (uiMode = UIMODE_BUTTONS)
    Exit
  endif
  nn = MIDINote
  v = MIDIVelocity
  _note_part = GetNoteState 0, nn

  // Dont store anything unless state was set to <> -1. 
  if _note_part = -1
    Exit
  endif
  // Reset state to prevent OnMidiOff action when notes are played with recording off 
  SetNoteState 0, nn, -1

  _note_step = Div (_note_part - active_pattern * sizeof_pattern), step_reso
  _note_pad = _note_part - ((active_pattern * sizeof_pattern) + _note_step * step_reso)
  if _note_step < 8
    _note_pad = _note_pad + 8
  endif

  _on_ticks = noteOnTicks[_note_part]
  _off_ticks = CurrentTimerTicks // total_tickCounter
  _elapsed_ticks = _off_ticks - _on_ticks

  // Special case:
  // if transport is stopped or we have long steps (like 2 bars) we might get 0 ticks so we default to 1 step for these cases.
  // we might also get negative elapse ticks if timer wrapped around the 16-bit int limit, so we just say 100% elapsed as a safeguard
  if _elapsed_ticks <= 0
    _elapsed_pct = 100
  else
    _elapsed_pct = _elapsed_ticks * timer_tick_resolution / noteTime * 100
  endif

  if noteTimeX_knob < 0
    noteTimeX[_note_part] = _elapsed_pct  // elapsed as percentage of notetime
  else
    noteTimeX[_note_part] = noteTimeX_knob  // Set fixed note time from knob
  endif

  if not mode_pad_edit 
    LabelPad _note_step, (NoteName nn, YES), {:}, Round(noteTimeX[_note_part]) 
  else
    LabelPad _note_pad, {🔴}, (NoteName nn, YES), {:}, Round(noteTimeX[_note_part]) 
  endif
@End

@OnMidiCC
  _cc = MIDIByte2
  _val = MIDIByte3

  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS)  or transpose or midi_rec_mode = MIDI_REC_OFF
    SendMidiThruOnCh pattern_midich[active_pattern]
    Exit
  endif
   
  _supressMidiThru = NO
 
  if mode_pad_edit = 1
    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 
    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part
     if not Unassigned pad_edit_part_pad  // Latch and label when editing parts of step
      LabelPad pad_edit_part_pad, {CC: }, _cc, {:}, _val
    endif
    _supressMidiThru = YES
  else
    _step = step
  endif

  if not _supressMidiThru
    SendMidiThruOnCh pattern_midich[active_pattern]
  endif

  _midi_offset = -1
  _slot_base = active_pattern * midi_slots
  if pattern_CC_slot_map[_slot_base] = _cc
    _midi_offset = 0
  elseif pattern_CC_slot_map[_slot_base + 1] = _cc
    _midi_offset = 1
  elseif pattern_CC_slot_map[_slot_base + 2] = _cc
    _midi_offset = 2
  elseif pattern_CC_slot_map[_slot_base + 3] = _cc
    _midi_offset = 3
  endif

  if _midi_offset = -1
    if pattern_CC_slot_map[_slot_base] = -1
      _midi_offset = 0
    elseif pattern_CC_slot_map[_slot_base + 1] = -1
      _midi_offset = 1
    elseif pattern_CC_slot_map[_slot_base + 2] = -1
      _midi_offset = 2
    elseif pattern_CC_slot_map[_slot_base + 3] = -1
      _midi_offset = 3
    else
      Log {OUT OF SLOTS! Not recording: }, _cc, {:}, _val
      Exit
    endif  
    pattern_CC_slot_map[_slot_base + _midi_offset] = _cc
  endif

  if midi_rec_mode = MIDI_REC_WRITE and midi_write_last_step <> _step
    _step_part = (active_pattern * sizeof_pattern) + _step * step_reso // The note location for the pad being edited.
    if _midi_offset = 0
      FillArray midi1_value[_step_part], -1, step_reso
    elseif _midi_offset = 1
      FillArray midi2_value[_step_part], -1, step_reso
    elseif _midi_offset = 2
      FillArray midi3_value[_step_part], -1, step_reso
    elseif _midi_offset = 3
      FillArray midi4_value[_step_part], -1, step_reso  
    endif
    Log {Clearing step }, _step, { at offset }, _midi_offset
    midi_write_last_step = _step
  endif

  if _midi_offset = 0
    midi1_value[_note_part] = _val
  elseif _midi_offset = 1
    midi2_value[_note_part] = _val
  elseif _midi_offset = 2
    midi3_value[_note_part] = _val
  elseif _midi_offset = 3
    midi4_value[_note_part] = _val
  endif

  LabelPad step, _cc, {: }, _val
  Log {Recorded midi, CC: }, _cc, {:}, _val, { -> offset: }, _midi_offset, {)},{ part:}, _note_part
@End


//  ╔═╗╦ ╦╦╔═╗╔╦╗
//  ╚═╗╠═╣║╠╣  ║ 
//  ╚═╝╩ ╩╩╚   ╩ 

@OnShiftDown
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    Call @SetUIMode_Voices 
  elseif uiMode = UIMODE_VOICES
    Call @SetUIMode_Pads
  elseif uiMode = UIMODE_PADS
    Call @SetUIMode_Buttons
  elseif uiMode = UIMODE_BUTTONS
    Call @SetUIMode_Pads
  elseif uiMode = UIMODE_HELP
    Call @SetUIMode_Buttons
  endif
@End 

@OnShiftUp
@End 


//  ╔═╗╔═╗╔╦╗       ╦ ╦╔═╗╦  ╔╦╗
//  ╠═╝╠═╣ ║║  ───  ╠═╣║ ║║   ║║
//  ╩  ╩ ╩═╩╝       ╩ ╩╚═╝╩═╝═╩╝

@OnPadHold
  if uiMode = UIMODE_PADS
    pad_edit_step = pad
    mode_pad_edit = 1
    pad_edit_part = 0 
    if pad < 8
      pad_edit_part_pad = 8  // used for latching pad in UI. "hold to edit" always edits first part of step
    else
      pad_edit_part_pad = 0
    endif
    pad_edit_got_note = NO
    pad_edit_hold = 1
    LabelPad pad, {Editing...} 
    Call @UpdateGUI
  elseif uiMode = UIMODE_BUTTONS
    if pad = BTN_CLEAR_ALL
      LabelPad BTN_CLEAR_ALL, {✅Cleared}
      Call @ClearSequencer
    elseif pad = BTN_CLEAR_ARMED
      LabelPad BTN_CLEAR_ARMED, {✅Cleared}
      Call @ClearActivePattern
    elseif pad = BTN_MIDI
      LabelPad BTN_MIDI, {✅Cleared}
      Call @ClearActivePatternMidi
    elseif pad >= 8 and pad <= 14
      if mode_multi_pattern
        _pattern = pad - 8
        active_pattern = _pattern
        LatchPad pad, playing_patterns[_pattern]
      endif

    Call @UpdateGUI

    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
   endif
  endif
@End

//  ╔═╗╔═╗╔╦╗       ╔═╗╦╔╗╔╔═╗╦  ╔═╗  ╔╦╗╔═╗╔═╗
//  ╠═╝╠═╣ ║║  ───  ╚═╗║║║║║ ╦║  ║╣    ║ ╠═╣╠═╝
//  ╩  ╩ ╩═╩╝       ╚═╝╩╝╚╝╚═╝╩═╝╚═╝   ╩ ╩ ╩╩  

@OnPadSingleTap // param: pad
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    Call @OnPadSingleTap_InPadEdit

  elseif uiMode = UIMODE_PADS  // pads
    Call @EnterPadEditMode

  elseif uiMode = UIMODE_BUTTONS and mode_copy_pattern = YES
    Call @OnPadSingleTap_InCopyPattern

  elseif uiMode = UIMODE_BUTTONS
    Call @OnPadSingleTap_Buttons

  endif
@End

@OnPadSingleTap_InPadEdit
  if (pad_edit_step > 7 AND pad > 7) OR (pad_edit_step <= 7 AND pad <= 7)  // pad and tapped pad are on the same row  
    mode_pad_edit = 0
    Call @UpdateGUI
  else  
    _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
    if voice1[_note_part] > -1
      LabelPad pad_edit_part_pad, {🔵}, (NoteName voice1[_note_part], YES), {:}, (Round noteTimeX[_note_part])
    else
      LabelPad pad_edit_part_pad, {⚪️}
    endif

    pad_edit_part = pad % step_reso // Only step_reso parts
    pad_edit_part_pad = pad // for UI usage like latching pad etc during edit
    pad_edit_got_note = NO

    _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)

    pad_edit_note_part = _note_part // used for Voices mode

    if voice1[_note_part] > -1
      LabelPad pad_edit_part_pad, {🔴}, (NoteName voice1[_note_part], YES), {:}, noteTimeX[_note_part]
    else
      LabelPad pad_edit_part_pad, {🔴}
    endif
    LabelPads {⚠️ Editing }, pad_edit_step, {:} , pad_edit_part, {  ℹ️ SHIFT for voices }
  endif
@End

@EnterPadEditMode
  mode_pad_edit = 1
  pad_edit_step = pad
  pad_edit_part = 0
  pad_edit_got_note = NO
  if pad < 8
    pad_edit_part_pad = 8 // for UI usage like latching pad etc during edit
  else
    pad_edit_part_pad = 0
  endif

  _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)

  pad_edit_note_part = _note_part // used for Voices mode
  
  Call @UpdateGUI
@End

@OnPadSingleTap_InCopyPattern
  mode_copy_pattern = NO
  if pad < 8
    exit
  endif

  CopyPattern_pattern = pad - 8
  CopyPattern_src_pattern_pos = active_pattern * sizeof_pattern
  CopyPattern_dest_pattern_pos = CopyPattern_pattern * sizeof_pattern

  Call @CopyPattern
  LabelPad CopyPattern_pattern + 8, {P}, active_pattern+1, {CPY, ARM}
  LatchPad active_pattern+8, 0
  LatchPad CopyPattern_pattern + 8, 1
  active_pattern = CopyPattern_pattern  // Auto-arm after copy
@End

@OnPadSingleTap_Buttons  
  if pad = BTN_TRANSPOSE
    transpose = not transpose
    LabelPad BTN_TRANSPOSE, { Transpose: }, transpose
    LabelPads {⚠️Transpose: }, transpose

  elseif pad = BTN_CLEAR_ALL
    LabelPads {⚠️ Hold Clear All pad to clear all patterns ⚠️}
    LabelPad BTN_CLEAR_ALL, {️⚠️hold=clr}

️  elseif pad = BTN_CLEAR_ARMED
    LabelPads {⚠️ Hold Clear Armed pad to clear current pattern ⚠️}
    LabelPad BTN_CLEAR_ALL, {️⚠️hold=clr}

  elseif pad = BTN_RECORD
    record = not record
    Call @UpdateGUI

  elseif pad = BTN_MIDI
    midi_rec_mode = (midi_rec_mode + 1) % 3
    Call @UpdateGUI
    if midi_rec_mode = MIDI_REC_OFF
      LabelPads {CC ⚪ off ⚠️ Hold CC rec to clear CC automation for current pattern ⚠️}
    elseif midi_rec_mode = MIDI_REC_WRITE
      LabelPads {CC 🔴 WRITE  ⚠️ Hold CC rec to clear CC automation for current pattern ⚠️}
    elseif midi_rec_mode = MIDI_REC_OVERDUB
      LabelPads {CC 🅾️OVERDUB ⚠️ Hold CC rec to clear CC automation for current pattern ⚠️}
    endif


  elseif pad = BTN_QUANTIZE
    quantize = (quantize + 1) % 3
    Call @UpdateGUI
    
  elseif pad = BTN_COPY_PATTERN
    LabelPads { Select pattern to copy active pattern to }
    mode_copy_pattern = YES

  elseif pad = BTN_MULTI_PATTERN
      mode_multi_pattern = not mode_multi_pattern
      if mode_multi_pattern
        LabelPads { Select patterns to play simultaneously }
        LabelPad BTN_MULTI_PATTERN, {Multi: ON}
      else
        LabelPads { Single pattern arm mode }
        LabelPad BTN_MULTI_PATTERN, {Multi: OFF}
      endif
      Call @UpdateGUI

  elseif pad = BTN_HELP
    Call @SetUIMode_Help

  elseif pad >= 8 and pad <= 14     // Pattern ARM. Future proof with upper bound ;)
    if mode_multi_pattern
      _pattern = pad - 8
      active_pattern = _pattern
      _current_state = playing_patterns[_pattern]
      _new_state = not _current_state

      playing_patterns[_pattern] = _new_state
      LatchPad pad, playing_patterns[_pattern]
    else
      last_active_pattern = active_pattern
      active_pattern = pad-8
    endif

    Call @UpdateGUI

    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
   endif
@End



//  ╔═╗╔═╗╔╦╗       ╔╦╗╔═╗╦ ╦╔╗ ╦  ╔═╗  ╔╦╗╔═╗╔═╗
//  ╠═╝╠═╣ ║║  ───   ║║║ ║║ ║╠╩╗║  ║╣    ║ ╠═╣╠═╝
//  ╩  ╩ ╩═╩╝       ═╩╝╚═╝╚═╝╚═╝╩═╝╚═╝   ╩ ╩ ╩╩  

@OnPadDoubleTap
  if uiMode = UIMODE_BUTTONS
    Exit
  endif
  if mode_pad_edit = 1 
    del_step_part = pad % 8
    del_step = pad_edit_step
    del_step_pos = del_step * step_reso + del_step_part // The note location in the wide grid

    _del_note_part = (active_pattern * sizeof_pattern) + del_step_pos

    polycount[_del_note_part] = 0
    voice1[_del_note_part] = -1
    voice2[_del_note_part] = -1
    voice3[_del_note_part] = -1
    voice4[_del_note_part] = -1
    voice5[_del_note_part] = -1
    voice6[_del_note_part] = -1
    velocity[_del_note_part] = 100
    noteTimeX[_del_note_part] = 100

    LatchPad pad, 0
    LabelPad pad, { }
  else
    del_step = pad
    del_note_part = del_step * step_reso // The note location in the wide grid

    for po = 0 to step_reso
      _del_note_part = (active_pattern * sizeof_pattern) + (del_note_part + po) 
      polycount[_del_note_part] = 0
      voice1[_del_note_part] = -1
      voice2[_del_note_part] = -1
      voice3[_del_note_part] = -1
      voice4[_del_note_part] = -1
      voice5[_del_note_part] = -1
      voice6[_del_note_part] = -1
      velocity[_del_note_part] = 100
      noteTimeX[_del_note_part] = 100
    endfor
  
    LatchPad del_step, 0
    LabelPad del_step, { }
  endif
@End


//  ╔═╗╔═╗╔═╗╦ ╦  ╔═╗╔═╗╔╦╗╔╦╗╔═╗╦═╗╔╗╔
//  ║  ║ ║╠═╝╚╦╝  ╠═╝╠═╣ ║  ║ ║╣ ╠╦╝║║║
//  ╚═╝╚═╝╩   ╩   ╩  ╩ ╩ ╩  ╩ ╚═╝╩╚═╝╚╝

@CopyPattern
  _pattern = CopyPattern_pattern
  _src_pattern_pos = CopyPattern_src_pattern_pos
  _dest_pattern_pos = CopyPattern_dest_pattern_pos

  CopyArray voice1[_src_pattern_pos], voice1[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2[_src_pattern_pos], voice2[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3[_src_pattern_pos], voice3[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4[_src_pattern_pos], voice4[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5[_src_pattern_pos], voice5[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6[_src_pattern_pos], voice6[_dest_pattern_pos], sizeof_pattern
  CopyArray voice1_velocity[_src_pattern_pos], voice1_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2_velocity[_src_pattern_pos], voice2_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3_velocity[_src_pattern_pos], voice3_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4_velocity[_src_pattern_pos], voice4_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5_velocity[_src_pattern_pos], voice5_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6_velocity[_src_pattern_pos], voice6_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray polycount[_src_pattern_pos], polycount[_dest_pattern_pos], sizeof_pattern
  CopyArray noteTimeX[_src_pattern_pos], noteTimeX[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnTicks[_src_pattern_pos], noteOnTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnDelayTicks[_src_pattern_pos], noteOnDelayTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray note_probability[_src_pattern_pos], note_probability[_dest_pattern_pos], sizeof_pattern
@End

//  ┌─┐┬  ┌─┐┌─┐┬─┐  ┌─┐┌─┐┌┬┐┌┬┐┌─┐┬─┐┌┐┌┌─┐
//  │  │  ├┤ ├─┤├┬┘  ├─┘├─┤ │  │ ├┤ ├┬┘│││└─┐
//  └─┘┴─┘└─┘┴ ┴┴└─  ┴  ┴ ┴ ┴  ┴ └─┘┴└─┘└┘└─┘

@ClearSequencer
  FillArray polycount, 0
  FillArray voice1, -1
  FillArray voice1_velocity, 100
  FillArray voice2, -1
  FillArray voice2_velocity, 100
  FillArray voice3, -1
  FillArray voice3_velocity, 100
  FillArray voice4, -1
  FillArray voice4_velocity, 100
  FillArray voice5, -1
  FillArray voice5_velocity, 100
  FillArray voice6, -1
  FillArray voice6_velocity, 100
  FillArray midicount, 0
  FillArray midi1_value, -1
  FillArray midi2_value, -1
  FillArray midi3_value, -1
  FillArray midi4_value, -1
  FillArray pattern_CC_slot_map, -1
  FillArray noteTimeX, 100
  FillArray noteOnTicks, 0
  FillArray noteOnDelayTicks, 0
  FillArray note_probability, 100
  playing_patterns = [ YES, NO, NO, NO, NO, NO, NO ]
@End

@ClearActivePattern
  _pattern_start = active_pattern * sizeof_pattern
  FillArray polycount[_pattern_start], 0, sizeof_pattern
  FillArray voice1[_pattern_start], -1, sizeof_pattern
  FillArray voice1_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice2[_pattern_start], -1, sizeof_pattern 
  FillArray voice2_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice3[_pattern_start], -1, sizeof_pattern 
  FillArray voice3_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice4[_pattern_start], -1, sizeof_pattern 
  FillArray voice4_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice5[_pattern_start], -1, sizeof_pattern 
  FillArray voice5_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice6[_pattern_start], -1, sizeof_pattern
  FillArray voice6_velocity[_pattern_start], 100, sizeof_pattern
  FillArray noteTimeX[_pattern_start], 100, sizeof_pattern
  FillArray noteOnTicks[_pattern_start], 0, sizeof_pattern
  FillArray noteOnDelayTicks[_pattern_start], 0, sizeof_pattern
  FillArray note_probability[_pattern_start], 100 , sizeof_pattern
  FillArray midicount[_pattern_start], 0, sizeof_pattern
  FillArray midi1_CC[_pattern_start], -1, sizeof_pattern
  FillArray midi1_value[_pattern_start], -1, sizeof_pattern
  FillArray midi2_CC[_pattern_start], -1, sizeof_pattern
  FillArray midi2_value[_pattern_start], -1, sizeof_pattern
  FillArray midi3_CC[_pattern_start], -1, sizeof_pattern
  FillArray midi3_value[_pattern_start], -1, sizeof_pattern
  FillArray midi4_CC[_pattern_start], -1, sizeof_pattern
  FillArray midi4_value[_pattern_start], -1, sizeof_pattern
  FillArray pattern_CC_slot_map[active_pattern * midi_slots], -1, midi_slots
@End

@ClearActivePatternMidi
  _pattern_start = active_pattern * sizeof_pattern
  FillArray midicount[_pattern_start], 0, sizeof_pattern
  FillArray midi1_CC[_pattern_start], -1, sizeof_pattern
  FillArray midi1_value[_pattern_start], -1, sizeof_pattern
  FillArray midi2_CC[_pattern_start], -1, sizeof_pattern
  FillArray midi2_value[_pattern_start], -1, sizeof_pattern
  FillArray midi3_CC[_pattern_start], -1, sizeof_pattern
  FillArray midi3_value[_pattern_start], -1, sizeof_pattern
  FillArray midi4_CC[_pattern_start], -1, sizeof_pattern
  FillArray midi4_value[_pattern_start], -1, sizeof_pattern
  FillArray pattern_CC_slot_map[active_pattern * midi_slots], -1, midi_slots
@End

//  ╦╔═╔╗╔╔═╗╔╗ ╔═╗
//  ╠╩╗║║║║ ║╠╩╗╚═╗
//  ╩ ╩╝╚╝╚═╝╚═╝╚═╝

@OnKnobChange
  if uiMode = UIMODE_PADS or uiMode = UIMODE_BUTTONS
    call @OnKnobChange_Pads
  elseif uiMode = UIMODE_VOICES
    call @OnKnobChange_Voices
  endif
@End

@OnKnobChange_Voices
  _part = pad_edit_note_part
  _knob = LastKnob
  _note = GetKnobValue _knob
  _voice = _knob + 1
 
  if polycount[_part] < _voice and _voice <= 6
    polycount[_part] = _voice
  endif
  
  if _knob = 0
    voice1[_part] = _note
    LabelKnob 0, (NoteName _note, YES)
  elseif _knob = 1
    voice2[_part] = _note
    LabelKnob 1, (NoteName _note, YES)
  elseif _knob = 2
    voice3[_part] = _note
    LabelKnob 2, (NoteName _note, YES)
  elseif _knob = 3
    voice4[_part] = _note
    LabelKnob 3, (NoteName _note, YES)
  elseif _knob = 4
    voice5[_part] = _note
    LabelKnob 4, (NoteName _note, YES)
  elseif _knob = 5
    voice6[_part] = _note
    LabelKnob 5, (NoteName _note, YES)
  elseif _knob = 6  // notetime. knob is mapped linearly from 0-100% for the first 1/4 of the slider, then from 100-1600 for the "upper" 75%.
    _ntx = (GetKnobValue 6)
    if _ntx <= 32
      _ntx = Round(_ntx * 3.125)
    else
      _ntx = Round(((_ntx-32) / 95) * 1500) + 100
    endif
    Log {New note time: }, _ntx
    noteTimeX[_part] = _ntx
    LabelKnob 6, _ntx
  elseif _knob = 7  // probability
    _p = Round((GetKnobValue 7) / 127 * 100)
    note_probability[_part] = _p
    LabelKnob 7, _p
  endif
@End

@OnKnobChange_Pads
  if LastKnob = KNOB_STEP
    currentDivisor = Round ((GetKnobValue 0) / 16)
    if currentDivisor = 0
      LabelKnobs {1/32}
    elseif currentDivisor = 1
      LabelKnobs {1/16}
    elseif currentDivisor = 2
      LabelKnobs {1/8t}
    elseif currentDivisor = 3
      LabelKnobs {1/8}
    elseif currentDivisor = 4
      LabelKnobs {1/4}
    elseif currentDivisor = 5
      LabelKnobs {1/2}
    elseif currentDivisor = 6
      LabelKnobs {bar}
    elseif currentDivisor = 7
      LabelKnobs {2 bar}
    endif
    call @ComputeTimes

  elseif LastKnob = KNOB_NOTETIME
    noteTimeX_knob = Round((GetKnobValue 1) / 127 * 800)  
    if noteTimeX_knob < 6.25
      noteTimeX_knob = -1 // "As Played"
      LabelKnobs {As Played}
    else
      LabelKnobs noteTimeX_knob*1.000, {%}
    endif
    if mode_pad_edit = 1 and noteTimeX_knob > 0  // REFACTOR: use pad_edit_note_part below (and in other similar places)
      noteTimeX[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = noteTimeX_knob
    endif

  elseif LastKnob = KNOB_PROBABILITY
    _probability = (GetKnobValue 2) / 127 * 100
    if mode_pad_edit = 1
      note_probability[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _probability
    else
      note_probability[(active_pattern * sizeof_pattern) + note_part] = _probability
    endif
    probability_knob = _probability
    LabelKnobs (Round probability_knob), {%}

  elseif LastKnob = KNOB_MIDICH
    _midich = RoundDown((GetKnobValue KNOB_MIDICH) / 128 * 16)
    pattern_midich[active_pattern] = _midich
    LabelKnobs _midich + 1
  endif
@End

//   ██████╗ ██╗   ██╗██╗
//  ██╔════╝ ██║   ██║██║
//  ██║  ███╗██║   ██║██║
//  ██║   ██║██║   ██║██║
//  ╚██████╔╝╚██████╔╝██║
//   ╚═════╝  ╚═════╝ ╚═╝

@SetUIMode_Pads
  ShowLayout 2
  uiMode = UIMODE_PADS
  Call @UpdateGUI
  LabelKnobs {P}, active_pattern+1, { settings }
@End

@SetUIMode_Voices
  ShowLayout 3
  uiMode = UIMODE_VOICES
  Call @UpdateGUI
@End

@SetUIMode_Help
  ShowLayout 4
  uiMode = UIMODE_HELP
  Call @UpdateGUI
@End

@SetUIMode_Buttons
  ShowLayout 2
  uiMode = UIMODE_BUTTONS
  mode_copy_pattern = NO
  Call @UpdateGUI
@End

@UpdateGUI
  if uiMode = UIMODE_PADS AND mode_pad_edit = 1
    call @GUI_PadEditMode

  elseif uiMode = UIMODE_PADS
    call @GUI_PadMode

  elseif uiMode = UIMODE_BUTTONS
    call @GUI_ButtonMode 
    call @GUI_LabelKnobs
 
  elseif uiMode = UIMODE_VOICES
     call @GUI_VoicesMode
  
  elseif uiMode = UIMODE_HELP
    call @GUI_HelpMode
  endif
@End

@GUI_HelpMode
  // Void for now
@End

@GUI_VoicesMode
  _edit_note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso) + pad_edit_part

  _n = voice1[_edit_note_part]
  _n1 = _n
  LabelKnob 0, (NoteName _n, YES)
  SetKnobValue 0, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice2[_edit_note_part]
  LabelKnob 1, (NoteName _n, YES)
  SetKnobValue 1, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice3[_edit_note_part]
  LabelKnob 2, (NoteName _n, YES)
  SetKnobValue 2, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice4[_edit_note_part]
  LabelKnob 3, (NoteName _n, YES)
  SetKnobValue 3, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice5[_edit_note_part]
  LabelKnob 4, (NoteName _n, YES)
  SetKnobValue 4, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice6[_edit_note_part]
  LabelKnob 5, (NoteName _n, YES)
  SetKnobValue 5, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  LabelKnob 6, {Note time}
  _ntx = noteTimeX[_edit_note_part]
  if _ntx <= 100
    _ntx = Round _ntx / 3.125
  else
    _ntx = Round ((((_ntx - 100) / 1500) * 95) + 32)
  endif
  SetKnobValue 6, _ntx

  LabelKnob 7, {Probability}
  SetKnobValue 7, (TranslateScale note_probability[_edit_note_part], 0, 100, 0, 127)
  LabelKnobs {⚠️ Voices for }, pad_edit_step, {:} , pad_edit_part, {  ⬆️ SHIFT to go back }
@End

@GUI_PadMode
  Call @GUI_LabelKnobs
  for _step = 0 to 15
    _voice_cnt = 0
    _part_cnt = 0
    _po = (active_pattern * sizeof_pattern) + (_step * step_reso)

    _pc = polycount[_po+0] + polycount[_po+1] + polycount[_po+2] + polycount[_po+3] + polycount[_po+4] + polycount[_po+5] + polycount[_po+6] + polycount[_po+7]

    if _pc > 0
      LatchPad _step, 1
      // Row below triggers parser bug in Mozaic if there are spaces after commas
      LabelPad _step,polycount[_po+0],polycount[_po+1],polycount[_po+2],polycount[_po+3],polycount[_po+4],polycount[_po+5],polycount[_po+6],polycount[_po+7]
    else
      LatchPad _step, 0
      LabelPad _step, { }
    endif
  endfor
  
 if transpose and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ ⚪️ }, { transpose: }, transpose, { Play: Multi}, { quant: }, quantize
  elseif transpose
    LabelPads  {P}, active_pattern+1,{ ⚪️ SOLO}, { transpose: }, transpose, { quant: }, quantize
  elseif record and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ 🔴 }, { Play: Multi}, { quant: }, quantize
  elseif record
    LabelPads  {P}, active_pattern+1,{ 🔴 SOLO}, { quant: }, quantize
  endif
  
@End

@GUI_PadEditMode
  if pad_edit_step <= 7
    _pad_offset = 8
  else
    _pad_offset = 0
  endif

  for the_part = 0 to step_reso-1
    _note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso + the_part)
    _cnt = polycount[_note_part]
    _pad = the_part + _pad_offset
    if _cnt > 0
      LabelPad _pad, {🔵}, _cnt, {:}, (NoteName voice1[_note_part], YES), {:}, (Round noteTimeX[_note_part])
      LatchPad _pad, 1
    else
      LatchPad _pad, 0
      LabelPad _pad, {⚪️}
    endif
  endfor

  _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
  if voice1[_note_part] > -1
    LabelPad pad_edit_part_pad, {🔴}, (NoteName voice1[_note_part], YES), {:}, polycount[_note_part]
  else
    LabelPad pad_edit_part_pad, {🔴}
  endif
  LabelPad pad_edit_step, {✅ Done}
  LabelPads {⚠️ Editing }, pad_edit_step, {:} , pad_edit_part, {  ⬆️ SHIFT for voices }

  Call @GUI_LabelKnobs
@End

@GUI_ButtonMode
  for po = 0 to 15
    LabelPad po, { }
    LatchPad po, 0
  endfor
  
  if transpose
    LabelPad BTN_TRANSPOSE, {⚠️Transp ON}
  else
    LabelPad BTN_TRANSPOSE, {Transp OFF}
  endif

  LabelPad BTN_CLEAR_ALL, {Clear all}

  if record
    LabelPad BTN_RECORD, {Live rec 🔴}
  else
    LabelPad BTN_RECORD, {Live rec ⚪}
  endif
  
  if midi_rec_mode = MIDI_REC_OFF
    LabelPad BTN_MIDI, {CC rec ⚪}
  elseif midi_rec_mode = MIDI_REC_WRITE
    LabelPad BTN_MIDI, {CC rec 🔴}
  elseif midi_rec_mode = MIDI_REC_OVERDUB
    LabelPad BTN_MIDI, {CC rec 🅾️}
  endif

  LabelPad BTN_COPY_PATTERN, {Copy pattern}
  LabelPad BTN_CLEAR_ARMED, {Clear armed}
  LabelPad BTN_HELP, {ℹ️Help}

  if quantize = QUANT_NONE
    LabelPad BTN_QUANTIZE, {Quant: None} 
  elseif quantize = QUANT_PART
    LabelPad BTN_QUANTIZE, {Quant: Part} 
  else // QUANT_STEP
    LabelPad BTN_QUANTIZE, {Quant: Step} 
  endif

  if mode_multi_pattern  
    LabelPad BTN_MULTI_PATTERN, {Play: Multi}
    for _pattern = 0 to 6
      if playing_patterns[_pattern] = 1 // and active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { 🔵}
      else
        LabelPad _pattern + 8, {P}, _pattern+1, { ⚪}
      endif
    endfor
  else
    LabelPad BTN_MULTI_PATTERN, {Play: Solo}
    for _pattern = 0 to 6
      if active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { SOLO}
      else
        LabelPad _pattern + 8, {P}, _pattern+1
      endif
    endfor
  endif

  LatchPad 8+active_pattern, 1
  if mode_multi_pattern
    LabelPads {Tap patterns to arm and toggle ON/OFF. Long-press for arm only. ⬆️ SHIFT exits.}
  else
    LabelPads {Tap pattern to solo & arm. ⬆️ SHIFT exits.}
  endif
@End

@GUI_LabelKnobs
  LabelKnobs {P}, active_pattern+1, { settings}
  LabelKnob KNOB_STEP, {Step}
  LabelKnob KNOB_NOTETIME, {Note time}
  LabelKnob KNOB_PROBABILITY, {Probability}
  LabelKnob KNOB_MIDICH, {Midi CH}
  SetKnobValue KNOB_MIDICH, pattern_midich[active_pattern]*8+4 
@End

//  ╔═╗╔═╗╔╦╗  ╔╦╗╔═╗╔╗╔╔═╗╔═╗╔═╗╦═╗
//  ╠═╝╠═╣ ║║  ║║║╠═╣║║║╠═╣║ ╦║╣ ╠╦╝
//  ╩  ╩ ╩═╩╝  ╩ ╩╩ ╩╝╚╝╩ ╩╚═╝╚═╝╩╚═

@PadManagerOnLoad
  
  // The following vars CAN be set before @InitPadManager. 
  // If they are not defined here, they will be automatically 
  // defined with their defaults in @InitPadManager
  //
  // In the most basic use-case, just Call @InitPadManager 
  // in your OnLoad without setting any of them. 
  
  pmAnalyseTime = 200 
  // Length of double tap / tap-and-hold time window in msec
    
  pmManageTimer = YES
  // Set to NO if your script wants to controll the timer.
  // Your timer needs to run continously and with an update
  // interval faster than 50, otherwise the pad manager 
  // wont work. Also set pmTickInterval accordingly.

  pmTickInterval = timer_tick_resolution    // Update interval for the timer in msec.

  //  pmExcludePads = [7,15]
  pmExcludeCnt = 0

  // List of pad ids and length of list to be excluded from
  // analysis. For these pads OnSingleTap will be called 
  // immediately in 'OnPadDown' without the analysis delay.

  Call @InitPadManager
@End



// ========= Pad Manager V2 =========
// -ki  01.06.2019

@InitPadManager  

  // Apply defaults, if the vars are not yet defined

  if Unassigned pmAnalyseTime
    pmAnalyseTime = 200 
  endif
  if Unassigned pmManageTimer
    pmManageTimer = YES
  endif
  if Unassigned pmTickInterval
    pmTickInterval = 25
  endif
  if Unassigned pmExcludePads
    pmExcludePads = []
  endif
  if Unassigned pmExcludeCnt
    pmExcludeCnt = 0
  endif
  
  padsActiveCnt = 0  
  padMaxId = 15
  for pad = 0 to padMaxId
    Call @InitPadState
  endfor

  if pmExcludeCnt>0
    for pad = 0 to pmExcludeCnt-1
      padExclude[ pmExcludePads[pad] ] = YES
    endfor
  endif

  padAnalyseTicks = pmAnalyseTime / pmTickInterval

  if pmManageTimer
    SetTimerInterval pmTickInterval
  endif
  
  Log {PadManager started (},pmExcludeCnt,{ excluded pads, timer=}, pmTickInterval,{msec)}
@End

@InitPadState // Param: pad
  padActive[pad] = NO
  padTicks[pad] = 0
  padTaps[pad] = 0
  padHold[pad] = NO
  padExclude[pad] = NO
@End

@ReleasePadState // Param: pad
  Dec padsActiveCnt
  if pmManageTimer and padsActiveCnt = 0
//    StopTimer 
  endif
  Call @InitPadState
 @End

@OnPadDown 
  if padExclude[LastPad]
    pad = LastPad
    Call @OnPadSingleTap
  else
    if pmManageTimer and padsActiveCnt = 0
//      StartTimer 
    endif
    if not padActive[LastPad]
      Inc padsActiveCnt
      padActive[LastPad] = YES
    endif
    inc padTaps[LastPad]
  endif
@End 

@OnPadUp 
  if padTaps[LastPad] = 1 and padTicks[LastPad] < padAnalyseTicks
    padHold[LastPad] = YES
  endif

  if pad_edit_hold and LastPad = pad_edit_step
    pad_edit_got_note = NO
    pad_edit_hold = 0
    mode_pad_edit = 0
    Call @UpdateGUI
  endif
@End 

@OnTimer 
  CurrentTimerTicks = (CurrentTimerTicks + 1) % 65534  // Wraps around every ~10 minutes
  for pad = 0 to padMaxId
    if padActive[pad]
      Inc padTicks[pad]
      if padTicks[pad] > padAnalyseTicks
        if padTaps[pad] = 1
          if padHold[pad]
            Call @OnPadSingleTap
          else
            Call @OnPadHold
          endif
        else
            Call @OnPadDoubleTap
        endif

        Call @ReleasePadState
      endif
    endif
  endfor
@End 

// <<<<<<<<< end of Pad Manager script code >>>>>

@Description
  FLOW - 7-pattern, multi-channel, 16x8 step midi looper & sequencer for Mozaic by peblin.
  Featuring:

  - 16 steps with 8 subdivisions (parts) each
  - 6 voice polyphony per part
  - 7 patterns, with midi channel configurable per pattern
  - From 1/32 to 2 bar step length giving 1/2 to 16 bar patterns
  - Live & step recording
  - Midi CC recording & automation
  - Live recording stores note duration and timing for (almost) exact playback
  - Individual step / part editing, including voices, probability and duration
  - Note probability & duration can be set per part
  - Transpose mode
  - Patterns play solo or multi - easily toggle patterns ON/OFF for live performance
  - 3 quantization modes for live recording - None (as played), per part, per step

-- Basics --

FLOW's sequencer consists of 16 steps per pattern. Each step is divided into 8 parts - so each part is 1/8 of step length. For example, setting step length using the Step knob to 1 bar, makes each part of the step a 1/8th note.

To get started, just start the host and start playing - the sequencer records whatever you play into the appropriate part and plays is back just as you played it. Double-tap to erase steps & parts, and single-tap on a step to edit its parts.

The sequencer has 4 views;
- Steps; each pad is a step. When a step has parts with notes, the pad will show the number of voices allocated per part in the step. T
- Step edit; shows one row of steps and the other row the parts of the step being edited. Accessed by tapping or holding a pad in Steps view.
- Part edit; shows faders for all voices, note time and probability of a part. Accessed by tapping ⬆️SHIFT when in step edit view.
- Control panel; top row of pads are sequencer controls, bottom row are ARM/ON/OFF toggles for the 7 patterns. Accessed by tapping SHIFT in the Steps view. Exit by tapping SHIFT again.

-- Recording --

Record into the sequencer using either live recording or step recording.

--- Live recording & Quantization ---

In this mode the sequencer records notes, velocities and (optionally) duration into the corresponding part. Live recording has three quantization modes - None, Part and Step. Set the quantisation mode by tapping the Quant button in Control Panel - it cycles between the modes.

- None; This aims to reproduce what you played as close to the original as possible. It keeps the timing of your playing by keeping track of the delay of the "note on" message to when the part started and will delay any playback with the same amount. The accuracy of the delay is 5 milliseconds for now.
- Part; This will quantize to nearest part (pushing note forward to next part if that is closer in time)
- Step; This will quantize to nearest step (pushing note forward to next step if its within 25% of the next step in time)

The sequencer has 6 voice polyphony per part, but only stores timing latency "per step", not "per voice" so any additional voices will play in sync with the first voice of the part.

--- Step recording ---

In this mode you select which step/part to edit, then play up to 6 notes for it. When editing a step, you're actually editing the first part of the step. 

The sequencer supports both "latched" and "hold pad" editing. 
- Latched; Simply tap the step you want to edit, then tap the part from all parts showing on the row above or below the chosen step. Finish recording/editing by tapping the step again, which is now labeled "✅ Done".
- Hold pad; Hold the step you want to edit, then tap the part from all parts showing on the row above or below the chosen step. Finish by releasing the held pad. 

Latched is really helpful on iPhone, while "hold pad" might be quicker on the iPad.

-- Deleting parts or full steps --

To delete a part or all parts in a step, double-tap the step or part pad. 

-- Editing part contents --

When in step edit mode, if you select a part and then press SHIFT you will enter "part edit" mode. Part edit mode shows all 6 voices, note duration and probability.

Drag faders to adjust notes. If you drag a previously unused voice it'll be added to the part - so you can for example add a seventh to a triad chord after recording. Or, tap a bass rythm and then afterwards dial in the desired notes.

It's not super-easy to hit the right note when dragging the fader - suggestions for improved UX welcome.

-- Part durations --

The knob "note time" sets the default note duration both for live and step recording. Note duration is measured as "percentage of step length". Thus, a note duration of 200% with the sequencer set to "1/8" will give 1/4th notes. This also means that if you change step length for the sequencer, the note durations will scale accordingly.

Note duration knob defaults to "As played", meaning that the sequencer will use your playing (converted to a percentage of step length) as duration.

When in part edit mode, you can set part duration from 5% to 1600% of one step. At 1600%, the note will be held for the whole loop when it will trigger again.

-- Part probabilities --

The probability knob sets the default probability for step-sequenced parts. You can also change the part probability using either the probability knob when step recording, or the probability fader in part edit view.

-- Pattern Midi Channel --

Each pattern can have its own midi channel for sending notes. Set the channel using the Midi CH knob and enjoy.

-- Play modes --

The sequencer can play each pattern SOLOed, or multiple patterns simultaneously. Toggle play mode with the "Play" button in the Control Panel.

--- Play: Solo ---

Only one pattern plays at a time and the playing pattern is also armed for recording. Change to the desired pattern in the Control Panel.

--- Play: Multi ---

Multiple patterns can play simultaneously, either on the same midi channel or using several depending on the midi channel setting for each pattern.

Toggle patterns ON/OFF in the Control Panel. Single-tapping on a pattern will toggle it ON/OFF and make it the armed pattern. Long-pressing on a pattern (tap and hold for approx 200ms+) will arm it, but not toggle the ON/OFF state. This way you can switch between editing different playing patterns without interrupting playback.

-- CC recording --

Flow can record incoming Midi CC commands per pattern. Even "empty" patterns (ie patterns with no notes) can record CCs so it's possible to record "CC phrases" such as different filter sweeps and then trigger them by toggling the recorded patterns on and off.

Tap the "CC rec" button in the Control Panel to toggle between OFF, 🔴 WRITE and 🅾️ OVERDUB.

In WRITE mode, incoming CC values will result in the current step being cleared (only once per loop), then stored in the corresponding sequencer part. For smooth knob movements this means that incoming values will "overwrite" previously stored ones (for that CC command), if values are coming a rate of at least once every step.

In OVERDUB mode, incoming CC values are stored "as is" per part in the sequencer. This can be used creatively to yield glitchy effects when filters jump around wildly - but will give wild results. 🔥

Flow has 4 "CC slots" and can store values for up to 4 different CCs per pattern. Slots are allocated on a first come basis - so if the sequencer receives sustain, mod wheel, cutoff and resonance CCs the slots for the active pattern are full and additional CC commands will be passed thru but not stored.

Playback of recorded CCs is (at least for now) quantized to the last recorded CC value of each part. This means that for patterns having up to 1/4th notes as step length CCs will be perceived as "smooth", but longer step lengths will give a stepped impression.

-- Transpose mode --

With transpose active, the sequencer will stop live recording and treat incoming midi notes as "pitch offset", with C3/midi note 48 as base pitch. So, playing G3 will transpose +7 semitones, while a B2 will transpose -1.

Transpose is applied to all outgoing notes - so in Play:Multi all playing patterns will be transposed. This behaviour might change in the future - suggestions welcome.

-- Copying patterns --

To copy a pattern, first make sure it's the armed pattern then press "Copy Pattern" in Control Panel. Then select the pattern to copy to. Everything except midi channel will be copied.

-- Clearing patterns --

"Clear armed" will clear the currently armed pattern, except for midi channel.
"Clear all" will clear all patterns. To prevent accidental disaster, both clear buttons requires you to long-press on the button.

- THANKS -

  Inspired by OP-Z and https://patchstorage.com/infinity
  Thanks to -ki for https://patchstorage.com/pad-manager-include and great contributions to the community

  And most of all thanks to Bram Bos for creating one of the most game-changing iOS music apps ever.

@End
