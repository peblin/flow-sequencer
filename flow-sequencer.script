@Onload
  SetShortName {Flow} 
  ShowLayout 2
  CurrentTimerTicks = 0
  last_pulse_ticks = 0
  timer_tick_resolution = 5 // Milliseconds per tick

  Call @PadManagerOnLoad

  step_reso = 8  // Grid/parts per step
  part_reso = 1 // REMOVE? Pulses per part
  poly = 6       // Max polyphony per part
  sizeof_pattern = 16*8      // Size of storing all step parts in an array

  // -- CONSTANTS -- 

  UIMODE_PADS = 1
  UIMODE_BUTTONS = 2
  UIMODE_VOICES = 3
  UIMODE_HELP = 4

  // Buttons
  BTN_MULTI_PATTERN = 0
  BTN_RECORD = 1
  BTN_MIDI = 2
  BTN_QUANTIZE = 3
  BTN_TRANSPOSE = 4
  BTN_COPY_PATTERN = 5
  BTN_CLEAR_ALL = 6
  BTN_CLEAR_ARMED = 7
  BTN_HELP = 15

  // Knobs for pads
  KNOB_GATE = 0
  KNOB_VELOCITY = 1
  KNOB_PROBABILITY = 2
  KNOB_STRUM = 3
 
  // Knobs for pattern
  KNOB_STEP = 0
  KNOB_MIDICH = 1
  
  // Knobs for voices
  VKNOB_VOICE1 = 0
  VKNOB_VOICE2 = 1
  VKNOB_VOICE3 = 2
  VKNOB_VOICE4 = 3
  VKNOB_VOICE5 = 4
  VKNOB_VOICE6 = 5
  VKNOB_GATE = 11
  VKNOB_VELOCITY = 12
  VKNOB_PROBABILITY = 13
  VKNOB_STRUM = 14
  VKNOB_RATCHET = 15
  VKNOB_SLOT1CC = 18
  VKNOB_SLOT2CC = 19
  VKNOB_SLOT3CC = 20
  VKNOB_SLOT4CC = 21
  VKNOB_SLOT1VAL = 7
  VKNOB_SLOT2VAL = 8
  VKNOB_SLOT3VAL = 9
  VKNOB_SLOT4VAL = 10

  poly_offset = 0
  note_pos = 0
  note_part = 0
  seq_step = 0 // this is internal to IncrementSequencer, use step below as its updated in "sync" with note_part and step_part
  step = 0
  pad_edit_step = 0
  loops = 0 // number of sequencer loops run since host start
  
  // tracks total ticks since start of transport. might wrap, but that wont kill anyone....i think
  total_tickCounter = 0  

// tracks if a note was received while holding a pad - in which case we can exit pad edit mode on pad release
  pad_edit_got_note = YES
  pad_edit_hold = 0  
  pad_edit_part_pad = 0
  pad_edit_note_part = 0 

  // states for UI
  
  resetStepOnNewStep = 0
  mode_pad_edit = 0
  mode_copy_pattern = NO
  clear_confirm = NO
  if Unassigned record
    record = 1 // Rec enabled by default
    transpose = NO
    transposeNote = 0
    mode_multi_pattern = NO
    midi_rec_mode = 0
  endif

  _res = step_reso * part_reso

  // PPQN and number of steps between parts for CC automation interpolation.
  // Array represents [1/32, 1/16, 1/8T, 1/8, 1/4, 1/2, 1 bar, 2 bars]
  PPQN = [8*_res, 4*_res, 3*_res, 2*_res, _res, _res/2, _res/4, _res/8]
  CC_interpolation_steps = [0, 0, 0, 0, 2, 4, 8, 16]

  // quantization
  QUANT_NONE = 0
  QUANT_PART = 1
  QUANT_STEP = 2
  quantize = QUANT_NONE

  // midi recording
  if Unassigned midi_rec_mode
    midi_rec_mode = 0
  endif
  MIDI_REC_OFF = 0
  MIDI_REC_WRITE = 1
  MIDI_REC_OVERDUB = 2
  
  midi_write_last_step = -1
  midi_write_last_loop = -1
  midi_slots = 4
  
  if Unassigned currentDivisor
    currentDivisor = 3
    count = 1
    tickCounter = 0
    gateX_knob = -1
    probability_knob = 100
  endif

  SetKnobValue KNOB_STEP, 48          // 1/8
  SetKnobValue KNOB_GATE, 0       // As played
  SetKnobValue KNOB_PROBABILITY, 127  // 100%
  SetKnobValue KNOB_MIDICH, 1         // Default Midi Channel 1

  call @ComputeTimes
  Call @InitSequencer

  if Unassigned last_active_pattern
    last_active_pattern = 1
  endif
  active_pattern = 0
  StartTimer 
  call @SetUIMode_Pads
@End

//  â•¦â•”â•—â•”â•¦â•”â•¦â•—   â”¬   â•”â•¦â•—â•¦â•”â•¦â•—â•”â•â•—
//  â•‘â•‘â•‘â•‘â•‘ â•‘   â”Œâ”¼â”€   â•‘ â•‘â•‘â•‘â•‘â•‘â•£ 
//  â•©â•â•šâ•â•© â•©   â””â”˜    â•© â•©â•© â•©â•šâ•â•  

@IncrementSequencer
  Inc tickCounter
  Inc total_tickCounter

  if tickCounter >= countPerStep
    tickCounter = 0
    if resetStepOnNewStep = 1
      resetStepOnNewStep = 0
      seq_step = reset_step
    else
      Inc seq_step
      if seq_step > 15
        seq_step = 0
        Inc loops
      endif
    endif
  endif
@End 

@ComputeTimes
  tickTime = QuarterNote / PPQN[currentDivisor] * part_reso 
  stepTime = tickTime * step_reso
  gate = stepTime
  countPerStep = step_reso * part_reso 
  SetMetroPPQN PPQN[currentDivisor]
@End

@OnHostStart
  seq_step = 0
  step = 0
  note_pos = 0
  note_part = 0  
  tickCounter = 0
  total_tickCounter = 0
  CurrentTimerTicks = 0  // "Optimistically" reset timer tick count on host start to reduce prob that it wraps during recording
  loops = 0
@End 

@InitSequencer
  if Unassigned polycount
    Call @ClearSequencer
    pattern_midich = [0,0,0,0,0,0,0]
  endif
@End

//  â•”â•¦â•—â•”â•â•—â•”â•¦â•—â•¦â•â•—â•”â•â•—   â”¬   â•”â•¦â•—â•¦â•”â•¦â•—â•¦
//  â•‘â•‘â•‘â•‘â•£  â•‘ â• â•¦â•â•‘ â•‘  â”Œâ”¼â”€  â•‘â•‘â•‘â•‘ â•‘â•‘â•‘
//  â•© â•©â•šâ•â• â•© â•©â•šâ•â•šâ•â•  â””â”˜   â•© â•©â•©â•â•©â•â•©

@OnMetroPulse_Interpolate 
//  Log {Interpolating for next val }, Interpolate_nextval, {(},Interpolate_diff,{) at }, _note_part + i, {, }, i, { parts away -> },Interpolate_dist,{ ms away. }

  _delay = Interpolate_dist / Interpolate_steps
  _increment = Interpolate_diff / Interpolate_steps
  
  for j = 1 to (Interpolate_steps - 1)
    _ival = _val + _increment * j
    SendMIDICC _ch, _cc, (Round _ival), (Round _delay * j)
    Log {Scheduled }, _cc, {:}, (Round _ival), { at }, (Round _delay*j)
  endfor             
@End

@OnMetroPulse_CC_automation
      // CC AUTOMATION
      _slot_base = _pattern * midi_slots
      if midi1_value[_note_part] >= 0 
        _cc = pattern_CC_slot_map[_slot_base]
        _val = midi1_value[_note_part]
        SendMIDICC _ch, _cc, _val, 1
        Log step, {:}, step_part, { CC },  _cc, {:}, _val

        Interpolate_steps = CC_interpolation_steps[currentDivisor]
        if Interpolate_steps > 0
          Interpolate_nextval = -1
          for i = 1 to step_reso
            if midi1_value[_note_part + i] >= 0 and Interpolate_nextval = -1
              Interpolate_nextval = midi1_value[_note_part + i]
              Interpolate_diff = midi1_value[_note_part+i] - midi1_value[_note_part]
              Interpolate_dist = i * tickTime
              Call @OnMetroPulse_Interpolate
            endif
          endfor
        endif
      endif
      
      if midi2_value[_note_part] >= 0
        _cc = pattern_CC_slot_map[_slot_base + 1]
        _val = midi2_value[_note_part]
        SendMIDICC _ch, _cc, midi2_value[_note_part], 2
        Log step, {:}, step_part, { CC },  _cc, {:}, midi2_value[_note_part]
        Interpolate_steps = CC_interpolation_steps[currentDivisor]
        if Interpolate_steps > 0
          Interpolate_nextval = -1
          for i = 1 to step_reso
            if midi2_value[_note_part + i] >= 0 and Interpolate_nextval = -1
              Interpolate_nextval = midi2_value[_note_part + i]
              Interpolate_diff = midi2_value[_note_part+i] - midi2_value[_note_part]
              Interpolate_dist = i * tickTime
              Call @OnMetroPulse_Interpolate
            endif
          endfor
        endif
      endif
      
      if midi3_value[_note_part] >= 0
        _cc = pattern_CC_slot_map[_slot_base + 2]
        _val = midi3_value[_note_part]
        SendMIDICC _ch, _cc, midi3_value[_note_part], 3 
        Log step, {:}, step_part, { CC },  _cc, {:}, midi3_value[_note_part]
        Interpolate_steps = CC_interpolation_steps[currentDivisor]
        if Interpolate_steps > 0
          Interpolate_nextval = -1
          for i = 1 to step_reso
            if midi3_value[_note_part + i] >= 0 and Interpolate_nextval = -1
              Interpolate_nextval = midi3_value[_note_part + i]
              Interpolate_diff = midi3_value[_note_part+i] - midi3_value[_note_part]
              Interpolate_dist = i * tickTime
              Call @OnMetroPulse_Interpolate
            endif
          endfor
        endif
      endif
      
      if midi4_value[_note_part] >= 0
        _cc = pattern_CC_slot_map[_slot_base + 3]
        _val = midi4_value[_note_part]      
        SendMIDICC _ch, _cc, midi4_value[_note_part], 4
        Log step, {:}, step_part, { CC },  _cc, {:}, midi4_value[_note_part]
        Interpolate_steps = CC_interpolation_steps[currentDivisor]
        if Interpolate_steps > 0
          Interpolate_nextval = -1
          for i = 1 to step_reso
            if midi4_value[_note_part + i] >= 0 and Interpolate_nextval = -1
              Interpolate_nextval = midi4_value[_note_part + i]
              Interpolate_diff = midi4_value[_note_part+i] - midi4_value[_note_part]
              Interpolate_dist = i * tickTime
              Call @OnMetroPulse_Interpolate
            endif
          endfor
        endif
      endif
@End

@OnMetroPulse_notes
        _transposeNote = 0
        if transpose 
          _transposeNote = transposeNote
        endif

        _polycount = polycount[_note_part]
        _noteDelay = noteOnDelayTicks[_note_part] * timer_tick_resolution
        _gate = gate * (gateX[_note_part] / 100) + _noteDelay
        _vcurve = note_velocityX[_note_part]
        if _vcurve = -1 
          _vcurve = pattern_velocurve[active_pattern]
        endif

        _strum = note_strum[_note_part]
        if _strum = -1
          _strum = pattern_strum[active_pattern]
        endif
        Log {Strum: }, _strum

        if _polycount > 5
          _v = Clip voice6_velocity[_note_part] * _vcurve, 0, 127 
          _s = 5*_strum
          SendMIDINoteOn _ch, voice6[_note_part] + _transposeNote, _v, _noteDelay + _s
          SendMIDINoteOff _ch, voice6[_note_part] + _transposeNote, 0, _gate + _s
        endif
        if _polycount > 4
          _v = Clip voice5_velocity[_note_part] * _vcurve, 0, 127 
          _s = 4*_strum
          SendMIDINoteOn _ch, voice5[_note_part] + _transposeNote, _v, 
          _noteDelay + _s
          SendMIDINoteOff _ch, voice5[_note_part] + _transposeNote, 0, _gate + _s
        endif
        if _polycount > 3
          _v = Clip voice4_velocity[_note_part] * _vcurve, 0, 127 
          _s = 3*_strum
          SendMIDINoteOn _ch, voice4[_note_part] + _transposeNote, _v, _noteDelay + _s
          SendMIDINoteOff _ch, voice4[_note_part] + _transposeNote, 0, _gate + _s
        endif
        if _polycount > 2
          _v = Clip voice3_velocity[_note_part] * _vcurve, 0, 127 
          _s = 2*_strum
          SendMIDINoteOn _ch, voice3[_note_part] + _transposeNote, _v, _noteDelay + _s
          SendMIDINoteOff _ch, voice3[_note_part] + _transposeNote, 0, _gate + _s
        endif
        if _polycount > 1
          _v = Clip voice2_velocity[_note_part] * _vcurve, 0, 127 
          _s = 1*_strum
          SendMIDINoteOn _ch, voice2[_note_part] + _transposeNote, _v, _noteDelay + _s
          SendMIDINoteOff _ch, voice2[_note_part] + _transposeNote, 0, _gate + _s
        endif
        if _polycount > 0
          _v = Clip voice1_velocity[_note_part] * _vcurve, 0, 127 
          _rpts = note_repeat[_note_part]
          _rpttime = _gate / _rpts
          _rptdelay = _noteDelay
          for _i = 1 to _rpts
            Log _i, {:}, _rpttime, {,}, _rptdelay
            SendMIDINoteOn _ch, voice1[_note_part] + _transposeNote, _v, _rptdelay      
            SendMIDINoteOff _ch, voice1[_note_part] + _transposeNote, 0, _rpttime
            _rptdelay = _rptdelay + _rpttime          
          endfor
        endif
@End

@OnMetroPulse   
  last_pulse_ticks = CurrentTimerTicks
  step = seq_step
  step_part = Round(((tickCounter+1) / countPerStep) * step_reso) - 1
  if step_part >= step_reso
    step_part = 0
    step = (step + 1) % 16
  endif
  note_part = (step * step_reso + step_part) // The note location in the wide grid

  for _pattern = 0 to 6 
    if (mode_multi_pattern = 0 and active_pattern=_pattern) or (mode_multi_pattern = 1 and playing_patterns[_pattern] = YES)
      _note_part = (_pattern * sizeof_pattern) + note_part
      _ch = pattern_midich[_pattern]

      if midi1_value[_note_part] >= 0 or midi2_value[_note_part] >= 0 or midi3_value[_note_part] >= 0 or midi4_value[_note_part] >= 0
        call @OnMetroPulse_CC_automation
      endif

      if voice1[_note_part] >= 0
        if ((Random 1, 100) <= note_probability[_note_part])
          call @OnMetroPulse_notes
        endif
      endif
    endif
  endfor
  FlashPad step
  Call @IncrementSequencer
@End

@OnMidiNoteOn
  _note_on_ticks = CurrentTimerTicks
  _el_ticks = _note_on_ticks - last_pulse_ticks
  _el_pct = (Round _el_ticks / (tickTime / timer_tick_resolution) * 100)
  nn = MIDINote
  v = MIDIVelocity

  if transpose AND mode_pad_edit <> 1 
    transposeNote = MIDINote - 48
    LabelPads {âš ï¸Transpose: }, transposeNote
    Exit
  endif
  
  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS)
    SendMidiThruOnCh pattern_midich[active_pattern]
    Exit
  endif
  
  _supressMidiThru = NO
 
  if mode_pad_edit = 1
    pad_edit_got_note = YES
    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 
    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part
 
    if not Unassigned pad_edit_part_pad  // Latch and label when editing parts of step
      LabelPad pad_edit_part_pad, (NoteName nn, YES)
      LatchPad pad_edit_part_pad, 1
    endif
    _supressMidiThru = YES
  else
    _step = step
    if quantize = QUANT_STEP
      if step_part > 5  // if we are within 25% of next step then quantize to that 
        _step = (_step  + 1) % 16
        _supressMidiThru = YES
      endif
      _note_part = (active_pattern * sizeof_pattern) + _step * step_reso
    else
      if quantize = QUANT_PART and _el_pct > 50
        // if note is closer to next part, then quantize to that one
        note_part = (note_part + (Round _el_pct/100)) % (16 * step_reso)
        _supressMidiThru = YES
      endif
      _note_part = (active_pattern * sizeof_pattern) + note_part
    endif
  endif
  
  v_trans = Clip v * pattern_velocurve[active_pattern], 0, 127 

  if not _supressMidiThru
    SendMIDINoteOn pattern_midich[active_pattern], nn, v_trans 
    // SendMidiThruOnCh pattern_midich[active_pattern]
  endif

  _poly_offset = polycount[_note_part]
 
  if _poly_offset = 0
    voice1[_note_part] = nn
    voice1_velocity[_note_part] = v
  elseif _poly_offset = 1
    voice2[_note_part] = nn
    voice2_velocity[_note_part] = v
  elseif _poly_offset = 2
    voice3[_note_part] = nn
    voice3_velocity[_note_part] = v
  elseif _poly_offset = 3
    voice4[_note_part] = nn
    voice4_velocity[_note_part] = v
  elseif _poly_offset = 4
    voice5[_note_part] = nn
    voice5_velocity[_note_part] = v
  elseif _poly_offset = 5
    voice6[_note_part] = nn
    voice6_velocity[_note_part] = v
  endif

  if _poly_offset < 6
    Inc _poly_offset
  endif

  polycount[_note_part] = _poly_offset
  noteOnTicks[_note_part] = CurrentTimerTicks //total_tickCounter

  // record knob settings if playing with CC arm on
  if midi_rec_mode <> MIDI_REC_OFF
    note_velocityX[_note_part] = pattern_velocurve[active_pattern]
    note_strum[_note_part] = pattern_strum[active_pattern]
  endif

  if quantize = QUANT_NONE and HostRunning and not mode_pad_edit // we can only have delay if metronome is running
    noteOnDelayTicks[_note_part] = _note_on_ticks - last_pulse_ticks
  else
    noteOnDelayTicks[_note_part] = 0
  endif

  // Store part so that MidiNoteOff can reference all data of the note being played
  SetNoteState 0, nn, _note_part    

  if not mode_pad_edit
    if not UIMODE_BUTTONS
      LabelPad _step, _poly_offset, {:}, (NoteName nn, YES) 
    endif
    LatchPad _step, 1
  endif
  last_note = nn      // for single-tap edit
  last_velocity = nn  
@End 

@OnMidiNoteOff

// TODO: Should to send explicit midi command with velocity set to gateX_knob (or "As Played") to make "midi thru" consistent with sequencer settings
  SendMidiThruOnCh pattern_midich[active_pattern]

  if not ((record and HostRunning) or mode_pad_edit = 1) or transpose or (uiMode = UIMODE_BUTTONS)
    Exit
  endif
  nn = MIDINote
  v = MIDIVelocity
  _note_part = GetNoteState 0, nn

  // Dont store anything unless state was set to <> -1. 
  if _note_part = -1
    Exit
  endif
  // Reset state to prevent OnMidiOff action when notes are played with recording off 
  SetNoteState 0, nn, -1

  _note_step = Div (_note_part - active_pattern * sizeof_pattern), step_reso
  _note_pad = _note_part - ((active_pattern * sizeof_pattern) + _note_step * step_reso)
  if _note_step < 8
    _note_pad = _note_pad + 8
  endif

  _on_ticks = noteOnTicks[_note_part]
  _off_ticks = CurrentTimerTicks // total_tickCounter
  _elapsed_ticks = _off_ticks - _on_ticks

  // Special case:
  // if transport is stopped or we have long steps (like 2 bars) we might get 0 ticks so we default to 1 step for these cases.
  // we might also get negative elapse ticks if timer wrapped around the 16-bit int limit, so we just say 100% elapsed as a safeguard
  if _elapsed_ticks <= 0
    _elapsed_pct = 100
  else
    _elapsed_pct = _elapsed_ticks * timer_tick_resolution / gate * 100
  endif

  if gateX_knob < 0
    gateX[_note_part] = _elapsed_pct  // elapsed as percentage of gate
  elseif midi_rec_mode <> MIDI_REC_OFF
    gateX[_note_part] = gateX_knob  // Set fixed gate from knob if CC arm is on 
  endif

  if not mode_pad_edit 
    LabelPad _note_step, (NoteName nn, YES), {:}, Round(gateX[_note_part]) 
  else
    LabelPad _note_pad, {ğŸ”´}, (NoteName nn, YES), {:}, Round(gateX[_note_part]) 
  endif
@End

// REFACTOR: Uses _note_part, which is not defined here. 
@OnMidiCC
  _cc = MIDIByte2
  _val = MIDIByte3

  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS)  or transpose or midi_rec_mode = MIDI_REC_OFF
    SendMidiThruOnCh pattern_midich[active_pattern]
    Exit
  endif
   
  _supressMidiThru = NO
 
  if mode_pad_edit = 1
    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 
    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part

    LabelPad pad_edit_part_pad, {CC: }, _cc, {:}, _val
    _supressMidiThru = YES
  else
    _step = step
    LabelPad _step, _cc, {: }, _val
  endif

  if not _supressMidiThru
    SendMidiThruOnCh pattern_midich[active_pattern]
  endif

  _midi_offset = -1
  _slot_base = active_pattern * midi_slots
  if pattern_CC_slot_map[_slot_base] = _cc
    _midi_offset = 0
  elseif pattern_CC_slot_map[_slot_base + 1] = _cc
    _midi_offset = 1
  elseif pattern_CC_slot_map[_slot_base + 2] = _cc
    _midi_offset = 2
  elseif pattern_CC_slot_map[_slot_base + 3] = _cc
    _midi_offset = 3
  endif

  if _midi_offset = -1
    if pattern_CC_slot_map[_slot_base] = -1
      _midi_offset = 0
    elseif pattern_CC_slot_map[_slot_base + 1] = -1
      _midi_offset = 1
    elseif pattern_CC_slot_map[_slot_base + 2] = -1
      _midi_offset = 2
    elseif pattern_CC_slot_map[_slot_base + 3] = -1
      _midi_offset = 3
    else
      Log {OUT OF SLOTS! Not recording: }, _cc, {:}, _val
      Exit
    endif  
    pattern_CC_slot_map[_slot_base + _midi_offset] = _cc
  endif

  if midi_rec_mode = MIDI_REC_WRITE and midi_write_last_step <> _step
    _step_part = (active_pattern * sizeof_pattern) + _step * step_reso // The note location for the pad being edited.
    if _midi_offset = 0
      FillArray midi1_value[_step_part], -1, step_reso
    elseif _midi_offset = 1
      FillArray midi2_value[_step_part], -1, step_reso
    elseif _midi_offset = 2
      FillArray midi3_value[_step_part], -1, step_reso
    elseif _midi_offset = 3
      FillArray midi4_value[_step_part], -1, step_reso  
    endif
    Log {Clearing step }, _step, { at offset }, _midi_offset
    midi_write_last_step = _step
  endif

  if _midi_offset = 0
    midi1_value[_note_part] = _val
  elseif _midi_offset = 1
    midi2_value[_note_part] = _val
  elseif _midi_offset = 2
    midi3_value[_note_part] = _val
  elseif _midi_offset = 3
    midi4_value[_note_part] = _val
  endif

  _midicount = 0
  if pattern_CC_slot_map[_slot_base] > -1
    Inc _midicount
  endif
  if pattern_CC_slot_map[_slot_base +1] > -1
    Inc _midicount
  endif
  if pattern_CC_slot_map[_slot_base +2] > -1
    Inc _midicount
  endif
  if pattern_CC_slot_map[_slot_base +3] > -1
    Inc _midicount
  endif

  midicount[_note_part] = _midicount

  Log {Recorded midi, CC: }, _cc, {:}, _val, { -> offset: }, _midi_offset, {)},{ part:}, _note_part
@End


//  â•”â•â•—â•¦ â•¦â•¦â•”â•â•—â•”â•¦â•—
//  â•šâ•â•—â• â•â•£â•‘â• â•£  â•‘ 
//  â•šâ•â•â•© â•©â•©â•š   â•© 

@OnShiftDown
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    Call @SetUIMode_Voices 
  elseif uiMode = UIMODE_VOICES
    Call @SetUIMode_Pads
  elseif uiMode = UIMODE_PADS
    Call @SetUIMode_Buttons
  elseif uiMode = UIMODE_BUTTONS
    Call @SetUIMode_Pads
  elseif uiMode = UIMODE_HELP
    Call @SetUIMode_Buttons
  endif
@End 


//  â•”â•â•—â•”â•â•—â•”â•¦â•—       â•¦ â•¦â•”â•â•—â•¦  â•”â•¦â•—
//  â• â•â•â• â•â•£ â•‘â•‘  â”€â”€â”€  â• â•â•£â•‘ â•‘â•‘   â•‘â•‘
//  â•©  â•© â•©â•â•©â•       â•© â•©â•šâ•â•â•©â•â•â•â•©â•

@OnPadHold
  if uiMode = UIMODE_PADS
    pad_edit_step = pad
    mode_pad_edit = 1
    pad_edit_part = 0 
    if pad < 8
      pad_edit_part_pad = 8  // used for latching pad in UI. "hold to edit" always edits first part of step
    else
      pad_edit_part_pad = 0
    endif
    pad_edit_got_note = NO
    pad_edit_hold = 1
    LabelPad pad, {Editing...} 
    Call @UpdateGUI
  elseif uiMode = UIMODE_BUTTONS
    if pad = BTN_CLEAR_ALL
      LabelPad BTN_CLEAR_ALL, {âœ…Cleared}
      Call @ClearSequencer
    elseif pad = BTN_CLEAR_ARMED
      LabelPad BTN_CLEAR_ARMED, {âœ…Cleared}
      Call @ClearActivePattern
    elseif pad = BTN_MIDI
      LabelPad BTN_MIDI, {âœ…Cleared}
      Call @ClearActivePatternMidi
    elseif pad >= 8 and pad <= 14
      if mode_multi_pattern
        _pattern = pad - 8
        active_pattern = _pattern
        LatchPad pad, playing_patterns[_pattern]
      endif

    Call @UpdateGUI

    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
   endif
  endif
@End

//  â•”â•â•—â•”â•â•—â•”â•¦â•—       â•”â•â•—â•¦â•”â•—â•”â•”â•â•—â•¦  â•”â•â•—  â•”â•¦â•—â•”â•â•—â•”â•â•—
//  â• â•â•â• â•â•£ â•‘â•‘  â”€â”€â”€  â•šâ•â•—â•‘â•‘â•‘â•‘â•‘ â•¦â•‘  â•‘â•£    â•‘ â• â•â•£â• â•â•
//  â•©  â•© â•©â•â•©â•       â•šâ•â•â•©â•â•šâ•â•šâ•â•â•©â•â•â•šâ•â•   â•© â•© â•©â•©  

@OnPadSingleTap // param: pad
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    Call @OnPadSingleTap_InPadEdit

  elseif uiMode = UIMODE_PADS  // pads
    Call @EnterPadEditMode

  elseif uiMode = UIMODE_BUTTONS and mode_copy_pattern = YES
    Call @OnPadSingleTap_InCopyPattern

  elseif uiMode = UIMODE_BUTTONS
    Call @OnPadSingleTap_Buttons

  endif
@End

@OnPadSingleTap_InPadEdit
  if (pad_edit_step > 7 AND pad > 7) OR (pad_edit_step <= 7 AND pad <= 7)  // pad and tapped pad are on the same row  
    mode_pad_edit = 0
    Call @UpdateGUI
  else  
    _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
    if voice1[_note_part] > -1
      LabelPad pad_edit_part_pad, {ğŸ”µ}, (NoteName voice1[_note_part], YES), {:}, (Round gateX[_note_part])
    else
      LabelPad pad_edit_part_pad, {âšªï¸}
    endif

    pad_edit_part = pad % step_reso // Only step_reso parts
    pad_edit_part_pad = pad // for UI usage like latching pad etc during edit
    pad_edit_got_note = NO

    _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)

    pad_edit_note_part = _note_part // used for Voices mode

    if voice1[_note_part] > -1
      LabelPad pad_edit_part_pad, {ğŸ”´}, (NoteName voice1[_note_part], YES), {:}, gateX[_note_part]
    else
      LabelPad pad_edit_part_pad, {ğŸ”´}
    endif
    LabelPads {âš ï¸ Editing }, pad_edit_step, {:} , pad_edit_part, {  â„¹ï¸ SHIFT for voices }
  endif
@End

@EnterPadEditMode
  mode_pad_edit = 1
  pad_edit_step = pad
  pad_edit_part = 0
  pad_edit_got_note = NO
  if pad < 8
    pad_edit_part_pad = 8 // for UI usage like latching pad etc during edit
  else
    pad_edit_part_pad = 0
  endif

  _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
  pad_edit_note_part = _note_part // used for Voices mode
  
  Call @UpdateGUI
@End

@OnPadSingleTap_InCopyPattern
  mode_copy_pattern = NO
  if pad < 8
    exit
  endif
  _pattern = pad - 8
  _src_pattern_pos = active_pattern * sizeof_pattern
  _dest_pattern_pos = _pattern * sizeof_pattern

  Call @CopyPattern
  LabelPad _pattern + 8, {P}, active_pattern+1, {CPY, ARM}
  LatchPad active_pattern+8, 0
  LatchPad _pattern + 8, 1
  active_pattern = _pattern  // Auto-arm after copy
@End

@OnPadSingleTap_Buttons  
  if pad = BTN_TRANSPOSE
    transpose = not transpose
    LabelPad BTN_TRANSPOSE, { Transpose: }, transpose
    LabelPads {âš ï¸Transpose: }, transpose

  elseif pad = BTN_CLEAR_ALL
    LabelPads {âš ï¸ Hold Clear All pad to clear all patterns âš ï¸}
    LabelPad BTN_CLEAR_ALL, {ï¸âš ï¸hold=clr}

ï¸  elseif pad = BTN_CLEAR_ARMED
    LabelPads {âš ï¸ Hold Clear Armed pad to clear current pattern âš ï¸}
    LabelPad BTN_CLEAR_ALL, {ï¸âš ï¸hold=clr}

  elseif pad = BTN_RECORD
    record = not record
    Call @UpdateGUI

  elseif pad = BTN_MIDI
    midi_rec_mode = (midi_rec_mode + 1) % 3
    Call @UpdateGUI
    if midi_rec_mode = MIDI_REC_OFF
      LabelPads {CC âšª off âš ï¸ Hold CC rec to clear CC automation for current pattern âš ï¸}
    elseif midi_rec_mode = MIDI_REC_WRITE
      LabelPads {CC ğŸ”´ WRITE  âš ï¸ Hold CC rec to clear CC automation for current pattern âš ï¸}
    elseif midi_rec_mode = MIDI_REC_OVERDUB
      LabelPads {CC ğŸ…¾ï¸OVERDUB âš ï¸ Hold CC rec to clear CC automation for current pattern âš ï¸}
    endif

  elseif pad = BTN_QUANTIZE
    quantize = (quantize + 1) % 3
    Call @UpdateGUI
    
  elseif pad = BTN_COPY_PATTERN
    LabelPads { Select pattern to copy active pattern to }
    mode_copy_pattern = YES

  elseif pad = BTN_MULTI_PATTERN
      mode_multi_pattern = not mode_multi_pattern
      if mode_multi_pattern
        LabelPads { Select patterns to play simultaneously }
        LabelPad BTN_MULTI_PATTERN, {Multi: ON}
      else
        LabelPads { Single pattern arm mode }
        LabelPad BTN_MULTI_PATTERN, {Multi: OFF}
      endif
      Call @UpdateGUI

  elseif pad = BTN_HELP
    Call @SetUIMode_Help

  elseif pad >= 8 and pad <= 14     // Pattern ARM. Future proof with upper bound ;)
    if mode_multi_pattern
      _pattern = pad - 8
      active_pattern = _pattern
      _current_state = playing_patterns[_pattern]
      _new_state = not _current_state

      playing_patterns[_pattern] = _new_state
      LatchPad pad, playing_patterns[_pattern]
    else
      last_active_pattern = active_pattern
      active_pattern = pad-8
    endif

    Call @UpdateGUI

    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
   endif
@End



//  â•”â•â•—â•”â•â•—â•”â•¦â•—       â•”â•¦â•—â•”â•â•—â•¦ â•¦â•”â•— â•¦  â•”â•â•—  â•”â•¦â•—â•”â•â•—â•”â•â•—
//  â• â•â•â• â•â•£ â•‘â•‘  â”€â”€â”€   â•‘â•‘â•‘ â•‘â•‘ â•‘â• â•©â•—â•‘  â•‘â•£    â•‘ â• â•â•£â• â•â•
//  â•©  â•© â•©â•â•©â•       â•â•©â•â•šâ•â•â•šâ•â•â•šâ•â•â•©â•â•â•šâ•â•   â•© â•© â•©â•©  

@OnPadDoubleTap
  if uiMode = UIMODE_BUTTONS
    Exit
  endif
  if mode_pad_edit = 1 
    del_step_part = pad % 8
    del_step = pad_edit_step
    del_step_pos = del_step * step_reso + del_step_part // The note location in the wide grid

    _del_note_part = (active_pattern * sizeof_pattern) + del_step_pos

    polycount[_del_note_part] = 0
    voice1[_del_note_part] = -1
    voice2[_del_note_part] = -1
    voice3[_del_note_part] = -1
    voice4[_del_note_part] = -1
    voice5[_del_note_part] = -1
    voice6[_del_note_part] = -1
    velocity[_del_note_part] = 100
    gateX[_del_note_part] = 100

    LatchPad pad, 0
    LabelPad pad, { }
  else
    del_step = pad
    del_note_part = del_step * step_reso // The note location in the wide grid

    for po = 0 to step_reso - 1
      _del_note_part = (active_pattern * sizeof_pattern) + (del_note_part + po) 
      polycount[_del_note_part] = 0
      voice1[_del_note_part] = -1
      voice2[_del_note_part] = -1
      voice3[_del_note_part] = -1
      voice4[_del_note_part] = -1
      voice5[_del_note_part] = -1
      voice6[_del_note_part] = -1
      velocity[_del_note_part] = 100
      gateX[_del_note_part] = 100
      note_repeat[_del_note_part] = 1
    endfor
  
    LatchPad del_step, 0
    LabelPad del_step, { }
  endif
@End



//  â•¦â•”â•â•”â•—â•”â•”â•â•—â•”â•— â•”â•â•—
//  â• â•©â•—â•‘â•‘â•‘â•‘ â•‘â• â•©â•—â•šâ•â•—
//  â•© â•©â•â•šâ•â•šâ•â•â•šâ•â•â•šâ•â•

@OnKnobChange
  if uiMode = UIMODE_PADS 
    call @OnKnobChange_Pads
  elseif uiMode = UIMODE_BUTTONS
    call @OnKnobChange_Buttons
  elseif uiMode = UIMODE_VOICES
    call @OnKnobChange_Voices
  endif
@End

@OnKnobChange_Voices
  _part = pad_edit_note_part
  _value = GetKnobValue LastKnob
  _voice = LastKnob + 1
 
  if polycount[_part] < _voice and _voice <= 6
    polycount[_part] = _voice
  endif
  
  if LastKnob = VKNOB_VOICE1
    voice1[_part] = _value
    LabelKnob VKNOB_VOICE1, (NoteName _value, YES)
  elseif LastKnob = VKNOB_VOICE2
    voice2[_part] = _value
    LabelKnob VKNOB_VOICE2, (NoteName _value, YES)
  elseif LastKnob = VKNOB_VOICE3
    voice3[_part] = _value
    LabelKnob VKNOB_VOICE3, (NoteName _value, YES)
  elseif LastKnob = VKNOB_VOICE4
    voice4[_part] = _value
    LabelKnob VKNOB_VOICE4, (NoteName _value, YES)
  elseif LastKnob = VKNOB_VOICE5
    voice5[_part] = _value
    LabelKnob VKNOB_VOICE5, (NoteName _value, YES)
  elseif LastKnob = VKNOB_VOICE6
    voice6[_part] = _value
    LabelKnob VKNOB_VOICE6, (NoteName _value, YES)
  elseif LastKnob = VKNOB_GATE  // gate. knob is mapped linearly from 0-100% for the first 1/4 of the slider, then from 100-1600 for the "upper" 75%.
    _ntx = _value
    if _ntx <= 32
      _ntx = Round(_ntx * 3.125)
    else
      _ntx = Round(((_ntx-32) / 95) * 1500) + 100
    endif
    gateX[_part] = _ntx
    LabelKnobs _ntx, {%}
    
  elseif LastKnob = VKNOB_PROBABILITY 
    _p = Round(_value / 127 * 100)
    note_probability[_part] = _p
    LabelKnobs _p, {%}
  
  elseif LastKnob = VKNOB_RATCHET
    _rpts = (Round (TranslateScale _value, 1, 127, 1, 6))
    note_repeat[_part] = _rpts
    LabelKnobs _rpts 

  elseif LastKnob = VKNOB_VELOCITY 
    _vxknob = _value
    if _vxknob = 0
      _vx = -1
    elseif _vxknob < 60
      _vx = TranslateScale _vxknob, 1, 60, 0, 1
    elseif _vxknob > 68
      _vx = TranslateScale _vxknob, 69, 127, 1, 10
    else
      _vx = 1.0
    endif
    note_velocityX[_part] = _vx
    if _vx >= 0
      LabelKnobs (Round _vx * 100), {%}
    else
      LabelKnobs {âš ï¸Unset=Uses pattern velocity setting}
    endif

    _vcurve = _vx
    _n = voice1[_part]
    _n1 = _n

    _v = Clip voice1_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 0, (NoteName _n, YES), {:}, Round _v

    _n = voice2[_part]
    _v = Clip voice2_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 1, (NoteName _n, YES), {:}, Round _v

    _n = voice3[_part]
    _v = Clip voice3_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 2, (NoteName _n, YES), {:}, Round _v

    _n = voice4[_part]
    _v = Clip voice4_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 3, (NoteName _n, YES), {:}, Round _v

    _n = voice5[_part]
    _v = Clip voice5_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 4, (NoteName _n, YES), {:}, Round _v

    _n = voice6[_part]
    _v = Clip voice6_velocity[_part] * _vcurve, 0, 127 
    LabelKnob 5, (NoteName _n, YES), {:}, Round _v

  elseif LastKnob = VKNOB_STRUM
      _value = TranslateScale _value, 0, 127, 0, 200
      note_strum[_part] = _value
      LabelKnobs (Round _value), {ms}

  elseif LastKnob = VKNOB_SLOT1CC
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots] = _value
    LabelKnob VKNOB_SLOT1CC, {A:CC }, _value
    LabelKnobs {CC}, _value, {âš ï¸ Affects whole pattern! âš ï¸}

  elseif LastKnob = VKNOB_SLOT1VAL
    _value = Round _value
    midi1_value[_part] = _value
    LabelKnob VKNOB_SLOT1VAL, {A: }, _value
    
  elseif LastKnob = VKNOB_SLOT2CC
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots +1] = _value
    LabelKnob VKNOB_SLOT2CC, {B:CC }, _value
    LabelKnobs {CC}, _value, {âš ï¸ Affects whole pattern! âš ï¸}

  elseif LastKnob = VKNOB_SLOT2VAL
    _value = Round _value
    midi2_value[_part] = _value
    LabelKnob VKNOB_SLOT2VAL, {B: }, _value

  elseif LastKnob = VKNOB_SLOT3CC
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots +2] = _value
    LabelKnob VKNOB_SLOT3CC, {C:CC }, _value
    LabelKnobs {CC}, _value, {âš ï¸ Affects whole pattern! âš ï¸}

  elseif LastKnob = VKNOB_SLOT3VAL
    _value = Round _value
    midi3_value[_part] = _value
    LabelKnob VKNOB_SLOT3VAL, {C: }, _value

  elseif LastKnob = VKNOB_SLOT4CC
    _value = Round _value
    pattern_CC_slot_map[active_pattern * midi_slots +3] = _value
    LabelKnob VKNOB_SLOT4CC, {D:CC }, _value
    LabelKnobs {CC}, _value, {âš ï¸ Affects whole pattern! âš ï¸}

  elseif LastKnob = VKNOB_SLOT4VAL
    _value = Round _value
    midi4_value[_part] = _value
    LabelKnob VKNOB_SLOT4VAL, {D: }, _value
  endif

@End

@OnKnobChange_Buttons
  if LastKnob = KNOB_STEP
    currentDivisor = Round ((GetKnobValue KNOB_STEP) / 16)
    if currentDivisor = 0
      LabelKnobs {1/32}
    elseif currentDivisor = 1
      LabelKnobs {1/16}
    elseif currentDivisor = 2
      LabelKnobs {1/8t}
    elseif currentDivisor = 3
      LabelKnobs {1/8}
    elseif currentDivisor = 4
      LabelKnobs {1/4}
    elseif currentDivisor = 5
      LabelKnobs {1/2}
    elseif currentDivisor = 6
      LabelKnobs {bar}
    elseif currentDivisor = 7
      LabelKnobs {2 bar}
    endif
    call @ComputeTimes

  elseif LastKnob = KNOB_MIDICH
    _midich = RoundDown((GetKnobValue KNOB_MIDICH) / 128 * 16)
    pattern_midich[active_pattern] = _midich
    LabelKnobs _midich + 1
  endif
@End

@OnKnobChange_Pads

  if LastKnob = KNOB_GATE
    gateX_knob = Round((GetKnobValue KNOB_GATE) / 127 * 800)  
    if gateX_knob < 6.25
      gateX_knob = -1 // "As Played"
      LabelKnobs {As Played}
    else
      LabelKnobs gateX_knob*1.000, {%}
    endif
    if gateX_knob > 0 and mode_pad_edit = 1    // REFACTOR: use pad_edit_note_part below (and in other similar places)
      gateX[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = gateX_knob
      Log {Recording gate change for }, pad_edit_step, {:}, pad_edit_part
    elseif gateX_knob > 0 and midi_rec_mode <> MIDI_REC_OFF
    // Record knob movement - to *next* part as the current has already sent its midi notes. 
      _np = (note_part + 1) % sizeof_pattern 
      gateX[(active_pattern * sizeof_pattern) + _np] = gateX_knob
    endif

  elseif LastKnob = KNOB_PROBABILITY
    _probability = (GetKnobValue KNOB_PROBABILITY) / 127 * 100
    if mode_pad_edit = 1
      note_probability[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _probability
    else
      note_probability[(active_pattern * sizeof_pattern) + note_part] = _probability
    endif
    probability_knob = _probability
    LabelKnobs (Round probability_knob), {%}

  elseif LastKnob = KNOB_VELOCITY
    _vxknob = GetKnobValue KNOB_VELOCITY
    if _vxknob = 0
      _vx = -1
    elseif    _vxknob < 60
      _vx = TranslateScale _vxknob, 1, 60, 0, 1
    elseif _vxknob > 68
      _vx = TranslateScale _vxknob, 69, 127, 1, 10
    else
      _vx = 1.0
    endif

    if mode_pad_edit = 1
      note_velocityX[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _vx
    elseif midi_rec_mode <> MIDI_REC_OFF    // Record knob movement - to *next* part as the current has already sent its midi notes. 
      _np = (note_part + 1) % sizeof_pattern 
      note_velocityX[(active_pattern * sizeof_pattern) + _np] = _vx
    endif
    if _vx >= 0
      LabelKnobs (Round _vx * 100), {%}
    else
      LabelKnobs {As played}
    endif
    pattern_velocurve[active_pattern] = _vx

    elseif LastKnob = KNOB_STRUM
      _s = (TranslateScale (GetKnobValue KNOB_STRUM), 0, 127, 0, 200)
      pattern_strum[active_pattern] = _s
      if mode_pad_edit = 1
        note_strum[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _s
      elseif midi_rec_mode <> MIDI_REC_OFF    // Record knob movement - to *next* part as the current has already sent its midi notes. 
        _np = (note_part + 1) % sizeof_pattern 
        note_strum[(active_pattern * sizeof_pattern) + _np] = _s
      endif
      LabelKnobs (Round _s)
  endif
@End

//  â•”â•â•—â•”â•â•—â•”â•â•—â•¦ â•¦  â•”â•â•—â•”â•â•—â•”â•¦â•—â•”â•¦â•—â•”â•â•—â•¦â•â•—â•”â•—â•”
//  â•‘  â•‘ â•‘â• â•â•â•šâ•¦â•  â• â•â•â• â•â•£ â•‘  â•‘ â•‘â•£ â• â•¦â•â•‘â•‘â•‘
//  â•šâ•â•â•šâ•â•â•©   â•©   â•©  â•© â•© â•©  â•© â•šâ•â•â•©â•šâ•â•â•šâ•
// requires
//  _pattern = CopyPattern_pattern
//  _src_pattern_pos = CopyPattern_src_pattern_pos
//  _dest_pattern_pos = CopyPattern_dest_pattern_pos
@CopyPattern


  CopyArray voice1[_src_pattern_pos], voice1[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2[_src_pattern_pos], voice2[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3[_src_pattern_pos], voice3[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4[_src_pattern_pos], voice4[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5[_src_pattern_pos], voice5[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6[_src_pattern_pos], voice6[_dest_pattern_pos], sizeof_pattern
  CopyArray voice1_velocity[_src_pattern_pos], voice1_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2_velocity[_src_pattern_pos], voice2_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3_velocity[_src_pattern_pos], voice3_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4_velocity[_src_pattern_pos], voice4_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5_velocity[_src_pattern_pos], voice5_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6_velocity[_src_pattern_pos], voice6_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray polycount[_src_pattern_pos], polycount[_dest_pattern_pos], sizeof_pattern
  CopyArray gateX[_src_pattern_pos], gateX[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnTicks[_src_pattern_pos], noteOnTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnDelayTicks[_src_pattern_pos], noteOnDelayTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray note_probability[_src_pattern_pos], note_probability[_dest_pattern_pos], sizeof_pattern
  CopyArray note_velocityX[_src_pattern_pos], note_velocityX[_dest_pattern_pos], sizeof_pattern
  CopyArray note_strum[_src_pattern_pos], note_strum[_dest_pattern_pos], sizeof_pattern
  CopyArray note_repeat[_src_pattern_pos], note_strum[_dest_pattern_pos], sizeof_pattern
@End

//  â”Œâ”€â”â”¬  â”Œâ”€â”â”Œâ”€â”â”¬â”€â”  â”Œâ”€â”â”Œâ”€â”â”Œâ”¬â”â”Œâ”¬â”â”Œâ”€â”â”¬â”€â”â”Œâ”â”Œâ”Œâ”€â”
//  â”‚  â”‚  â”œâ”¤ â”œâ”€â”¤â”œâ”¬â”˜  â”œâ”€â”˜â”œâ”€â”¤ â”‚  â”‚ â”œâ”¤ â”œâ”¬â”˜â”‚â”‚â”‚â””â”€â”
//  â””â”€â”˜â”´â”€â”˜â””â”€â”˜â”´ â”´â”´â””â”€  â”´  â”´ â”´ â”´  â”´ â””â”€â”˜â”´â””â”€â”˜â””â”˜â””â”€â”˜

@ClearSequencer
  FillArray polycount, 0
  FillArray voice1, -1
  FillArray voice1_velocity, 0
  FillArray voice2, -1
  FillArray voice2_velocity, 0
  FillArray voice3, -1
  FillArray voice3_velocity, 0
  FillArray voice4, -1
  FillArray voice4_velocity, 0
  FillArray voice5, -1
  FillArray voice5_velocity, 0
  FillArray voice6, -1
  FillArray voice6_velocity, 0
  FillArray midicount, 0
  FillArray midi1_value, -1
  FillArray midi2_value, -1
  FillArray midi3_value, -1
  FillArray midi4_value, -1
  FillArray pattern_CC_slot_map, -1
  FillArray pattern_velocurve, 1.0, 8
  FillArray pattern_strum, 0, 8
  FillArray gateX, 100
  FillArray noteOnTicks, 0
  FillArray noteOnDelayTicks, 0
  FillArray note_probability, 100
  FillArray note_velocityX, -1
  FillArray note_strum, -1
  playing_patterns = [ YES, NO, NO, NO, NO, NO, NO ]
  FillArray note_repeat, 1
@End

@ClearActivePattern
  _pattern_start = active_pattern * sizeof_pattern
  FillArray polycount[_pattern_start], 0, sizeof_pattern
  FillArray voice1[_pattern_start], -1, sizeof_pattern
  FillArray voice1_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice2[_pattern_start], -1, sizeof_pattern 
  FillArray voice2_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice3[_pattern_start], -1, sizeof_pattern 
  FillArray voice3_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice4[_pattern_start], -1, sizeof_pattern 
  FillArray voice4_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice5[_pattern_start], -1, sizeof_pattern 
  FillArray voice5_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice6[_pattern_start], -1, sizeof_pattern
  FillArray voice6_velocity[_pattern_start], 0, sizeof_pattern
  FillArray gateX[_pattern_start], 100, sizeof_pattern
  FillArray noteOnTicks[_pattern_start], 0, sizeof_pattern
  FillArray noteOnDelayTicks[_pattern_start], 0, sizeof_pattern
  FillArray note_velocityX[_pattern_start], -1, sizeof_pattern
  FillArray note_strum[_pattern_start], -1, sizeof_pattern
  FillArray note_probability[_pattern_start], 100 , sizeof_pattern
  FillArray note_repeat[_pattern_start], 1, sizeof_pattern
  FillArray midicount[_pattern_start], 0, sizeof_pattern
  FillArray midi1_value[_pattern_start], -1, sizeof_pattern
  FillArray midi2_value[_pattern_start], -1, sizeof_pattern
  FillArray midi3_value[_pattern_start], -1, sizeof_pattern
  FillArray midi4_value[_pattern_start], -1, sizeof_pattern
  FillArray pattern_CC_slot_map[active_pattern * midi_slots], -1, midi_slots
  pattern_velocurve[active_pattern] = 1.0
  pattern_strum[active_pattern] = 0
@End

@ClearActivePatternMidi
  _pattern_start = active_pattern * sizeof_pattern
  FillArray midicount[_pattern_start], 0, sizeof_pattern
  FillArray midi1_value[_pattern_start], -1, sizeof_pattern
  FillArray midi2_value[_pattern_start], -1, sizeof_pattern
  FillArray midi3_value[_pattern_start], -1, sizeof_pattern
  FillArray midi4_value[_pattern_start], -1, sizeof_pattern
  FillArray pattern_CC_slot_map[active_pattern * midi_slots], -1, midi_slots
@End

//   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—
//  â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
//  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
//  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
//  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
//   â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•

@SetUIMode_Pads
  ShowLayout 2
  uiMode = UIMODE_PADS
  Call @UpdateGUI
@End

@SetUIMode_Voices
  ShowLayout 1
  uiMode = UIMODE_VOICES
  Call @UpdateGUI
@End

@SetUIMode_Help
  ShowLayout 4
  uiMode = UIMODE_HELP
  Call @UpdateGUI
@End

@SetUIMode_Buttons
  ShowLayout 2
  uiMode = UIMODE_BUTTONS
  mode_copy_pattern = NO
  Call @UpdateGUI
@End

@UpdateGUI
  if uiMode = UIMODE_PADS AND mode_pad_edit = 1
    call @GUI_PadEditMode
    Call @GUI_LabelPadEditKnobs

  elseif uiMode = UIMODE_PADS
    call @GUI_PadMode
    Call @GUI_LabelPadKnobs

  elseif uiMode = UIMODE_BUTTONS
    call @GUI_ButtonMode 
    call @GUI_LabelButtonKnobs
 
  elseif uiMode = UIMODE_VOICES
     call @GUI_VoicesMode
  
  elseif uiMode = UIMODE_HELP
    call @GUI_HelpMode
  endif
@End

@GUI_HelpMode
  // Void for now
@End

@GUI_VoicesMode
  _edit_note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso) + pad_edit_part

  _n = voice1[_edit_note_part]
  _n1 = _n
  _v = voice1_velocity[_edit_note_part] 

  LabelKnob VKNOB_VOICE1, (NoteName _n, YES), {:}, Round _v
  SetKnobValue VKNOB_VOICE1, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice2[_edit_note_part]
  _v = voice2_velocity[_edit_note_part] 
  LabelKnob VKNOB_VOICE2, (NoteName _n, YES), {:}, Round _v
  SetKnobValue VKNOB_VOICE2, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice3[_edit_note_part]
  _v = voice3_velocity[_edit_note_part] 
  LabelKnob VKNOB_VOICE3, (NoteName _n, YES), {:}, Round _v
  SetKnobValue VKNOB_VOICE3, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice4[_edit_note_part]
  _v = voice4_velocity[_edit_note_part] 
  LabelKnob VKNOB_VOICE4, (NoteName _n, YES), {:}, Round _v
  SetKnobValue VKNOB_VOICE4, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice5[_edit_note_part]
  _v = voice5_velocity[_edit_note_part] 
  LabelKnob VKNOB_VOICE5, (NoteName _n, YES), {:}, Round _v
  SetKnobValue VKNOB_VOICE5, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice6[_edit_note_part]
  _v = voice6_velocity[_edit_note_part] 
  LabelKnob VKNOB_VOICE6, (NoteName _n, YES), {:}, Round _v
  SetKnobValue VKNOB_VOICE6, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  LabelKnob VKNOB_GATE, {Gate}
  _ntx = gateX[_edit_note_part]
  if _ntx <= 100
    _ntx = Round _ntx / 3.125
  else
    _ntx = Round ((((_ntx - 100) / 1500) * 95) + 32)
  endif
  SetKnobValue VKNOB_GATE, _ntx

  LabelKnob VKNOB_PROBABILITY, {Probability}
  SetKnobValue VKNOB_PROBABILITY, (TranslateScale note_probability[_edit_note_part], 0, 100, 0, 127)

  LabelKnob VKNOB_RATCHET, {Ratchet}
  SetKnobValue VKNOB_RATCHET, (TranslateScale note_repeat[_edit_note_part], 1, 6, 0, 127)

  LabelKnob VKNOB_VELOCITY, {Velocity}
  _vx = note_velocityX[_edit_note_part]
  if _vx = 1
    _vxknob = 64
  elseif _vx > 1
    _vxknob = TranslateScale _vx, 1, 10, 69, 127
  elseif _vx < 1
    _vxknob = TranslateScale _vx, 0, 1, 0, 60
  endif
  SetKnobValue VKNOB_VELOCITY, _vxknob
 
  LabelKnob VKNOB_STRUM, {Strum}
  SetKnobValue VKNOB_STRUM, (TranslateScale pattern_strum[active_pattern], 0, 200, 0, 127) 
 
  LabelKnob VKNOB_SLOT1CC, {A:CC }, pattern_CC_slot_map[active_pattern*midi_slots]
  SetKnobValue VKNOB_SLOT1CC, pattern_CC_slot_map[active_pattern*midi_slots]
  LabelKnob VKNOB_SLOT2CC, {B:CC }, pattern_CC_slot_map[active_pattern*midi_slots +1]
  SetKnobValue VKNOB_SLOT2CC, pattern_CC_slot_map[active_pattern*midi_slots + 1]
  LabelKnob VKNOB_SLOT3CC, {C:CC }, pattern_CC_slot_map[active_pattern*midi_slots+2]
  SetKnobValue VKNOB_SLOT3CC, pattern_CC_slot_map[active_pattern*midi_slots + 2]
  LabelKnob VKNOB_SLOT4CC, {D:CC }, pattern_CC_slot_map[active_pattern*midi_slots+3]
  SetKnobValue VKNOB_SLOT4CC, pattern_CC_slot_map[active_pattern*midi_slots + 3]

  LabelKnob VKNOB_SLOT1VAL, {A: }, midi1_value[_edit_note_part]
  SetKnobValue VKNOB_SLOT1VAL, midi1_value[_edit_note_part]

  LabelKnob VKNOB_SLOT2VAL, {B: }, midi2_value[_edit_note_part]
  SetKnobValue VKNOB_SLOT2VAL, midi2_value[_edit_note_part]

  LabelKnob VKNOB_SLOT3VAL, {C: }, midi3_value[_edit_note_part]
  SetKnobValue VKNOB_SLOT3VAL, midi3_value[_edit_note_part]

  LabelKnob VKNOB_SLOT4VAL, {D: }, midi4_value[_edit_note_part]
  SetKnobValue VKNOB_SLOT4VAL, midi4_value[_edit_note_part]

  LabelKnobs {âš ï¸ Voices for }, pad_edit_step, {:} , pad_edit_part, {  â¬†ï¸ SHIFT to go back }
  LabelKnob 6, { }
  LabelKnob 16, { }
  LabelKnob 17, { }
@End

@GUI_PadMode

  for _step = 0 to 15
    _voice_cnt = 0
    _part_cnt = 0
    _po = (active_pattern * sizeof_pattern) + (_step * step_reso)
    _pc = polycount[_po+0] + polycount[_po+1] + polycount[_po+2] + polycount[_po+3] + polycount[_po+4] + polycount[_po+5] + polycount[_po+6] + polycount[_po+7]
    _mc = midicount[_po+0] + midicount[_po+1] + midicount[_po+2] + midicount[_po+3] + midicount[_po+4] + midicount[_po+5] + midicount[_po+6] + midicount[_po+7]
    
    if _pc > 0
      LatchPad _step, 1
      // Row below triggers parser bug in Mozaic if there are spaces after commas
      if _mc > 0
        LabelPad _step,{A},polycount[_po+0],polycount[_po+1],polycount[_po+2],polycount[_po+3],polycount[_po+4],polycount[_po+5],polycount[_po+6],polycount[_po+7]
      else
        LabelPad _step,polycount[_po+0],polycount[_po+1],polycount[_po+2],polycount[_po+3],polycount[_po+4],polycount[_po+5],polycount[_po+6],polycount[_po+7]
      endif
    else
      LatchPad _step, 0
      if _mc > 0
        LabelPad _step, {A}
      else
        LabelPad _step, { }
      endif
    endif
  endfor
  
 if transpose and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ âšªï¸ }, { transpose: }, transpose, { Play: Multi}, { quant: }, quantize
  elseif transpose
    LabelPads  {P}, active_pattern+1,{ âšªï¸ SOLO}, { transpose: }, transpose, { quant: }, quantize
  elseif record and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ ğŸ”´ }, { Play: Multi}, { quant: }, quantize
  elseif record
    LabelPads  {P}, active_pattern+1,{ ğŸ”´ SOLO}, { quant: }, quantize
  endif
  
@End

@GUI_PadEditMode
  if pad_edit_step <= 7
    _pad_offset = 8
  else
    _pad_offset = 0
  endif

  for the_part = 0 to step_reso-1
    _note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso + the_part)
    _cnt = polycount[_note_part]
    _mc = midicount[_note_part]
    _pad = the_part + _pad_offset
    if _cnt > 0
      if _mc > 0
        LabelPad _pad, _cnt, {:}, (NoteName voice1[_note_part], YES), {:}, (Round gateX[_note_part]), {A}
      else
        LabelPad _pad, _cnt, {:}, (NoteName voice1[_note_part], YES), {:}, (Round gateX[_note_part])
      endif
      LatchPad _pad, 1
    else // {ğŸ”µ},
      LatchPad _pad, 0
      if _mc > 0
        LabelPad _pad, {âšªï¸ A}
      else
        LabelPad _pad, {âšªï¸}, 
      endif
    endif
  endfor

  _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
  if voice1[_note_part] > -1
    LabelPad pad_edit_part_pad, {ğŸ”´}, (NoteName voice1[_note_part], YES), {:}, polycount[_note_part]
  else
    LabelPad pad_edit_part_pad, {ğŸ”´}
  endif
  LabelPad pad_edit_step, {âœ… Done}
  LabelPads {âš ï¸ Editing }, pad_edit_step, {:} , pad_edit_part, {  â¬†ï¸ SHIFT for voices }

@End

@GUI_ButtonMode
  for po = 0 to 15
    LabelPad po, { }
    LatchPad po, 0
  endfor
  
  if transpose
    LabelPad BTN_TRANSPOSE, {âš ï¸Transp ON}
  else
    LabelPad BTN_TRANSPOSE, {Transp OFF}
  endif

  LabelPad BTN_CLEAR_ALL, {Clear all}

  if record
    LabelPad BTN_RECORD, {Live rec ğŸ”´}
  else
    LabelPad BTN_RECORD, {Live rec âšª}
  endif
  
  if midi_rec_mode = MIDI_REC_OFF
    LabelPad BTN_MIDI, {CC rec âšª}
  elseif midi_rec_mode = MIDI_REC_WRITE
    LabelPad BTN_MIDI, {CC rec ğŸ”´}
  elseif midi_rec_mode = MIDI_REC_OVERDUB
    LabelPad BTN_MIDI, {CC rec ğŸ…¾ï¸}
  endif

  LabelPad BTN_COPY_PATTERN, {Copy pattern}
  LabelPad BTN_CLEAR_ARMED, {Clear armed}
  LabelPad BTN_HELP, {â„¹ï¸Help}

  if quantize = QUANT_NONE
    LabelPad BTN_QUANTIZE, {Quant: None} 
  elseif quantize = QUANT_PART
    LabelPad BTN_QUANTIZE, {Quant: Part} 
  else // QUANT_STEP
    LabelPad BTN_QUANTIZE, {Quant: Step} 
  endif

  if mode_multi_pattern  
    LabelPad BTN_MULTI_PATTERN, {Play: Multi}
    for _pattern = 0 to 6
      if playing_patterns[_pattern] = 1 // and active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { ğŸ”µ}
      else
        LabelPad _pattern + 8, {P}, _pattern+1, { âšª}
      endif
    endfor
  else
    LabelPad BTN_MULTI_PATTERN, {Play: Solo}
    for _pattern = 0 to 6
      if active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { SOLO}
      else
        LabelPad _pattern + 8, {P}, _pattern+1
      endif
    endfor
  endif

  LatchPad 8+active_pattern, 1
  if mode_multi_pattern
    LabelPads {Tap patterns to arm and toggle ON/OFF. Long-press for arm only. â¬†ï¸ SHIFT exits.}
  else
    LabelPads {Tap pattern to solo & arm. â¬†ï¸ SHIFT exits.}
  endif
@End

@GUI_LabelButtonKnobs
  LabelKnobs {P}, active_pattern+1, { settings}
  LabelKnob KNOB_STEP, {Step}
  LabelKnob KNOB_MIDICH, {Midi CH}
  SetKnobValue KNOB_MIDICH, pattern_midich[active_pattern]*8+4 
  LabelKnob 2, { }
  LabelKnob 3, { }
@End

@GUI_LabelPadKnobs
  LabelKnobs {P}, active_pattern+1, { rec params}
  LabelKnob KNOB_GATE, {Gate}
  _ntx = gateX_knob
  if _ntx <= 100
    _ntx = Round _ntx / 3.125
  else
    _ntx = Round ((((_ntx - 100) / 1500) * 95) + 32)
  endif
  SetKnobValue KNOB_GATE, _ntx

  LabelKnob KNOB_VELOCITY, {Velocity}
  _vx = pattern_velocurve[active_pattern]
  if _vx = 1
    _vxknob = 64
  elseif _vx > 1
    _vxknob = TranslateScale _vx, 1, 10, 69, 127
  elseif _vx < 1
    _vxknob = TranslateScale _vx, 0, 1, 0, 60
  endif
  SetKnobValue KNOB_VELOCITY, _vxknob

  LabelKnob KNOB_PROBABILITY, {Probability}
  LabelKnob KNOB_STRUM, {Strum}
  SetKnobValue KNOB_STRUM, (TranslateScale pattern_strum[active_pattern], 0, 200, 0, 127) 
 
@End

@GUI_LabelPadEditKnobs
  Call @GUI_LabelPadKnobs
  LabelKnobs pad_edit_step, {:} , pad_edit_part, { params}
@End

//  â•”â•â•—â•”â•â•—â•”â•¦â•—  â•”â•¦â•—â•”â•â•—â•”â•—â•”â•”â•â•—â•”â•â•—â•”â•â•—â•¦â•â•—
//  â• â•â•â• â•â•£ â•‘â•‘  â•‘â•‘â•‘â• â•â•£â•‘â•‘â•‘â• â•â•£â•‘ â•¦â•‘â•£ â• â•¦â•
//  â•©  â•© â•©â•â•©â•  â•© â•©â•© â•©â•â•šâ•â•© â•©â•šâ•â•â•šâ•â•â•©â•šâ•

@PadManagerOnLoad
  
  // The following vars CAN be set before @InitPadManager. 
  // If they are not defined here, they will be automatically 
  // defined with their defaults in @InitPadManager
  //
  // In the most basic use-case, just Call @InitPadManager 
  // in your OnLoad without setting any of them. 
  
  pmAnalyseTime = 200 
  // Length of double tap / tap-and-hold time window in msec
    
  pmManageTimer = YES
  // Set to NO if your script wants to controll the timer.
  // Your timer needs to run continously and with an update
  // interval faster than 50, otherwise the pad manager 
  // wont work. Also set pmTickInterval accordingly.

  pmTickInterval = timer_tick_resolution    // Update interval for the timer in msec.

  //  pmExcludePads = [7,15]
  pmExcludeCnt = 0

  // List of pad ids and length of list to be excluded from
  // analysis. For these pads OnSingleTap will be called 
  // immediately in 'OnPadDown' without the analysis delay.

  Call @InitPadManager
@End



// ========= Pad Manager V2 =========
// -ki  01.06.2019

@InitPadManager  

  // Apply defaults, if the vars are not yet defined

  if Unassigned pmAnalyseTime
    pmAnalyseTime = 200 
  endif
  if Unassigned pmManageTimer
    pmManageTimer = YES
  endif
  if Unassigned pmTickInterval
    pmTickInterval = 25
  endif
  if Unassigned pmExcludePads
    pmExcludePads = []
  endif
  if Unassigned pmExcludeCnt
    pmExcludeCnt = 0
  endif
  
  padsActiveCnt = 0  
  padMaxId = 15
  for pad = 0 to padMaxId
    Call @InitPadState
  endfor

  if pmExcludeCnt>0
    for pad = 0 to pmExcludeCnt-1
      padExclude[ pmExcludePads[pad] ] = YES
    endfor
  endif

  padAnalyseTicks = pmAnalyseTime / pmTickInterval

  if pmManageTimer
    SetTimerInterval pmTickInterval
  endif
  
  Log {PadManager started (},pmExcludeCnt,{ excluded pads, timer=}, pmTickInterval,{msec)}
@End

@InitPadState // Param: pad
  padActive[pad] = NO
  padTicks[pad] = 0
  padTaps[pad] = 0
  padHold[pad] = NO
  padExclude[pad] = NO
@End

@ReleasePadState // Param: pad
  Dec padsActiveCnt
  if pmManageTimer and padsActiveCnt = 0
//    StopTimer 
  endif
  Call @InitPadState
 @End

@OnPadDown 
  if padExclude[LastPad]
    pad = LastPad
    Call @OnPadSingleTap
  else
    if pmManageTimer and padsActiveCnt = 0
//      StartTimer 
    endif
    if not padActive[LastPad]
      Inc padsActiveCnt
      padActive[LastPad] = YES
    endif
    inc padTaps[LastPad]
  endif
@End 

@OnPadUp 
  if padTaps[LastPad] = 1 and padTicks[LastPad] < padAnalyseTicks
    padHold[LastPad] = YES
  endif

  if pad_edit_hold and LastPad = pad_edit_step
    pad_edit_got_note = NO
    pad_edit_hold = 0
    mode_pad_edit = 0
    Call @UpdateGUI
  endif
@End 

@OnTimer

  CurrentTimerTicks = (CurrentTimerTicks + 1) % 65534  // Wraps around every ~10 minutes
  
  if padsActiveCnt = 0
    Exit
  endif

  for pad = 0 to padMaxId
    if padActive[pad]
      Inc padTicks[pad]
      if padTicks[pad] > padAnalyseTicks
        if padTaps[pad] = 1
          if padHold[pad]
            Call @OnPadSingleTap
          else
            Call @OnPadHold
          endif
        else
            Call @OnPadDoubleTap
        endif

        Call @ReleasePadState
      endif
    endif
  endfor
@End 

// <<<<<<<<< end of Pad Manager script code >>>>>

@Description
  FLOW - 7-pattern, multi-channel, 16x8 step midi looper & sequencer for Mozaic by peblin.
  Featuring:

  - 16 steps with 8 subdivisions (parts) each
  - 6 voice polyphony per part
  - 7 patterns, with midi channel configurable per pattern
  - From 1/32 to 2 bar step length giving 1/2 to 16 bar patterns
  - Live & step recording
  - Midi CC recording & automation
  - Live recording stores note duration and timing for (almost) exact playback
  - Individual step / part editing, including voices, probability and duration
  - Note probability & duration can be set per part
  - Transpose mode
  - Patterns play solo or multi - easily toggle patterns ON/OFF for live performance
  - 3 quantization modes for live recording - None (as played), per part, per step

-- Basics --

FLOW's sequencer consists of 16 steps per pattern. Each step is divided into 8 parts - so each part is 1/8 of step length. For example, setting step length using the Step knob to 1 bar, makes each part of the step a 1/8th note.

To get started, just start the host and start playing - the sequencer records whatever you play into the appropriate part and plays is back just as you played it. Double-tap to erase steps & parts, and single-tap on a step to edit its parts.

The sequencer has 4 views;
- Steps; each pad is a step. When a step has parts with notes, the pad will show the number of voices allocated per part in the step. T
- Step edit; shows one row of steps and the other row the parts of the step being edited. Accessed by tapping or holding a pad in Steps view.
- Part edit; shows faders for all voices, gate and probability of a part. Accessed by tapping â¬†ï¸SHIFT when in step edit view.
- Control panel; top row of pads are sequencer controls, bottom row are ARM/ON/OFF toggles for the 7 patterns. Accessed by tapping SHIFT in the Steps view. Exit by tapping SHIFT again.

-- Recording --

Record into the sequencer using either live recording or step recording.

--- Live recording & Quantization ---

In this mode the sequencer records notes, velocities and (optionally) duration into the corresponding part. Live recording has three quantization modes - None, Part and Step. Set the quantisation mode by tapping the Quant button in Control Panel - it cycles between the modes.

- None; This aims to reproduce what you played as close to the original as possible. It keeps the timing of your playing by keeping track of the delay of the "note on" message to when the part started and will delay any playback with the same amount. The accuracy of the delay is 5 milliseconds for now.
- Part; This will quantize to nearest part (pushing note forward to next part if that is closer in time)
- Step; This will quantize to nearest step (pushing note forward to next step if its within 25% of the next step in time)

The sequencer has 6 voice polyphony per part, but only stores timing latency "per step", not "per voice" so any additional voices will play in sync with the first voice of the part.

--- Step recording ---

In this mode you select which step/part to edit, then play up to 6 notes for it. When editing a step, you're actually editing the first part of the step. 

The sequencer supports both "latched" and "hold pad" editing. 
- Latched; Simply tap the step you want to edit, then tap the part from all parts showing on the row above or below the chosen step. Finish recording/editing by tapping the step again, which is now labeled "âœ… Done".
- Hold pad; Hold the step you want to edit, then tap the part from all parts showing on the row above or below the chosen step. Finish by releasing the held pad. 

Latched is really helpful on iPhone, while "hold pad" might be quicker on the iPad.

-- Deleting parts or full steps --

To delete a part or all parts in a step, double-tap the step or part pad. 

-- Editing part contents --

When in step edit mode, if you select a part and then press SHIFT you will enter "part edit" mode. Part edit mode shows all 6 voices, note duration and probability.

Drag faders to adjust notes. If you drag a previously unused voice it'll be added to the part - so you can for example add a seventh to a triad chord after recording. Or, tap a bass rythm and then afterwards dial in the desired notes.

It's not super-easy to hit the right note when dragging the fader - suggestions for improved UX welcome.

-- Ratcheting --

In part edit mode, you can set ratcheting from 1-6. Ratcheting splits a note into 1 to 6 smaller notes, triggering over the same gate duration as the original note. So, with ratcheting set to 3 and gate at 100% you will get one note at start part, one at 1/3 of the step length and one at 2/3 of step length.

By experimenting with gate length it's very easy to make ratcheting "humanized" to create more varied fills. At the extreme, with gate length at 1600% and ratcheting set to 6 the note will trigger 6 times over the full sequencer cycle - perfect for weird ghost notes :)

-- Strumming --

You can set strum in milliseconds per pattern and/or per part (in both step and part edit modes). 

Voice playback will be strummed by delaying each voice with the strum amount multiplied with voice number (starting with 0). So, a strum value of 10ms will play voice0 at time 0, voice1 10ms later, voice2 20ms later and so on. 

By recording chords â€œin reverseâ€, ie highest note first, you can simulate both up and down strums as if it were a guitar. Strumming can also be used creatively with drums if several drum hits are on the same part - by setting the strum value theyâ€™ll be slightly separated, for a more humanized feel.

When sequencer has CC rec enabled, changes to strum will be saved live as the sequencer plays. 

-- Gate --

The knob "gate" sets the default gate length both for live and step recording. Gate length is measured as "percentage of step length". Thus, a gate of 200% with the sequencer set to "1/8" will give 1/4th notes. This also means that if you change step length for the sequencer, the gate length will scale accordingly.

Note duration knob defaults to "As played", meaning that the sequencer will use your playing (converted to a percentage of step length) as duration.

When in part edit mode, you can set part duration from 5% to 1600% of one step. At 1600%, the note will be held for the whole cycle when it will trigger again.

When sequencer has CC rec enabled, changes to gate will be saved live as the sequencer plays. 

-- Probability --

The "probability" knob sets the default probability for step-sequenced parts. You can also change the part probability using either the probability knob when step recording, or the probability fader in part edit view.

-- Velocity --

The "Velocity" knob sets the default velocity scale factor when recording. Velocity scale factor can be set by part, in step edit mode as well as part edit mode. If you change the velocity scale factor in part edit mode, the faders for each voice will show the resulting velocity as fader label making it somewhat easier to understand what's happening.

Velocity scale factor is set from 0% (mute) to 1000% and will be multiplied with the recorded velocity on playback.

When sequencer has CC rec enabled, changes to velocity scale factor will be saved live as the sequencer plays.

-- Pattern Midi Channel --

Each pattern can have its own midi channel for sending notes. Set the channel using the Midi CH knob and enjoy.

-- Play modes --

The sequencer can play each pattern SOLOed, or multiple patterns simultaneously. Toggle play mode with the "Play" button in the Control Panel.

--- Play: Solo ---

Only one pattern plays at a time and the playing pattern is also armed for recording. Change to the desired pattern in the Control Panel.

--- Play: Multi ---

Multiple patterns can play simultaneously, either on the same midi channel or using several depending on the midi channel setting for each pattern.

Toggle patterns ON/OFF in the Control Panel. Single-tapping on a pattern will toggle it ON/OFF and make it the armed pattern. Long-pressing on a pattern (tap and hold for approx 200ms+) will arm it, but not toggle the ON/OFF state. This way you can switch between editing different playing patterns without interrupting playback.

-- CC recording --

Flow can record incoming Midi CC commands per pattern. Even "empty" patterns (ie patterns with no notes) can record CCs so it's possible to record "CC phrases" such as different filter sweeps and then trigger them by toggling the recorded patterns on and off.

Tap the "CC rec" button in the Control Panel to toggle between OFF, ğŸ”´ WRITE and ğŸ…¾ï¸ OVERDUB.

In WRITE mode, incoming CC values will result in the current step being cleared (only once per loop), then stored in the corresponding sequencer part. For smooth knob movements this means that incoming values will "overwrite" previously stored ones (for that CC command), if values are coming a rate of at least once every step.

In OVERDUB mode, incoming CC values are stored "as is" per part in the sequencer. This can be used creatively to yield glitchy effects when filters jump around wildly - but will give wild results. ğŸ”¥

Flow has 4 "CC slots" and can store values for up to 4 different CCs per pattern. Slots are allocated on a first come basis - so if the sequencer receives sustain, mod wheel, cutoff and resonance CCs the slots for the active pattern are full and additional CC commands will be passed thru but not stored.

--- CC playback ---

For patterns with step length less than 1/4, playback of recorded CCs is quantized to the last recorded CC value of each part. 

For patterns with longer steps - from 1/4 to 2 bars - Flow will interpolate CC values to "smooth" the sampled CC values. The amount of extra/interpolated values varies depending on step length - from 1 extra for 1/4th notes to 15 extra for 2 bar notes. This is very useful for long, evolving pads. ğŸŒŠ


-- Transpose mode --

With transpose active, the sequencer will stop live recording and treat incoming midi notes as "pitch offset", with C3/midi note 48 as base pitch. So, playing G3 will transpose +7 semitones, while a B2 will transpose -1.

Transpose is applied to all outgoing notes - so in Play:Multi all playing patterns will be transposed. This behaviour might change in the future - suggestions welcome.

-- Copying patterns --

To copy a pattern, first make sure it's the armed pattern then press "Copy Pattern" in Control Panel. Then select the pattern to copy to. Everything except midi channel will be copied.

-- Clearing patterns --

"Clear armed" will clear the currently armed pattern, except for midi channel.
"Clear all" will clear all patterns. To prevent accidental disaster, both clear buttons requires you to long-press on the button.

- THANKS -

  Inspired by OP-Z and https://patchstorage.com/infinity
  Thanks to -ki for https://patchstorage.com/pad-manager-include and great contributions to the community

  And most of all thanks to Bram Bos for creating one of the most game-changing iOS music apps ever.

@End