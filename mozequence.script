// TODO
// Break up On...  events into smaller functions
// ^^ Separate UI
// Knob modes - "pads", "part edit", "buttons" (pattern settings)

// HMMM
// When transposing in "Multi" - should all patterns be transposed, just armed or configurable per pattern? Maybe transpose is a pattern setting rather than "arm vs transpose" thing?

// BUGS
// What happens to note delay if youve live recorded, then edits a step? need to clear note delay

@Onload
  ShowLayout 2

  CurrentTimerTicks = 0
  last_pulse_ticks = 0
  timer_tick_resolution = 5 // Milliseconds per tick

  Call @PadManagerOnLoad

  step_reso = 8  // Grid/parts per step
  part_reso = 1 // REMOVE? Pulses per part
  poly = 6       // Max polyphony per part
  sizeof_pattern = 16*8      // Size of storing all step parts in an array

  // CONSTANTS

  UIMODE_PADS = 1
  UIMODE_BUTTONS = 2
  UIMODE_VOICES = 3

  // Buttons
  BTN_MULTI_PATTERN = 0
  BTN_COPY_PATTERN = 1
  BTN_TRANSPOSE = 2
  BTN_RECORD = 3
  BTN_QUANTIZE = 4
  BTN_DUMP = 5
  BTN_CLEAR_ALL = 6
  BTN_CLEAR_ARMED = 7

  // Knobs
  KNOB_STEP = 0
  KNOB_NOTETIME = 1
  KNOB_PROBABILITY = 2
  KNOB_MIDICH = 3
  
  poly_offset = 0
  note_pos = 0
  note_part = 0
  seq_step = 0 // this is internal to IncrementSequencer, use step below as its updated in "sync" with note_part and step_part
  step = 0
  pad_edit_step = 0
  
  // tracks total ticks since start of transport. might wrap, but that wont kill anyone....i think
  total_tickCounter = 0  

// tracks if a note was received while holding a pad - in which case we can exit pad edit mode on pad release
  pad_edit_got_note = YES
  pad_edit_hold = 0  
  pad_edit_part_pad = 0
  pad_edit_note_part = 0 

  // states for UI
  
  resetStepOnNewStep = 0
  mode_pad_edit = 0
  mode_multi_pattern = NO
  mode_copy_pattern = NO
  if Unassigned record
    record = 1 // Rec enabled by default
    transpose = NO
    transposeNote = 0
    mode_copy_pattern = NO
  endif

  _res = step_reso * part_reso
  PPQN = [8*_res, 4*_res, 3*_res, 2*_res, _res, _res/2, _res/4, _res/8]

  // quantization
  
  QUANT_NONE = 0
  QUANT_PART = 1
  QUANT_STEP = 2
  
  quantize = QUANT_NONE

  
  // init knob defaults
  if Unassigned currentDivisor
    currentDivisor = 3
    count = 1
    tickCounter = 0
    gate = 0.75
    swing = 0
    noteTimeX_knob = -1
    probability_knob = 100
  endif

  SetKnobValue KNOB_STEP, 48          // 1/8
  SetKnobValue KNOB_NOTETIME, 0       // As played
  SetKnobValue KNOB_PROBABILITY, 127  // 100%
  SetKnobValue KNOB_MIDICH, 1         // Default Midi Channel 1

  call @ComputeTimes
  Call @InitSequencer

  if Unassigned last_active_pattern
    last_active_pattern = 1
  endif
  active_pattern = 0
  StartTimer 
  call @SetUIMode_Pads
@End

//  ╦╔╗╔╦╔╦╗   ┬   ╔╦╗╦╔╦╗╔═╗
//  ║║║║║ ║   ┌┼─   ║ ║║║║║╣ 
//  ╩╝╚╝╩ ╩   └┘    ╩ ╩╩ ╩╚═╝  

@IncrementSequencer
  Inc tickCounter
  Inc total_tickCounter

  if tickCounter >= countPerStep
    tickCounter = 0
    
    if resetStepOnNewStep = 1
      resetStepOnNewStep = 0
      seq_step = reset_step
    else
      Inc seq_step
      if seq_step > 15
        seq_step = 0
      endif
    endif
  endif
@End 

@ComputeTimes
  // tickTime == partTime ??
  tickTime = QuarterNote / PPQN[currentDivisor] * part_reso 
  stepTime = tickTime * step_reso
  countPerStep = step_reso * part_reso 
  noteTime = stepTime * gate
  SetMetroPPQN PPQN[currentDivisor]

@End

@OnHostStart
  seq_step = 0
  step = 0
  note_pos = 0
  note_part = 0  
  tickCounter = 0
  total_tickCounter = 0
  CurrentTimerTicks = 0  // "Optimistically" reset timer tick count on host start to reduce prob that it wraps during recording
@End 

@InitSequencer
  if Unassigned polycount
    Call @ClearSequencer
    pattern_midich = [0,0,0,0,0,0,0]
  endif
@End

//  ╔╦╗╔═╗╔╦╗╦═╗╔═╗   ┬   ╔╦╗╦╔╦╗╦
//  ║║║║╣  ║ ╠╦╝║ ║  ┌┼─  ║║║║ ║║║
//  ╩ ╩╚═╝ ╩ ╩╚═╚═╝  └┘   ╩ ╩╩═╩╝╩

@OnMetroPulse   
  last_pulse_ticks = CurrentTimerTicks

  // If we dont use RoundDown here, but Round we should be able to get better quantization,
  // but we need to handle the "last part" so it can wrap over to next step as well as wrap
  // around at the end of the 16 steps

  step = seq_step
  step_part = Round(((tickCounter+1) / countPerStep) * step_reso) - 1
  if step_part >= step_reso
    step_part = 0
    step = (step + 1) % 16
  endif
  note_part = (step * step_reso + step_part) // The note location in the wide grid
  
  for _active_pattern = 0 to 6 
    if (mode_multi_pattern = 0 and active_pattern=_active_pattern) or (mode_multi_pattern = 1 and playing_patterns[_active_pattern] = YES)
      _note_part = (_active_pattern * sizeof_pattern) + note_part

      if voice1[_note_part] >= 0 and ((Random 1, 100) <= note_probability[_note_part])
        _transposeNote = 0
        if transpose 
          _transposeNote = transposeNote
        endif

        _polycount = polycount[_note_part]
        _noteDelay = noteOnDelayTicks[_note_part] * timer_tick_resolution
        _noteTime = noteTime * (noteTimeX[_note_part] / 100) + _noteDelay
        _ch = pattern_midich[_active_pattern]

        if _polycount > 5
          SendMIDINoteOn _ch, voice6[_note_part] + _transposeNote, voice6_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice6[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 4
          SendMIDINoteOn _ch, voice5[_note_part] + _transposeNote, voice5_velocity[_note_part], _noteDelay     
          SendMIDINoteOff _ch, voice5[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 3
          SendMIDINoteOn _ch, voice4[_note_part] + _transposeNote, voice4_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice4[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 2
          SendMIDINoteOn _ch, voice3[_note_part] + _transposeNote, voice3_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice3[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 1
          SendMIDINoteOn _ch, voice2[_note_part] + _transposeNote, voice2_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice2[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 0
          SendMIDINoteOn _ch, voice1[_note_part] + _transposeNote, voice1_velocity[_note_part], _noteDelay      
          SendMIDINoteOff _ch, voice1[_note_part] + _transposeNote, 0, _noteTime
        endif
      endif
    endif
  endfor

  FlashPad step
  Call @IncrementSequencer
@End

@OnMidiNoteOn
  _note_on_ticks = CurrentTimerTicks
  _el_ticks = _note_on_ticks - last_pulse_ticks
  _el_pct = (Round _el_ticks / (tickTime / timer_tick_resolution) * 100)
  log {Part elapsed ticks: }, _el_ticks, { elapsed pct: }, _el_pct, {%}
  nn = MIDINote
  v = MIDIVelocity

  if transpose AND mode_pad_edit <> 1 
    transposeNote = MIDINote - 48
    LabelPads { Transpose: }, transposeNote
    Exit
  endif
  
  SendMidiThruOnCh pattern_midich[active_pattern]

  if not ((record and HostRunning) or mode_pad_edit = 1) or (uiMode = UIMODE_BUTTONS)
    Exit
  endif
  
  if mode_pad_edit = 1
    pad_edit_got_note = YES
    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 

    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part
 
    if not Unassigned pad_edit_part_pad  // Latch and label when editing parts of step
      LabelPad pad_edit_part_pad, (NoteName nn, YES)
      LatchPad pad_edit_part_pad, 1
    endif
  else
    _step = step
    if quantize = QUANT_STEP
      if step_part > 5  // if we are within 25% of next step then quantize to that 
        _step = (_step  + 1) % 16
      endif
      _note_part = (active_pattern * sizeof_pattern) + _step * step_reso
    else
      if quantize = QUANT_PART and _el_pct > 50
        // if note is closer to next part, then quantize to that one
        note_part = (note_part + (Round _el_pct/100)) % (16 * step_reso)
      endif
      _note_part = (active_pattern * sizeof_pattern) + note_part
    endif
  endif
  
  _poly_offset = polycount[_note_part]
 
  if _poly_offset = 0
    voice1[_note_part] = nn
    voice1_velocity[_note_part] = v
  elseif _poly_offset = 1
    voice2[_note_part] = nn
    voice2_velocity[_note_part] = v
  elseif _poly_offset = 2
    voice3[_note_part] = nn
    voice3_velocity[_note_part] = v
  elseif _poly_offset = 3
    voice4[_note_part] = nn
    voice4_velocity[_note_part] = v
  elseif _poly_offset = 4
    voice5[_note_part] = nn
    voice5_velocity[_note_part] = v
  elseif _poly_offset = 5
    voice6[_note_part] = nn
    voice6_velocity[_note_part] = v
  endif

  if _poly_offset < 6
    Inc _poly_offset
  endif

  polycount[_note_part] = _poly_offset
  noteOnTicks[_note_part] = CurrentTimerTicks //total_tickCounter

  if quantize = QUANT_NONE and HostRunning  // we can only have delay if metronome is running
    noteOnDelayTicks[_note_part] = _note_on_ticks - last_pulse_ticks
  else
    noteOnDelayTicks[_note_part] = 0
  endif

  // Store part so that MidiNoteOff can reference all data of the note being played
  SetNoteState 0, nn, _note_part    

  if not mode_pad_edit
    if not UIMODE_BUTTONS
      LabelPad _step, _poly_offset, {:}, (NoteName nn, YES) 
    endif
    LatchPad _step, 1
  endif
  last_note = nn      // for single-tap edit
  last_velocity = nn  
@End 

@OnMidiNoteOff

// REFACTOR: Need to send explicit midi command with velocity set to noteTimeX_knob (or "As Played")
  SendMidiThruOnCh pattern_midich[active_pattern]

  if not ((record and HostRunning) or mode_pad_edit = 1) or transpose or (uiMode = UIMODE_BUTTONS)
    Exit
  endif

  nn = MIDINote
  v = MIDIVelocity

  _note_part = GetNoteState 0, nn

  // Dont store anything unless state was set to <> -1. 
  if _note_part = -1
    Exit
  endif
  // Reset state to prevent OnMidiOff action when notes are played with recording off 
  SetNoteState 0, nn, -1

  _note_step = Div (_note_part - active_pattern * sizeof_pattern), step_reso
  _note_pad = _note_part - ((active_pattern * sizeof_pattern) + _note_step * step_reso)
  if _note_step < 8
    _note_pad = _note_pad + 8
  endif

  _on_ticks = noteOnTicks[_note_part]
  _off_ticks = CurrentTimerTicks // total_tickCounter
  _elapsed_ticks = _off_ticks - _on_ticks

  // Special case:
  // if transport is stopped or we have long steps (like 2 bars) we might get 0 ticks so we default to 1 step for these cases.
  // we might also get negative elapse ticks if timer wrapped around the 16-bit int limit, so we just say 100% elapsed as a safeguard
  if _elapsed_ticks <= 0
    _elapsed_pct = 100
  else
    _elapsed_pct = _elapsed_ticks * timer_tick_resolution / noteTime * 100
  endif

  if noteTimeX_knob < 0
    noteTimeX[_note_part] = _elapsed_pct  // elapsed as percentage of notetime
  else
    noteTimeX[_note_part] = noteTimeX_knob  // Set fixed note time from knob
  endif

  if not mode_pad_edit 
    LabelPad _note_step, (NoteName nn, YES), {:}, Round(noteTimeX[_note_part]) 
  else
    LabelPad _note_pad, {🔴}, (NoteName nn, YES), {:}, Round(noteTimeX[_note_part]) 
  endif
@End

@OnMidiCC
  Log {CC: }, MIDIByte2, { - }, MidiByte3
@End


//  ╔═╗╦ ╦╦╔═╗╔╦╗
//  ╚═╗╠═╣║╠╣  ║ 
//  ╚═╝╩ ╩╩╚   ╩ 

@OnShiftDown
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    Call @SetUIMode_Voices 
  elseif uiMode = UIMODE_VOICES
    Call @SetUIMode_Pads
  elseif uiMode = UIMODE_PADS
    uiMode = UIMODE_BUTTONS // "button" mode
    Call @UpdateGUI
  elseif uiMode = UIMODE_BUTTONS
    uiMode = UIMODE_PADS // pad mode
    mode_copy_pattern = NO
    Call @UpdateGUI
  endif
@End 

@OnShiftUp
@End 

//  ╔═╗╔═╗╔╦╗╔═╗   ┬   ╔╦╗╔═╗╔═╗╔═╗
//  ╠═╝╠═╣ ║║╚═╗  ┌┼─   ║ ╠═╣╠═╝╚═╗
//  ╩  ╩ ╩═╩╝╚═╝  └┘    ╩ ╩ ╩╩  ╚═╝

@OnPadHold
  pad_edit_step = pad
  mode_pad_edit = 1
  pad_edit_part = 0 
  if pad < 8
    pad_edit_part_pad = 8  // used for latching pad in UI. "hold to edit" always edits first part of step
  else
    pad_edit_part_pad = 0
  endif
  pad_edit_got_note = NO
  pad_edit_hold = 1
  LabelPad pad, {Editing...} 
  Call @UpdateGUI
@End

@OnPadSingleTap_InPadEdit
  if (pad_edit_step > 7 AND pad > 7) OR (pad_edit_step <= 7 AND pad <= 7)  // pad and tapped pad are on the same row  
    mode_pad_edit = 0
    Call @UpdateGUI
  else  
    _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
    if voice1[_note_part] > -1
      LabelPad pad_edit_part_pad, {🔵}, (NoteName voice1[_note_part], YES), {:}, (Round noteTimeX[_note_part])
    else
      LabelPad pad_edit_part_pad, {⚪️}
    endif

    pad_edit_part = pad % step_reso // Only step_reso parts
    pad_edit_part_pad = pad // for UI usage like latching pad etc during edit
    pad_edit_got_note = NO

    _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)

    pad_edit_note_part = _note_part // used for Voices mode

    if voice1[_note_part] > -1
      LabelPad pad_edit_part_pad, {🔴}, (NoteName voice1[_note_part], YES), {:}, noteTimeX[_note_part]
    else
      LabelPad pad_edit_part_pad, {🔴}
    endif
    LabelPads {⚠️ Editing }, pad_edit_step, {:} , pad_edit_part, {  ℹ️ SHIFT for voices }
  endif
@End

@EnterPadEditMode
  mode_pad_edit = 1
  pad_edit_step = pad
  pad_edit_part = 0
  pad_edit_got_note = NO
  if pad < 8
    pad_edit_part_pad = 8 // for UI usage like latching pad etc during edit
  else
    pad_edit_part_pad = 0
  endif
  Call @UpdateGUI
@End

@OnPadSingleTap_InCopyPattern
  mode_copy_pattern = NO
  if pad < 8
    exit
  endif

  CopyPattern_pattern = pad - 8
  CopyPattern_src_pattern_pos = active_pattern * sizeof_pattern
  CopyPattern_dest_pattern_pos = CopyPattern_pattern * sizeof_pattern

  Call @CopyPattern
  LabelPad CopyPattern_pattern + 8, {P}, active_pattern+1, {CPY, ARM}
  LatchPad active_pattern+8, 0
  LatchPad CopyPattern_pattern + 8, 1
  active_pattern = CopyPattern_pattern  // Auto-arm after copy
@End

@OnPadSingleTap_Buttons  
  if pad = BTN_TRANSPOSE
    transpose = not transpose
    LabelPad BTN_TRANSPOSE, { Transpose: }, transpose
    LabelPads { Transpose: }, transpose

  elseif pad = BTN_CLEAR_ALL
    Call @ClearSequencer    
    
  elseif pad = BTN_RECORD
    record = not record
    Call @UpdateGUI

  elseif pad = BTN_QUANTIZE
    quantize = (quantize + 1) % 3
    Call @UpdateGUI

  elseif pad = BTN_DUMP
    Call @DumpNotes
    
  elseif pad = BTN_COPY_PATTERN
    LabelPads { Select pattern to copy active pattern to }
    mode_copy_pattern = YES

  elseif pad = BTN_MULTI_PATTERN
      mode_multi_pattern = not mode_multi_pattern
      if mode_multi_pattern
        LabelPads { Select patterns to play simultaneously }
        LabelPad BTN_MULTI_PATTERN, {Multi: ON}
      else
        LabelPads { Single pattern arm mode }
        LabelPad BTN_MULTI_PATTERN, {Multi: OFF}
      endif
      Call @UpdateGUI

  elseif pad = BTN_CLEAR_ARMED
    Call @ClearActivePattern

  elseif pad >= 8 and pad <= 14     // Pattern ARM. Future proof with upper bound ;)
    if mode_multi_pattern
      _pattern = pad - 8
      _current_state = playing_patterns[_pattern]
      if _pattern = active_pattern and _current_state = NO  // OFF, ARM
        _new_state = 1
        active_pattern = _pattern
      elseif _pattern = active_pattern and _current_state = YES // ON, ARM
        _new_state = 0
        active_pattern = _pattern
      elseif _pattern <> active_pattern and _current_state = NO // OFF, UNARM
        _new_state = 1
        active_pattern = _pattern          
      elseif _pattern <> active_pattern and _current_state = YES // ON, UNARM
        active_pattern = _pattern
      endif

      playing_patterns[_pattern] = _new_state
      LatchPad pad, playing_patterns[_pattern]
    else
      last_active_pattern = active_pattern
      active_pattern = pad-8
    endif

    Call @UpdateGUI

    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
   endif
@End

// ROUTER: Single Taps 
@OnPadSingleTap // param: pad
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    Call @OnPadSingleTap_InPadEdit

//  elseif uiMode = UIMODE_PADS and mode_pad_reset_step = 1 // something like this for a "performance mode"
    // reset_step = pad
    // resetStepOnNewStep = 1

  elseif uiMode = UIMODE_PADS  // pads
    Call @EnterPadEditMode

  elseif uiMode = UIMODE_BUTTONS and mode_copy_pattern = YES
    Call @OnPadSingleTap_InCopyPattern

  elseif uiMode = UIMODE_BUTTONS
    Call @OnPadSingleTap_Buttons

  endif
@End

@OnPadDoubleTap
  if uiMode = UIMODE_BUTTONS
    Exit
  endif
  if mode_pad_edit = 1 
    del_step_part = pad % 8
    del_step = pad_edit_step
    del_step_pos = del_step * step_reso + del_step_part // The note location in the wide grid

    _del_note_part = (active_pattern * sizeof_pattern) + del_step_pos

    polycount[_del_note_part] = 0
    voice1[_del_note_part] = -1
    voice2[_del_note_part] = -1
    voice3[_del_note_part] = -1
    voice4[_del_note_part] = -1
    voice5[_del_note_part] = -1
    voice6[_del_note_part] = -1
    velocity[_del_note_part] = 100
    noteTimeX[_del_note_part] = 100

    LatchPad pad, 0
    LabelPad pad, { }
  else
    del_step = pad
    del_note_part = del_step * step_reso // The note location in the wide grid

    for po = 0 to step_reso
      _del_note_part = (active_pattern * sizeof_pattern) + (del_note_part + po) 
      polycount[_del_note_part] = 0
      voice1[_del_note_part] = -1
      voice2[_del_note_part] = -1
      voice3[_del_note_part] = -1
      voice4[_del_note_part] = -1
      voice5[_del_note_part] = -1
      voice6[_del_note_part] = -1
      velocity[_del_note_part] = 100
      noteTimeX[_del_note_part] = 100
    endfor
  
    LatchPad del_step, 0
    LabelPad del_step, { }
  endif
@End


//  ╔═╗╔═╗╔═╗╦ ╦  ╔═╗╔═╗╔╦╗╔╦╗╔═╗╦═╗╔╗╔
//  ║  ║ ║╠═╝╚╦╝  ╠═╝╠═╣ ║  ║ ║╣ ╠╦╝║║║
//  ╚═╝╚═╝╩   ╩   ╩  ╩ ╩ ╩  ╩ ╚═╝╩╚═╝╚╝

@CopyPattern
  _pattern = CopyPattern_pattern
  _src_pattern_pos = CopyPattern_src_pattern_pos
  _dest_pattern_pos = CopyPattern_dest_pattern_pos

  CopyArray voice1[_src_pattern_pos], voice1[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2[_src_pattern_pos], voice2[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3[_src_pattern_pos], voice3[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4[_src_pattern_pos], voice4[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5[_src_pattern_pos], voice5[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6[_src_pattern_pos], voice6[_dest_pattern_pos], sizeof_pattern
  CopyArray voice1_velocity[_src_pattern_pos], voice1_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2_velocity[_src_pattern_pos], voice2_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3_velocity[_src_pattern_pos], voice3_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4_velocity[_src_pattern_pos], voice4_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5_velocity[_src_pattern_pos], voice5_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6_velocity[_src_pattern_pos], voice6_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray polycount[_src_pattern_pos], polycount[_dest_pattern_pos], sizeof_pattern
  CopyArray noteTimeX[_src_pattern_pos], noteTimeX[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnTicks[_src_pattern_pos], noteOnTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnDelayTicks[_src_pattern_pos], noteOnDelayTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray note_probability[_src_pattern_pos], note_probability[_dest_pattern_pos], sizeof_pattern
@End

//  ┌─┐┬  ┌─┐┌─┐┬─┐  ┌─┐┌─┐┌┬┐┌┬┐┌─┐┬─┐┌┐┌┌─┐
//  │  │  ├┤ ├─┤├┬┘  ├─┘├─┤ │  │ ├┤ ├┬┘│││└─┐
//  └─┘┴─┘└─┘┴ ┴┴└─  ┴  ┴ ┴ ┴  ┴ └─┘┴└─┘└┘└─┘

@ClearSequencer
  FillArray polycount, 0
  FillArray voice1, -1
  FillArray voice1_velocity, 100
  FillArray voice2, -1
  FillArray voice2_velocity, 100
  FillArray voice3, -1
  FillArray voice3_velocity, 100
  FillArray voice4, -1
  FillArray voice4_velocity, 100
  FillArray voice5, -1
  FillArray voice5_velocity, 100
  FillArray voice6, -1
  FillArray voice6_velocity, 100
  FillArray noteTimeX, 100
  FillArray noteOnTicks, 0
  FillArray noteOnDelayTicks, 0
  FillArray note_probability, 100
  playing_patterns = [ YES, NO, NO, NO, NO, NO, NO ]
@End

@ClearActivePattern
  _pattern_start = active_pattern * sizeof_pattern
  FillArray polycount[_pattern_start], 0, sizeof_pattern
  FillArray voice1[_pattern_start], -1, sizeof_pattern
  FillArray voice1_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice2[_pattern_start], -1, sizeof_pattern 
  FillArray voice2_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice3[_pattern_start], -1, sizeof_pattern 
  FillArray voice3_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice4[_pattern_start], -1, sizeof_pattern 
  FillArray voice4_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice5[_pattern_start], -1, sizeof_pattern 
  FillArray voice5_velocity[_pattern_start], 100, sizeof_pattern 
  FillArray voice6[_pattern_start], -1, sizeof_pattern
  FillArray voice6_velocity[_pattern_start], 100, sizeof_pattern
  FillArray noteTimeX[_pattern_start], 100, sizeof_pattern
  FillArray noteOnTicks[_pattern_start], 0, sizeof_pattern
  FillArray noteOnDelayTicks[_pattern_start], 0, sizeof_pattern
  FillArray note_probability[_pattern_start], 100 , sizeof_pattern
@End

@DumpNotes
  for _pattern = 0 to 7
    for _step = 0 to 15
       for _part = 0 to step_reso - 1
          _notepart = _step * step_reso + _part
          _notepos = (_pattern * sizeof_pattern) + _notepart
          if voice1[_notepos] >= 0
              Log { Pattern: }, _pattern+1, { Step: }, _step, { Part: }, _part, { Voice1: }, (NoteName voice1[_notepos], YES)
          endif
      endfor  
    endfor  
  endfor
@End

//  ╦╔═╔╗╔╔═╗╔╗ ╔═╗
//  ╠╩╗║║║║ ║╠╩╗╚═╗
//  ╩ ╩╝╚╝╚═╝╚═╝╚═╝

@OnKnobChange
  if uiMode = UIMODE_PADS or uiMode = UIMODE_BUTTONS
    call @OnKnobChange_Pads
  elseif uiMode = UIMODE_VOICES
    call @OnKnobChange_Voices
  endif
@End

@OnKnobChange_Voices
  _part = pad_edit_note_part
  _knob = LastKnob
  _note = GetKnobValue _knob

  _voice = _knob + 1
 
  if polycount[_part] < _voice and _voice <= 6
    polycount[_part] = _voice
  endif
  
  if _knob = 0
    voice1[_part] = _note
    LabelKnob 0, (NoteName _note, YES)
  elseif _knob = 1
    voice2[_part] = _note
    LabelKnob 1, (NoteName _note, YES)
  elseif _knob = 2
    voice3[_part] = _note
    LabelKnob 2, (NoteName _note, YES)
  elseif _knob = 3
    voice4[_part] = _note
    LabelKnob 3, (NoteName _note, YES)
  elseif _knob = 4
    voice5[_part] = _note
    LabelKnob 4, (NoteName _note, YES)
  elseif _knob = 5
    voice6[_part] = _note
    LabelKnob 5, (NoteName _note, YES)
  elseif _knob = 6  // notetime
    _ntx = Round((GetKnobValue 6) / 127 * 800)
    noteTimeX[_part] = _ntx
    LabelKnob 6, _ntx
  elseif _knob = 7  // probability
    _p = Round((GetKnobValue 7) / 127 * 100)
    note_probability[_part] = _p
    LabelKnob 7, _p
  endif
@End

@OnKnobChange_Pads

// REFACTOR - doing unnecessary work 

  if currentDivisor = 0
    LabelKnob 0, {1/32}
  elseif currentDivisor = 1
    LabelKnob 0, {1/16}
  elseif currentDivisor = 2
    LabelKnob 0, {1/8t}
  elseif currentDivisor = 3
    LabelKnob 0, {1/8}
  elseif currentDivisor = 4
    LabelKnob 0, {1/4}
  elseif currentDivisor = 5
    LabelKnob 0, {1/2}
  elseif currentDivisor = 6
    LabelKnob 0, {bar}
  elseif currentDivisor = 7
    LabelKnob 0, {2 bar}
  endif

  if LastKnob = KNOB_STEP
    currentDivisor = Round ((GetKnobValue 0) / 16)
    if currentDivisor = 0
      LabelKnobs {1/32}
    elseif currentDivisor = 1
      LabelKnobs {1/16}
    elseif currentDivisor = 2
      LabelKnobs {1/8t}
    elseif currentDivisor = 3
      LabelKnobs {1/8}
    elseif currentDivisor = 4
      LabelKnobs {1/4}
    elseif currentDivisor = 5
      LabelKnobs {1/2}
    elseif currentDivisor = 6
      LabelKnobs {bar}
    elseif currentDivisor = 7
      LabelKnobs {2 bar}
    endif
    call @ComputeTimes

  elseif LastKnob = KNOB_NOTETIME
    noteTimeX_knob = Round((GetKnobValue 1) / 127 * 800)  
    if noteTimeX_knob < 6.25
      noteTimeX_knob = -1 // "As Played"
      LabelKnobs {As Played}
    else
      LabelKnobs noteTimeX_knob*1.000, {%}
    endif
  
    if mode_pad_edit = 1 and noteTimeX_knob > 0  // REFACTOR: use pad_edit_note_part below (and in other similar places)
      noteTimeX[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = noteTimeX_knob
    endif

  elseif LastKnob = KNOB_PROBABILITY
    _probability = (GetKnobValue 2) / 127 * 100
    if mode_pad_edit = 1
      note_probability[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _probability
    else
      note_probability[(active_pattern * sizeof_pattern) + note_part] = _probability
    endif

    probability_knob = _probability
    LabelKnobs (Round probability_knob), {%}

  elseif LastKnob = KNOB_MIDICH
    _midich = RoundDown((GetKnobValue KNOB_MIDICH) / 128 * 16)
    pattern_midich[active_pattern] = _midich
    LabelKnobs _midich + 1
  endif

//  call @UpdateGUI
@End

//   ██████╗ ██╗   ██╗██╗
//  ██╔════╝ ██║   ██║██║
//  ██║  ███╗██║   ██║██║
//  ██║   ██║██║   ██║██║
//  ╚██████╔╝╚██████╔╝██║
//   ╚═════╝  ╚═════╝ ╚═╝

@SetUIMode_Pads
  uiMode = UIMODE_PADS
  ShowLayout 2
  Call @UpdateGUI
  LabelKnobs {P}, active_pattern+1, { settings }
@End

@SetUIMode_Voices
  uiMode = UIMODE_VOICES
  Call @UpdateGUI
@End

@UpdateGUI
  if uiMode = UIMODE_PADS AND mode_pad_edit = 1
    call @GUI_PadEditMode

  elseif uiMode = UIMODE_PADS
    call @GUI_PadMode

  elseif uiMode = UIMODE_BUTTONS
    call @GUI_ButtonMode 
    call @GUI_LabelKnobs
 
  elseif uiMode = UIMODE_VOICES
     call @GUI_VoicesMode
  endif
@End

@GUI_VoicesMode
  ShowLayout 3
  _edit_note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso) + pad_edit_part

  _n = voice1[_edit_note_part]
  _n1 = _n
  LabelKnob 0, (NoteName _n, YES)
  SetKnobValue 0, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice2[_edit_note_part]
  LabelKnob 1, (NoteName _n, YES)
  SetKnobValue 1, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice3[_edit_note_part]
  LabelKnob 2, (NoteName _n, YES)
  SetKnobValue 2, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice4[_edit_note_part]
  LabelKnob 3, (NoteName _n, YES)
  SetKnobValue 3, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice5[_edit_note_part]
  LabelKnob 4, (NoteName _n, YES)
  SetKnobValue 4, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice6[_edit_note_part]
  LabelKnob 5, (NoteName _n, YES)
  SetKnobValue 5, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  LabelKnob 6, {Note time}
  SetKnobValue 6, (TranslateScale noteTimeX[_edit_note_part], 0, 800, 0, 127)

  LabelKnob 7, {Probability}
  SetKnobValue 6, (TranslateScale note_probability[_edit_note_part], 0, 100, 0, 127)
@End

@GUI_PadMode
  Call @GUI_LabelKnobs
  for _step = 0 to 15
    _voice_cnt = 0
    _part_cnt = 0
    _po = (active_pattern * sizeof_pattern) + (_step * step_reso)

    _pc = polycount[_po+0] + polycount[_po+1] + polycount[_po+2] + polycount[_po+3] + polycount[_po+4] + polycount[_po+5] + polycount[_po+6] + polycount[_po+7]

    if _pc > 0
      LatchPad _step, 1
      // Row below triggers parser bug in Mozaic if there are spaces after commas
      LabelPad _step,polycount[_po+0],polycount[_po+1],polycount[_po+2],polycount[_po+3],polycount[_po+4],polycount[_po+5],polycount[_po+6],polycount[_po+7]
    else
      LatchPad _step, 0
      LabelPad _step, { }
    endif
  endfor
  
 if transpose and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ ⚪️ }, { transpose: }, transpose, { Play: Multi}, { quant: }, quantize
  elseif transpose
    LabelPads  {P}, active_pattern+1,{ ⚪️ SOLO}, { transpose: }, transpose, { quant: }, quantize
  elseif record and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ 🔴 }, { Play: Multi}, { quant: }, quantize
  elseif record
    LabelPads  {P}, active_pattern+1,{ 🔴 SOLO}, { quant: }, quantize
  endif
  
@End

@GUI_PadEditMode
  if pad_edit_step <= 7
    _pad_offset = 8
  else
    _pad_offset = 0
  endif

  for the_part = 0 to step_reso-1
    _note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso + the_part)
    _cnt = polycount[_note_part]
    _pad = the_part + _pad_offset
    if _cnt > 0
      LabelPad _pad, {🔵}, _cnt, {:}, (NoteName voice1[_note_part], YES), {:}, (Round noteTimeX[_note_part])
      LatchPad _pad, 1
    else
      LatchPad _pad, 0
      LabelPad _pad, {⚪️}
    endif
  endfor

  _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
  if voice1[_note_part] > -1
    LabelPad pad_edit_part_pad, {🔴}, (NoteName voice1[_note_part], YES), {:}, polycount[_note_part]
  else
    LabelPad pad_edit_part_pad, {🔴}
  endif
  LabelPad pad_edit_step, {✅ Done}
  LabelPads {⚠️ Editing }, pad_edit_step, {:} , pad_edit_part, {  ℹ️ SHIFT for voices }

  Call @GUI_LabelKnobs
@End

@GUI_ButtonMode
  
  for po = 0 to 15
    LabelPad po, { }
    LatchPad po, 0
  endfor
  
  if transpose
    LabelPad BTN_TRANSPOSE, {⚠️transp ON}
  else
    LabelPad BTN_TRANSPOSE, {transp OFF}
  endif

  LabelPad BTN_CLEAR_ALL, {Clear all}

  if record
    LabelPad BTN_RECORD, {live rec 🔴}
  else
    LabelPad BTN_RECORD, {live rec ⚪}
  endif
  LabelPad BTN_DUMP, {Dump}
  LabelPad BTN_COPY_PATTERN, {Copy pattern}
  LabelPad BTN_CLEAR_ARMED, {Clear armed}

  if quantize = QUANT_NONE
    LabelPad BTN_QUANTIZE, {Quant: None} 
  elseif quantize = QUANT_PART
    LabelPad BTN_QUANTIZE, {Quant: Part} 
  else // QUANT_STEP
    LabelPad BTN_QUANTIZE, {Quant: Step} 
  endif

  if mode_multi_pattern  
    LabelPad BTN_MULTI_PATTERN, {Play: Multi}
    for _pattern = 0 to 6
      if playing_patterns[_pattern] = 1 and active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, {🔴 ON}
      elseif playing_patterns[_pattern] = 1 and active_pattern <> _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { ON}
      elseif playing_patterns[_pattern] = 0 and active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, {🔴 OFF}
      else
        LabelPad _pattern + 8, {P}, _pattern+1, { OFF}
      endif
    endfor
  else
    LabelPad BTN_MULTI_PATTERN, {Play: Solo}
    for _pattern = 0 to 6
      if active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { SOLO}
      else
        LabelPad _pattern + 8, {P}, _pattern+1
      endif
    endfor
  endif

  LatchPad 8+active_pattern, 1
  LabelPads {Tap pattern to arm. ℹ️ SHIFT exits.}
@End

@GUI_LabelKnobs
  LabelKnobs {P}, active_pattern+1, { settings}

  LabelKnob KNOB_STEP, {Step}
  LabelKnob KNOB_NOTETIME, {Note time}
  LabelKnob KNOB_PROBABILITY, {Probability}
  LabelKnob KNOB_MIDICH, {Midi CH}
  SetKnobValue KNOB_MIDICH, pattern_midich[active_pattern]*8+4 
@End

//  ╔═╗╔═╗╔╦╗  ╔╦╗╔═╗╔╗╔╔═╗╔═╗╔═╗╦═╗
//  ╠═╝╠═╣ ║║  ║║║╠═╣║║║╠═╣║ ╦║╣ ╠╦╝
//  ╩  ╩ ╩═╩╝  ╩ ╩╩ ╩╝╚╝╩ ╩╚═╝╚═╝╩╚═

@PadManagerOnLoad
  
  // The following vars CAN be set before @InitPadManager. 
  // If they are not defined here, they will be automatically 
  // defined with their defaults in @InitPadManager
  //
  // In the most basic use-case, just Call @InitPadManager 
  // in your OnLoad without setting any of them. 
  
  pmAnalyseTime = 200 
  // Length of double tap / tap-and-hold time window in msec
    
  pmManageTimer = YES
  // Set to NO if your script wants to controll the timer.
  // Your timer needs to run continously and with an update
  // interval faster than 50, otherwise the pad manager 
  // wont work. Also set pmTickInterval accordingly.

  pmTickInterval = timer_tick_resolution    // Update interval for the timer in msec.

  //  pmExcludePads = [7,15]
  pmExcludeCnt = 0

  // List of pad ids and length of list to be excluded from
  // analysis. For these pads OnSingleTap will be called 
  // immediately in 'OnPadDown' without the analysis delay.

  Call @InitPadManager
@End



// ========= Pad Manager V2 =========
// -ki  01.06.2019

@InitPadManager  

  // Apply defaults, if the vars are not yet defined

  if Unassigned pmAnalyseTime
    pmAnalyseTime = 200 
  endif
  if Unassigned pmManageTimer
    pmManageTimer = YES
  endif
  if Unassigned pmTickInterval
    pmTickInterval = 25
  endif
  if Unassigned pmExcludePads
    pmExcludePads = []
  endif
  if Unassigned pmExcludeCnt
    pmExcludeCnt = 0
  endif
  
  padsActiveCnt = 0  
  padMaxId = 15
  for pad = 0 to padMaxId
    Call @InitPadState
  endfor

  if pmExcludeCnt>0
    for pad = 0 to pmExcludeCnt-1
      padExclude[ pmExcludePads[pad] ] = YES
    endfor
  endif

  padAnalyseTicks = pmAnalyseTime / pmTickInterval

  if pmManageTimer
    SetTimerInterval pmTickInterval
  endif
  
  Log {PadManager started (},pmExcludeCnt,{ excluded pads, timer=}, pmTickInterval,{msec)}
@End

@InitPadState // Param: pad
  padActive[pad] = NO
  padTicks[pad] = 0
  padTaps[pad] = 0
  padHold[pad] = NO
  padExclude[pad] = NO
@End

@ReleasePadState // Param: pad
  Dec padsActiveCnt
  if pmManageTimer and padsActiveCnt = 0
//    StopTimer 
  endif
  Call @InitPadState
 @End

@OnPadDown 
  if padExclude[LastPad]
    pad = LastPad
    Call @OnPadSingleTap
  else
    if pmManageTimer and padsActiveCnt = 0
//      StartTimer 
    endif
    if not padActive[LastPad]
      Inc padsActiveCnt
      padActive[LastPad] = YES
    endif
    inc padTaps[LastPad]
  endif
@End 

@OnPadUp 
  if padTaps[LastPad] = 1 and padTicks[LastPad] < padAnalyseTicks
    padHold[LastPad] = YES
  endif

  if pad_edit_hold and LastPad = pad_edit_step
    pad_edit_got_note = NO
    pad_edit_hold = 0
    mode_pad_edit = 0
    Call @UpdateGUI
  endif
@End 

@OnTimer 
  CurrentTimerTicks = (CurrentTimerTicks + 1) % 65534  // Wraps around every ~10 minutes
  for pad = 0 to padMaxId
    if padActive[pad]
      Inc padTicks[pad]
      if padTicks[pad] > padAnalyseTicks
        if padTaps[pad] = 1
          if padHold[pad]
            Call @OnPadSingleTap
          else
            Call @OnPadHold
          endif
        else
            Call @OnPadDoubleTap
        endif

        Call @ReleasePadState
      endif
    endif
  endfor
@End 

// <<<<<<<<< end of Pad Manager script code >>>>>

@Description
  Multi-pattern two-level midi sequencer/looper for Mozaic by peblin.
  Featuring:

  - 16 steps with 8 subdivisions (parts) each
  - 7 patterns with pattern copy
  - 6 voice polyphony per part
  - From 1/32 to 2 bar step length
  - Live recording, including note durations
  - Individual step / part editing
  - Note probability
  - Note duration can be set by knob per part
  - Transpose mode
  - Manual triggering of steps using single tap
    
  Inspired by OP-Z and https://patchstorage.com/infinity
  Thanks to -ki for https://patchstorage.com/pad-manager-include

@End