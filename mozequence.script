@Onload
  ShowLayout 2
  Call @PadManagerOnLoad

  step_reso = 8  // Grid/parts per step
  poly = 6       // Max polyphony per part
  sizeof_pattern = 16*8   // Size of storing all step parts in an array

  // CONSTANTS

  UIMODE_PADS = 1
  UIMODE_BUTTONS = 2

  // Buttons
  BTN_MULTI_PATTERN = 0
  BTN_COPY_PATTERN = 1
  BTN_TRANSPOSE = 2
  BTN_RECORD = 3
  BTN_DUMP = 5
  BTN_CLEAR_ALL = 6
  BTN_CLEAR_ARMED = 7

  poly_offset = 0
  note_pos = 0
  note_part = 0
  step = 0
  pad_edit_step = 0
  total_tickCounter = 0  // tracks total ticks since start of transport. might wrap, but that wont kill anyone....i think

  pad_edit_got_note = 1  // to know if a note was received while holding a pad - in which case we can exit pad edit mode on pad release
  pad_edit_hold = 0  
  pad_edit_part_pad = 0 

  // states for UI
  
  resetStepOnNewStep = 0
  uiMode = UIMODE_PADS
  mode_pad_edit = 0
  mode_multi_pattern = NO
  mode_copy_pattern = NO
  if Unassigned record
    record = 1 // Rec enabled by default
    transpose = NO
    transposeNote = 0
    mode_copy_pattern = NO
  endif

  PPQN = [8*step_reso, 4*step_reso, 3*step_reso, 2*step_reso, step_reso, step_reso/2, step_reso/4, step_reso/8]

  // init knob defaults
  if Unassigned currentDivisor
    currentDivisor = 1
    count = 1
    tickCounter = 0
    gate = 0.75
    swing = 0
    noteTimeX_knob = 100
    probability_knob = 100
  endif

  SetKnobValue 0, 0
  SetKnobValue 1, 64
  SetKnobValue 2, 127
  SetKnobValue 3, 64

  call @ComputeTimes
  Call @InitSequencer

  if Unassigned last_active_pattern
    last_active_pattern = 1
  endif
  active_pattern = 0

  call @UpdateGUI
@End

// Refactor pad_edit -> part_edit
// Break up OnPad events into smaller functions
// Explicit "mode_pad_edit" mode variables keeping UI state
// Explicit "end action and return to pad view" call at end of pattern actions (clear, copy etc)
// + Rec should only affect live recording
// Active_pattern when we have multi patterns? redundant?


@InitSequencer
  if Unassigned polycount
    Call @ClearSequencer
  endif
@End

@ClearSequencer
  FillArray polycount, 0
  FillArray voice1, -1
  FillArray voice1_velocity, 0
  FillArray voice2, -1
  FillArray voice2_velocity, 0
  FillArray voice3, -1
  FillArray voice3_velocity, 0
  FillArray voice4, -1
  FillArray voice4_velocity, 0
  FillArray voice5, -1
  FillArray voice5_velocity, 0
  FillArray voice6, -1
  FillArray voice6_velocity, 0
  FillArray noteTimeX, 100
  FillArray noteOnTicks, 0
  FillArray note_probability, 100

  playing_patterns = [ YES, NO, NO, NO, NO, NO, NO ]
@End

@ClearActivePattern
  _pattern_start = active_pattern * sizeof_pattern
  FillArray polycount[_pattern_start], 0, sizeof_pattern
  FillArray voice1[_pattern_start], -1, sizeof_pattern
  FillArray voice1_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice2[_pattern_start], -1, sizeof_pattern 
  FillArray voice2_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice3[_pattern_start], -1, sizeof_pattern 
  FillArray voice3_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice4[_pattern_start], -1, sizeof_pattern 
  FillArray voice4_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice5[_pattern_start], -1, sizeof_pattern 
  FillArray voice5_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice6[_pattern_start], -1, sizeof_pattern
  FillArray voice6_velocity[_pattern_start], 0, sizeof_pattern
  FillArray noteTimeX[_pattern_start], 100, sizeof_pattern
  FillArray noteOnTicks[_pattern_start], 0, sizeof_pattern
  FillArray note_probability[_pattern_start], 100 , sizeof_pattern
@End

@OnMetroPulse 
  FlashPad step
  step_part = RoundDown(tickCounter / countPerStep) * step_reso 
  note_part = (step * step_reso + step_part) // The note location in the wide grid
  
  for _active_pattern = 0 to 6 
    if (mode_multi_pattern = 0 and active_pattern=_active_pattern) or (mode_multi_pattern = 1 and playing_patterns[_active_pattern] = YES)
      _note_part = (_active_pattern * sizeof_pattern) + note_part

      if voice1[_note_part] >= 0 and ((Random 1, 100) <= note_probability[_note_part])
        _transposeNote = 0
        if transpose 
          _transposeNote = transposeNote
        endif

        _polycount = polycount[_note_part]
        _noteTime = noteTime * (noteTimeX[_note_part] / 100)

        if _polycount > 5
          SendMIDINoteOn 0, voice6[_note_part] + _transposeNote, voice6_velocity[_note_part]      
          SendMIDINoteOff 0, voice6[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 4
          SendMIDINoteOn 0, voice5[_note_part] + _transposeNote, voice5_velocity[_note_part]      
          SendMIDINoteOff 0, voice5[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 3
          SendMIDINoteOn 0, voice4[_note_part] + _transposeNote, voice4_velocity[_note_part]      
          SendMIDINoteOff 0, voice4[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 2
          SendMIDINoteOn 0, voice3[_note_part] + _transposeNote, voice3_velocity[_note_part]      
          SendMIDINoteOff 0, voice3[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 1
          SendMIDINoteOn 0, voice2[_note_part] + _transposeNote, voice2_velocity[_note_part]      
          SendMIDINoteOff 0, voice2[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 0
          SendMIDINoteOn 0, voice1[_note_part] + _transposeNote, voice1_velocity[_note_part]      
          SendMIDINoteOff 0, voice1[_note_part] + _transposeNote, 0, _noteTime
        endif
      endif
    endif
  endfor

  Call @IncrementSequencer
@End

@OnShiftDown
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
      Log { Exiting Pad Edit mode }
      mode_pad_edit = 0
  elseif uiMode = UIMODE_PADS
    uiMode = UIMODE_BUTTONS // "button" mode
  elseif uiMode = UIMODE_BUTTONS
    uiMode = UIMODE_PADS // pad mode
    mode_copy_pattern = NO
  endif
  Call @UpdateGUI
@End 

@OnShiftUp
@End 

@OnPadHold
  pad_edit_step = pad
  mode_pad_edit = 1
  pad_edit_part = 0 
  if pad < 8
    pad_edit_part_pad = 8  // used for latching pad in UI. "hold to edit" always edits first part of step
  else
    pad_edit_part_pad = 0
  endif
  pad_edit_got_note = 0
  pad_edit_hold = 1
  Log {Pad held: }, pad
  LabelPad pad, {Editing...} 
  Call @UpdateGUI
@End


@OnPadSingleTap // param: pad

  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    if (pad_edit_step > 7 AND pad > 7) OR (pad_edit_step < 7 AND pad < 7)    // pad and tapped pad are on the same row  
      Log { Exiting Pad Edit mode }
      mode_pad_edit = 0
      Call @UpdateGUI
    else
      pad_edit_part = pad % step_reso // Only step_reso parts
      pad_edit_part_pad = pad // for UI usage like latching pad etc during edit
      LabelPad pad, { Edit }
      LabelPads {Editing step:part -- }, pad_edit_step, {:} , pad_edit_part, { -- SHIFT or step pad to exit }
    endif

//  elseif uiMode = UIMODE_PADS and mode_pad_reset_step = 1 // something like this for a "performance mode"
    // reset_step = pad
    // resetStepOnNewStep = 1

  elseif uiMode = UIMODE_PADS  // pads
    Log {Pad singletapped: }, pad

    pad_edit_step = pad
    mode_pad_edit = 1
    pad_edit_part = 0
    pad_edit_got_note = 0
    Call @UpdateGUI
  
  elseif uiMode = UIMODE_BUTTONS and mode_copy_pattern = YES
    mode_copy_pattern = NO

    if pad < 8
      exit
    endif
    
    _pattern = pad - 8
    _src_pattern_pos = active_pattern * sizeof_pattern
    _dest_pattern_pos = _pattern * sizeof_pattern
  
    CopyArray voice1[_src_pattern_pos], voice1[_dest_pattern_pos], sizeof_pattern
    CopyArray voice2[_src_pattern_pos], voice2[_dest_pattern_pos], sizeof_pattern
    CopyArray voice3[_src_pattern_pos], voice3[_dest_pattern_pos], sizeof_pattern
    CopyArray voice4[_src_pattern_pos], voice4[_dest_pattern_pos], sizeof_pattern
    CopyArray voice5[_src_pattern_pos], voice5[_dest_pattern_pos], sizeof_pattern
    CopyArray voice6[_src_pattern_pos], voice6[_dest_pattern_pos], sizeof_pattern
    CopyArray voice1_velocity[_src_pattern_pos], voice1_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice2_velocity[_src_pattern_pos], voice2_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice3_velocity[_src_pattern_pos], voice3_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice4_velocity[_src_pattern_pos], voice4_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice5_velocity[_src_pattern_pos], voice5_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice6_velocity[_src_pattern_pos], voice6_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray polycount[_src_pattern_pos], polycount[_dest_pattern_pos], sizeof_pattern
    CopyArray noteTimeX[_src_pattern_pos], noteTimeX[_dest_pattern_pos], sizeof_pattern
    CopyArray noteOnTicks[_src_pattern_pos], noteOnTicks[_dest_pattern_pos], sizeof_pattern
    CopyArray note_probability[_src_pattern_pos], note_probability[_dest_pattern_pos], sizeof_pattern

    LabelPad _pattern + 8, {Copied }, active_pattern+1 

  elseif uiMode = UIMODE_BUTTONS
    if pad = BTN_TRANSPOSE
      transpose = not transpose
      LabelPad 0, { Transpose: }, transpose

      if transpose = 0
        LabelPads { Hello }
      endif

    elseif pad = BTN_CLEAR_ALL
      Call @ClearSequencer    
      
    elseif pad = BTN_RECORD
      record = not record
      LabelPad 2, { Rec: }, record
  
    elseif pad = BTN_DUMP
      Call @DumpNotes
      
    elseif pad = BTN_COPY_PATTERN
      LabelPads { Select pattern to copy active pattern to }
      mode_copy_pattern = YES

    elseif pad = BTN_MULTI_PATTERN
        mode_multi_pattern = not mode_multi_pattern
        if mode_multi_pattern
          LabelPads { Select patterns to play simultaneously }
          LabelPad BTN_MULTI_PATTERN, {Multi: ON}
        else
          LabelPads { Single pattern arm mode }
          LabelPad BTN_MULTI_PATTERN, {Multi: OFF}
        endif

        Call @UpdateGUI

    elseif pad = BTN_CLEAR_ARMED
      Call @ClearActivePattern

    elseif pad >= 8 and pad <= 14     // Pattern ARM. Future proof with upper bound ;)
      if mode_multi_pattern
        _pattern = pad - 8
        _new_state = not playing_patterns[_pattern]
        playing_patterns[_pattern] = _new_state
        active_pattern = _pattern
        LatchPad pad, playing_patterns[_pattern]

        Log {Pattern }, _pattern + 1, {: }, _new_state      
      else
        last_active_pattern = active_pattern
        active_pattern = pad-8
      endif

      Call @UpdateGUI
    endif

    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
    
    if mode_copy_pattern <> 1 and mode_multi_pattern <> 1 and pad <> BTN_MULTI_PATTERN
      uiMode = UIMODE_PADS
      Call @UpdateGUI
    endif
  endif
@End

@DumpNotes

  for _pattern = 0 to 7
    for _step = 0 to 15
       for _part = 0 to step_reso - 1
          _notepart = _step * step_reso + _part
          _notepos = (_pattern * sizeof_pattern) + _notepart
          if voice1[_notepos] >= 0
              Log { Pattern: }, _pattern+1, { Step: }, _step, { Part: }, _part, { Voice1: }, (NoteName voice1[_notepos], YES)
          endif
      endfor  
    endfor  
  endfor
 
@End

@OnPadDoubleTap

  if mode_pad_edit = 1
    del_step_part = pad % 8
    del_step = pad_edit_step
    del_step_pos = del_step * step_reso + del_step_part // The note location in the wide grid

    polycount[(active_pattern * sizeof_pattern) + del_step_pos] = 0
  
    LatchPad pad, 0
    LabelPad pad, { }
  else
    del_step = pad
    del_note_part = del_step * step_reso // The note location in the wide grid

    for po = 0 to step_reso
      polycount[(active_pattern * sizeof_pattern) + (del_note_part + po)] = 0
    endfor
  
    LatchPad del_step, 0
    LabelPad del_step, { }
  endif
@End

@OnHostStart
  step = 0
  note_pos = 0
  note_part = 0  
  tickCounter = 0
  total_tickCounter = 0
@End 

@OnMidiNoteOn

  log {Midi Note On: }, MIDINote, { Vel: }, MIDIVelocity
  nn = MIDINote
  v = MIDIVelocity

  if transpose AND mode_pad_edit <> 1 
    transposeNote = MIDINote - 48
    LabelPads { Transpose: }, transposeNote
    Exit
  endif
  
  SendMidiThru

  if not record and not mode_pad_edit = 1
    Exit
  endif
  
  if mode_pad_edit = 1

    pad_edit_got_note = 1
    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 

    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part
 
    if not Unassigned pad_edit_part_pad  // Latch and label when editing parts of step
      LabelPad pad_edit_part_pad, nn
      LatchPad pad_edit_part_pad, 1
    endif
  else
    _step = step
    _note_part = (active_pattern * sizeof_pattern) + note_part
  endif
  
  _poly_offset = polycount[_note_part]
 
  if _poly_offset = 0
    voice1[_note_part] = nn
    voice1_velocity[_note_part] = nn
  elseif _poly_offset = 1
    voice2[_note_part] = nn
    voice2_velocity[_note_part] = nn
  elseif _poly_offset = 2
    voice3[_note_part] = nn
    voice3_velocity[_note_part] = nn
  elseif _poly_offset = 3
    voice4[_note_part] = nn
    voice4_velocity[_note_part] = nn
  elseif _poly_offset = 4
    voice5[_note_part] = nn
    voice5_velocity[_note_part] = nn
  elseif _poly_offset = 5
    voice6[_note_part] = nn
    voice6_velocity[_note_part] = nn
  endif

  if _poly_offset < 8
    Inc _poly_offset
  endif

  polycount[_note_part] = _poly_offset
  noteOnTicks[_note_part] = total_tickCounter
  SetNoteState 0, nn, _note_part    // So that MidiNoteOff can reference all data of the note being played

  LabelPad _step, _poly_offset, {:}, (NoteName nn, YES) 
  LatchPad _step, 1
  Log {CPS: }‚ countPerStep, {tickCounter: }, tickCounter, { step: }, step,{ note_part: }, note_part, { note_pos: }, note_pos, { Note: }, (Notename nn, YES)

  last_note = nn      // for single-tap edit
  last_velocity = nn  

@End 

@OnMidiNoteOff
  nn = MIDINote
  v = MIDIVelocity

  SendMidiThru

  _note_part = GetNoteState 0, nn
  _on_ticks = noteOnTicks[_note_part]
  _off_ticks = total_tickCounter
  _elapsed_ticks = _off_ticks - _on_ticks

  // Special case if transport is stopped or we have long steps (like 2 bars) we might get 0 ticks so we default to 1 step for these cases.
  if _elapsed_ticks = 0
    _elapsed_pct = 100
  else
    _elapsed_pct = tickTime * _elapsed_ticks / noteTime * 100
  endif

  Log { Note On: }, _on_ticks, { Off: }, _off_ticks, { Elapsed: }, _elapsed_ticks, { = }, _elapsed_pct
  noteTimeX[_note_part] = _elapsed_pct  // elapsed as percentage of notetime
@End

@OnKnobChange
  if LastKnob = 0
    currentDivisor = Round ((GetKnobValue 0) / 16)
  elseif LastKnob = 1
    noteTimeX_knob = Round((GetKnobValue 1) / 127 * 800)  
    if noteTimeX_knob < 6.25
      noteTimeX_knob = 6.25     // So noteTimeX_knox will be between 6.25 (equiv of a 1/64 note) and 800 of the note time, scaled down to % (1/100) later
    endif
  
    if mode_pad_edit = 1
      noteTimeX[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = noteTimeX_knob
    else
      noteTimeX[(active_pattern * sizeof_pattern) + note_part] = noteTimeX_knob
    endif
//  elseif LastKnob = 2  
//    gate = (GetKnobValue 2) / 100
  elseif LastKnob = 2  
    _probability = (GetKnobValue 2) / 127 * 100
    if mode_pad_edit = 1
      note_probability[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _probability
    else
      note_probability[(active_pattern * sizeof_pattern) + note_part] = _probability
    endif

    probability_knob = _probability
    
  elseif LastKnob = 3
    swing = (GetKnobValue 3) / 127
  endif

  call @ComputeTimes
  call @UpdateGUI
@End

@IncrementSequencer
  Inc tickCounter
  Inc total_tickCounter

  if tickCounter >= countPerStep
    tickCounter = 0
    
    if resetStepOnNewStep = 1
      resetStepOnNewStep = 0
      step = reset_step
    else
      Inc step
      if step > 15
        step = 0
      endif
    endif
  endif
@End 

@ComputeTimes
  tickTime = QuarterNote / PPQN[currentDivisor]
  stepTime = tickTime * step_reso
  countPerStep = step_reso 

  noteTime = stepTime * gate
  SetMetroPPQN PPQN[currentDivisor]
@End

@UpdateGUI
  if uiMode = UIMODE_PADS AND mode_pad_edit = 1
    call @GUI_PadEditMode
    LabelPads {Editing step:part -- }, pad_edit_step, {:} , pad_edit_part, { -- SHIFT or step pad to exit }
    LabelKnobs {Note settings}

  elseif uiMode = UIMODE_PADS
    call @GUI_PadMode
    LabelPads  {P}, active_pattern+1,{ rec: }, record, { transpose: }, transpose, { multi:}, mode_multi_pattern
    LabelKnobs {P}, active_pattern+1, { settings}

  elseif uiMode = UIMODE_BUTTONS
    call @GUI_ButtonMode 
    LabelKnobs {P}, active_pattern+1, { settings}
  endif
@End

@GUI_PadEditMode
  if pad_edit_step <= 7
    _pad_offset = 8
  else
    _pad_offset = 0
  endif

  for the_part = 0 to step_reso
    _note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso + the_part)
    _cnt = polycount[_note_part]
    _pad = the_part + _pad_offset
    if _cnt > 0
      LabelPad _pad, _cnt, {:}, (NoteName voice1[_note_part], YES), {:}, noteTimeX[_note_part]
      LatchPad _pad, 1
    else
      LatchPad _pad, 0
      LabelPad _pad, {-}
    endif
  endfor

  Call @GUI_LabelKnobs
@End

@GUI_ButtonMode
  
  for po = 0 to 15
    LabelPad po, { }
    LatchPad po, 0
  endfor

  LabelPad BTN_TRANSPOSE, { Transpose: }, transpose
  LabelPad BTN_CLEAR_ALL, { Clear all }
  LabelPad BTN_RECORD, { Live rec: }, record
  LabelPad BTN_DUMP, { Dump }
  LabelPad BTN_COPY_PATTERN, { Copy pattern }
  LabelPad BTN_CLEAR_ARMED, { Clear armed }

  if mode_multi_pattern  
    LabelPad BTN_MULTI_PATTERN, {Play: Multi}
    for _pattern = 0 to 6
      if playing_patterns[_pattern] = 1 and active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { ON, ARM}
      elseif playing_patterns[_pattern] = 1 and active_pattern <> _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { ON}
      elseif playing_patterns[_pattern] = 0 and active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { OFF, ARM}
      else
        LabelPad _pattern + 8, {P}, _pattern+1, { OFF}
      endif
    endfor
  else
    LabelPad BTN_MULTI_PATTERN, {Play: Solo}
    for _pattern = 0 to 6
      if active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { SOLO}
      else
        LabelPad _pattern + 8, {P}, _pattern+1
      endif
    endfor
  endif

  LatchPad 8+active_pattern, 1
  LabelPads {Tap pattern to arm. SHIFT exits.}
@End

@GUI_LabelKnobs
  if currentDivisor = 0
    LabelKnob 0, {1/32}
  elseif currentDivisor = 1
    LabelKnob 0, {1/16}
  elseif currentDivisor = 2
    LabelKnob 0, {1/8t}
  elseif currentDivisor = 3
    LabelKnob 0, {1/8}
  elseif currentDivisor = 4
    LabelKnob 0, {1/4}
  elseif currentDivisor = 5
    LabelKnob 0, {1/2}
  elseif currentDivisor = 6
    LabelKnob 0, {bar}
  elseif currentDivisor = 7
    LabelKnob 0, {2 bar}
  endif

  LabelKnob 1, noteTimeX_knob*1.000
  LabelKnob 2, Round probability_knob
@End

@GUI_PadMode

  Call @GUI_LabelKnobs

  for _step = 0 to 15
    _voice_cnt = 0
    _part_cnt = 0
    for _part = 0 to step_reso-1
      _voice_part_cnt = polycount[(active_pattern * sizeof_pattern) + (_step * step_reso + _part)]
      if _voice_part_cnt > 0
        _voice_cnt = _voice_cnt + _voice_part_cnt
        Inc _part_cnt
      endif
    endfor

    if _part_cnt > 0
      LatchPad _step, 1
      LabelPad _step, _part_cnt, {:}, _voice_cnt, {:}, noteTimeX[(active_pattern * sizeof_pattern) + (_step * step_reso)]
    else
      LatchPad _step, 0
      LabelPad _step, { }
    endif
  endfor

@End

@PadManagerOnLoad
  
  // The following vars CAN be set before @InitPadManager. 
  // If they are not defined here, they will be automatically 
  // defined with their defaults in @InitPadManager
  //
  // In the most basic use-case, just Call @InitPadManager 
  // in your OnLoad without setting any of them. 
  
  pmAnalyseTime = 150 
  // Length of double tap / tap-and-hold time window in msec
    
  pmManageTimer = YES
  // Set to NO if your script wants to controll the timer.
  // Your timer needs to run continously and with an update
  // interval faster than 50, otherwise the pad manager 
  // wont work. Also set pmTickInterval accordingly.

  pmTickInterval = 50
  // Update interval for the timer in msec.

  //  pmExcludePads = [7,15]
  pmExcludeCnt = 0
  // List of pad ids and length of list to be excluded from
  // analysis. For these pads OnSingleTap will be called 
  // immediately in 'OnPadDown' without the analysis delay.

  Call @InitPadManager
@End



// ========= Pad Manager V2 =========
// -ki  01.06.2019

@InitPadManager  

  // Apply defaults, if the vars are not yet defined

  if Unassigned pmAnalyseTime
    pmAnalyseTime = 200 
  endif
  if Unassigned pmManageTimer
    pmManageTimer = YES
  endif
  if Unassigned pmTickInterval
    pmTickInterval = 25
  endif
  if Unassigned pmExcludePads
    pmExcludePads = []
  endif
  if Unassigned pmExcludeCnt
    pmExcludeCnt = 0
  endif
  
  padsActiveCnt = 0  
  padMaxId = 15
  for pad = 0 to padMaxId
    Call @InitPadState
  endfor

  if pmExcludeCnt>0
    for pad = 0 to pmExcludeCnt-1
      padExclude[ pmExcludePads[pad] ] = YES
    endfor
  endif

  padAnalyseTicks = pmAnalyseTime / pmTickInterval

  if pmManageTimer
    SetTimerInterval pmTickInterval
  endif
  
  Log {PadManager started (},pmExcludeCnt,{ excluded pads, timer=}, pmTickInterval,{msec)}
@End

@InitPadState // Param: pad
  padActive[pad] = NO
  padTicks[pad] = 0
  padTaps[pad] = 0
  padHold[pad] = NO
  padExclude[pad] = NO
@End

@ReleasePadState // Param: pad
  Dec padsActiveCnt
  if pmManageTimer and padsActiveCnt = 0
    StopTimer 
  endif
  Call @InitPadState
 @End

@OnPadDown 
  if padExclude[LastPad]
    pad = LastPad
    Call @OnPadSingleTap
  else
    if pmManageTimer and padsActiveCnt = 0
      StartTimer 
    endif
    if not padActive[LastPad]
      Inc padsActiveCnt
      padActive[LastPad] = YES
    endif
    inc padTaps[LastPad]
  endif
@End 

@OnPadUp 
  if padTaps[LastPad] = 1 and padTicks[LastPad] < padAnalyseTicks
    padHold[LastPad] = YES
  endif

  if pad_edit_got_note = 1 OR (pad_edit_hold and pad = pad_edit_step)  // second clause is probably sufficient?!
    pad_edit_got_note = 0
    mode_pad_edit = 0
    Call @UpdateGUI
  endif
@End 

@OnTimer 
  for pad = 0 to padMaxId
    if padActive[pad]
      Inc padTicks[pad]

      if padTicks[pad] > padAnalyseTicks
        if padTaps[pad] = 1
          if padHold[pad]
            Call @OnPadSingleTap
          else
            Call @OnPadHold
          endif
        else
            Call @OnPadDoubleTap
        endif

        Call @ReleasePadState
      endif
    endif
  endfor
@End 

// <<<<<<<<< end of Pad Manager script code >>>>>

@Description
  Multi-pattern two-level midi sequencer/looper for Mozaic by peblin.
  Featuring:

  - 16 steps with 8 subdivisions (parts) each
  - 7 patterns with pattern copy
  - 6 voice polyphony per part
  - From 1/32 to 2 bar step length
  - Live recording, including note durations
  - Individual step / part editing
  - Note probability
  - Note duration can be set by knob per part
  - Transpose mode
  - Manual triggering of steps using single tap
    
  Inspired by OP-Z and https://patchstorage.com/infinity
  Thanks to -ki for https://patchstorage.com/pad-manager-include
@End