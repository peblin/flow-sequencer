// TODO
// Refactor pad_edit -> part_edit
// Break up On...  events into smaller functions
// ^^ Separate UI
// + Rec should only affect live recording

// BUGS
// noteTimeX is overwritten if note is replayed even if recording is Off
// cant exit editing of step 7:7
// What happens to note delay if youve live recorded, then edits a step? need to clear note delay

@Onload
  ShowLayout 2

  CurrentTimerTicks = 0
  timer_tick_resolution = 10 // Milliseconds per tick
  last_pulse_ticks = 0
  Call @PadManagerOnLoad

  step_reso = 8  // Grid/parts per step
  poly = 6       // Max polyphony per part
  sizeof_pattern = 16*8      // Size of storing all step parts in an array

  // CONSTANTS

  UIMODE_PADS = 1
  UIMODE_BUTTONS = 2
  UIMODE_VOICES = 3

  // Buttons
  BTN_MULTI_PATTERN = 0
  BTN_COPY_PATTERN = 1
  BTN_TRANSPOSE = 2
  BTN_RECORD = 3
  BTN_QUANTIZE = 4
  BTN_DUMP = 5
  BTN_CLEAR_ALL = 6
  BTN_CLEAR_ARMED = 7

  poly_offset = 0
  note_pos = 0
  note_part = 0
  step = 0
  pad_edit_step = 0
  
  // tracks total ticks since start of transport. might wrap, but that wont kill anyone....i think
  total_tickCounter = 0  

// tracks if a note was received while holding a pad - in which case we can exit pad edit mode on pad release
  pad_edit_got_note = YES
  pad_edit_hold = 0  
  pad_edit_part_pad = 0 

  // states for UI
  
  resetStepOnNewStep = 0
  mode_pad_edit = 0
  mode_multi_pattern = NO
  mode_copy_pattern = NO
  if Unassigned record
    record = 1 // Rec enabled by default
    transpose = NO
    transposeNote = 0
    mode_copy_pattern = NO
  endif

  PPQN = [8*step_reso, 4*step_reso, 3*step_reso, 2*step_reso, step_reso, step_reso/2, step_reso/4, step_reso/8]

  // quantization
  
  QUANT_NONE = 0
  QUANT_PART = 1
  QUANT_STEP = 2
  
  quantize = QUANT_NONE

  // init knob defaults
  if Unassigned currentDivisor
    currentDivisor = 1
    count = 1
    tickCounter = 0
    gate = 0.75
    swing = 0
    noteTimeX_knob = 100
    probability_knob = 100
  endif

  SetKnobValue 0, 0
  SetKnobValue 1, 64
  SetKnobValue 2, 127
  SetKnobValue 3, 64

  call @ComputeTimes
  Call @InitSequencer

  if Unassigned last_active_pattern
    last_active_pattern = 1
  endif
  active_pattern = 0
  StartTimer 
  call @SetUIMode_Pads
@End

@IncrementSequencer
  Inc tickCounter
  Inc total_tickCounter

  if tickCounter >= countPerStep
    tickCounter = 0
    
    if resetStepOnNewStep = 1
      resetStepOnNewStep = 0
      step = reset_step
    else
      Inc step
      if step > 15
        step = 0
      endif
    endif
  endif
@End 

@ComputeTimes
  tickTime = QuarterNote / PPQN[currentDivisor]
  stepTime = tickTime * step_reso
  countPerStep = step_reso 

  noteTime = stepTime * gate
  SetMetroPPQN PPQN[currentDivisor]
@End





@InitSequencer
  if Unassigned polycount
    Call @ClearSequencer
  endif
@End

@ClearSequencer
  FillArray polycount, 0
  FillArray voice1, -1
  FillArray voice1_velocity, 0
  FillArray voice2, -1
  FillArray voice2_velocity, 0
  FillArray voice3, -1
  FillArray voice3_velocity, 0
  FillArray voice4, -1
  FillArray voice4_velocity, 0
  FillArray voice5, -1
  FillArray voice5_velocity, 0
  FillArray voice6, -1
  FillArray voice6_velocity, 0
  FillArray noteTimeX, 100
  FillArray noteOnTicks, 0
  FillArray noteOnDelayTicks, 0
  FillArray note_probability, 100

  playing_patterns = [ YES, NO, NO, NO, NO, NO, NO ]
@End

@ClearActivePattern
  _pattern_start = active_pattern * sizeof_pattern
  FillArray polycount[_pattern_start], 0, sizeof_pattern
  FillArray voice1[_pattern_start], -1, sizeof_pattern
  FillArray voice1_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice2[_pattern_start], -1, sizeof_pattern 
  FillArray voice2_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice3[_pattern_start], -1, sizeof_pattern 
  FillArray voice3_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice4[_pattern_start], -1, sizeof_pattern 
  FillArray voice4_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice5[_pattern_start], -1, sizeof_pattern 
  FillArray voice5_velocity[_pattern_start], 0, sizeof_pattern 
  FillArray voice6[_pattern_start], -1, sizeof_pattern
  FillArray voice6_velocity[_pattern_start], 0, sizeof_pattern
  FillArray noteTimeX[_pattern_start], 100, sizeof_pattern
  FillArray noteOnTicks[_pattern_start], 0, sizeof_pattern
  FillArray noteOnDelayTicks[_pattern_start], 0, sizeof_pattern
  FillArray note_probability[_pattern_start], 100 , sizeof_pattern
@End

@OnMetroPulse   
  last_pulse_ticks = CurrentTimerTicks


  // If we dont use RoundDown here, but Round we should be able to get better quantization,
  // but we need to handle the "last part" so it can wrap over to next step as well as wrap
  // around at the end of the 16 steps

  step_part = RoundDown(((tickCounter+1) / countPerStep) * step_reso) - 1
  note_part = (step * step_reso + step_part) // The note location in the wide grid
  
//  Log {step_part: }, step_part, {  note_part: }, note_part, {  tickCounter: }, tickCounter, {  tc+1/cps: }, ((tickCounter+1)/countPerStep)
  
  for _active_pattern = 0 to 6 
    if (mode_multi_pattern = 0 and active_pattern=_active_pattern) or (mode_multi_pattern = 1 and playing_patterns[_active_pattern] = YES)
      _note_part = (_active_pattern * sizeof_pattern) + note_part

      if voice1[_note_part] >= 0 and ((Random 1, 100) <= note_probability[_note_part])
        _transposeNote = 0
        if transpose 
          _transposeNote = transposeNote
        endif

        _polycount = polycount[_note_part]
        _noteDelay = noteOnDelayTicks[_note_part] * timer_tick_resolution
        _noteTime = noteTime * (noteTimeX[_note_part] / 100) + _noteDelay

        Log {Delay: }, _noteDelay

        if _polycount > 5
          SendMIDINoteOn 0, voice6[_note_part] + _transposeNote, voice6_velocity[_note_part], _noteDelay      
          SendMIDINoteOff 0, voice6[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 4
          SendMIDINoteOn 0, voice5[_note_part] + _transposeNote, voice5_velocity[_note_part], _noteDelay     
          SendMIDINoteOff 0, voice5[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 3
          SendMIDINoteOn 0, voice4[_note_part] + _transposeNote, voice4_velocity[_note_part], _noteDelay      
          SendMIDINoteOff 0, voice4[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 2
          SendMIDINoteOn 0, voice3[_note_part] + _transposeNote, voice3_velocity[_note_part], _noteDelay      
          SendMIDINoteOff 0, voice3[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 1
          SendMIDINoteOn 0, voice2[_note_part] + _transposeNote, voice2_velocity[_note_part], _noteDelay      
          SendMIDINoteOff 0, voice2[_note_part] + _transposeNote, 0, _noteTime
        endif
        if _polycount > 0
          SendMIDINoteOn 0, voice1[_note_part] + _transposeNote, voice1_velocity[_note_part], _noteDelay      
          SendMIDINoteOff 0, voice1[_note_part] + _transposeNote, 0, _noteTime
        endif
      endif
    endif
  endfor

  FlashPad step
  Call @IncrementSequencer
@End

@OnShiftDown
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    Call @SetUIMode_Voices 
//      Log { Exiting Pad Edit mode }
//      mode_pad_edit = 0
  elseif uiMode = UIMODE_VOICES
    Call @SetUIMode_Pads
  elseif uiMode = UIMODE_PADS
    uiMode = UIMODE_BUTTONS // "button" mode
    Call @UpdateGUI
  elseif uiMode = UIMODE_BUTTONS
    uiMode = UIMODE_PADS // pad mode
    mode_copy_pattern = NO
    Call @UpdateGUI
  endif
@End 

@OnShiftUp
@End 

@OnPadHold
  pad_edit_step = pad
  mode_pad_edit = 1
  pad_edit_part = 0 
  if pad < 8
    pad_edit_part_pad = 8  // used for latching pad in UI. "hold to edit" always edits first part of step
  else
    pad_edit_part_pad = 0
  endif
  pad_edit_got_note = NO
  pad_edit_hold = 1
  Log {Pad held: }, pad
  LabelPad pad, {Editing...} 
  Call @UpdateGUI
@End

@OnPadSingleTap // param: pad
  if uiMode = UIMODE_PADS and mode_pad_edit = 1
    if (pad_edit_step > 7 AND pad > 7) OR (pad_edit_step <= 7 AND pad <= 7)  // pad and tapped pad are on the same row  
      Log {Exiting Pad Edit mode }
      mode_pad_edit = 0
      Call @UpdateGUI
    else  
      _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
      if voice1[_note_part] > -1
        LabelPad pad_edit_part_pad, {üîµ}, (NoteName voice1[_note_part], YES), {:}, polycount[_note_part]
      else
        LabelPad pad_edit_part_pad, {‚ö™Ô∏è}
      endif

      pad_edit_part = pad % step_reso // Only step_reso parts
      pad_edit_part_pad = pad // for UI usage like latching pad etc during edit
      pad_edit_got_note = NO

      _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
      if voice1[_note_part] > -1
        LabelPad pad_edit_part_pad, {üî¥}, (NoteName voice1[_note_part], YES), {:}, polycount[_note_part]
      else
        LabelPad pad_edit_part_pad, {üî¥}
      endif
      LabelPads {‚ö†Ô∏è Editing }, pad_edit_step, {:} , pad_edit_part, {  ‚ÑπÔ∏è SHIFT for voices }
  endif

//  elseif uiMode = UIMODE_PADS and mode_pad_reset_step = 1 // something like this for a "performance mode"
    // reset_step = pad
    // resetStepOnNewStep = 1

  elseif uiMode = UIMODE_PADS  // pads
    Log {Entering Pad Edit mode for pad }, pad
    mode_pad_edit = 1
    pad_edit_step = pad
    pad_edit_part = 0
    pad_edit_got_note = NO
    if pad < 8
      pad_edit_part_pad = 8 // for UI usage like latching pad etc during edit
    else
      pad_edit_part_pad = 0
    endif
    Call @UpdateGUI
  
  elseif uiMode = UIMODE_BUTTONS and mode_copy_pattern = YES
    mode_copy_pattern = NO
    if pad < 8
      exit
    endif

    CopyPattern_pattern = pad - 8
    CopyPattern_src_pattern_pos = active_pattern * sizeof_pattern
    CopyPattern_dest_pattern_pos = CopyPattern_pattern * sizeof_pattern
  
    Call @CopyPattern
    LabelPad CopyPattern_pattern + 8, {P}, active_pattern+1, {CPY, ARM}
    LatchPad active_pattern+8, 0
    LatchPad CopyPattern_pattern + 8, 1
    active_pattern = CopyPattern_pattern  // Auto-arm after copy

  elseif uiMode = UIMODE_BUTTONS
    if pad = BTN_TRANSPOSE
      transpose = not transpose
      LabelPad BTN_TRANSPOSE, { Transpose: }, transpose
      LabelPads { Transpose: }, transpose

    elseif pad = BTN_CLEAR_ALL
      Call @ClearSequencer    
      
    elseif pad = BTN_RECORD
      record = not record
      LabelPad BTN_RECORD, { Rec: }, record
  
    elseif pad = BTN_QUANTIZE
      quantize = (quantize + 1) % 3
      Call @UpdateGUI
 
    elseif pad = BTN_DUMP
      Call @DumpNotes
      
    elseif pad = BTN_COPY_PATTERN
      LabelPads { Select pattern to copy active pattern to }
      mode_copy_pattern = YES

    elseif pad = BTN_MULTI_PATTERN
        mode_multi_pattern = not mode_multi_pattern
        if mode_multi_pattern
          LabelPads { Select patterns to play simultaneously }
          LabelPad BTN_MULTI_PATTERN, {Multi: ON}
        else
          LabelPads { Single pattern arm mode }
          LabelPad BTN_MULTI_PATTERN, {Multi: OFF}
        endif

        Call @UpdateGUI

    elseif pad = BTN_CLEAR_ARMED
      Call @ClearActivePattern

    elseif pad >= 8 and pad <= 14     // Pattern ARM. Future proof with upper bound ;)
      if mode_multi_pattern
        _pattern = pad - 8
        _current_state = playing_patterns[_pattern]
        if _pattern = active_pattern and _current_state = NO  // OFF, ARM
          _new_state = 1
          active_pattern = _pattern
        elseif _pattern = active_pattern and _current_state = YES // ON, ARM
          _new_state = 0
          active_pattern = _pattern
        elseif _pattern <> active_pattern and _current_state = NO // OFF, UNARM
          _new_state = 1
          active_pattern = _pattern          
        elseif _pattern <> active_pattern and _current_state = YES // ON, UNARM
          active_pattern = _pattern
        endif

        playing_patterns[_pattern] = _new_state
        LatchPad pad, playing_patterns[_pattern]

        Log {Pattern }, _pattern + 1, {: }, _new_state      
      else
        last_active_pattern = active_pattern
        active_pattern = pad-8
      endif

      Call @UpdateGUI
    endif

    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
    
//    if mode_copy_pattern <> 1 and mode_multi_pattern <> 1 and pad <> 
// BTN_MULTI_PATTERN and pad <> BTN_QUANTIZE
//      Call @SetUIMode_Pads
//    endif
  endif
@End

@SetUIMode_Pads
  uiMode = UIMODE_PADS
  ShowLayout 2
  Call @UpdateGUI
  LabelKnobs {P}, active_pattern+1, { settings }
@End

@SetUIMode_Voices
  uiMode = UIMODE_VOICES
  Call @UpdateGUI
@End

@CopyPattern
  _pattern = CopyPattern_pattern
  _src_pattern_pos = CopyPattern_src_pattern_pos
  _dest_pattern_pos = CopyPattern_dest_pattern_pos

  CopyArray voice1[_src_pattern_pos], voice1[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2[_src_pattern_pos], voice2[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3[_src_pattern_pos], voice3[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4[_src_pattern_pos], voice4[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5[_src_pattern_pos], voice5[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6[_src_pattern_pos], voice6[_dest_pattern_pos], sizeof_pattern
  CopyArray voice1_velocity[_src_pattern_pos], voice1_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice2_velocity[_src_pattern_pos], voice2_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice3_velocity[_src_pattern_pos], voice3_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice4_velocity[_src_pattern_pos], voice4_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice5_velocity[_src_pattern_pos], voice5_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray voice6_velocity[_src_pattern_pos], voice6_velocity[_dest_pattern_pos], sizeof_pattern
  CopyArray polycount[_src_pattern_pos], polycount[_dest_pattern_pos], sizeof_pattern
  CopyArray noteTimeX[_src_pattern_pos], noteTimeX[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnTicks[_src_pattern_pos], noteOnTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray noteOnDelayTicks[_src_pattern_pos], noteOnDelayTicks[_dest_pattern_pos], sizeof_pattern
  CopyArray note_probability[_src_pattern_pos], note_probability[_dest_pattern_pos], sizeof_pattern
@End

@DumpNotes

  for _pattern = 0 to 7
    for _step = 0 to 15
       for _part = 0 to step_reso - 1
          _notepart = _step * step_reso + _part
          _notepos = (_pattern * sizeof_pattern) + _notepart
          if voice1[_notepos] >= 0
              Log { Pattern: }, _pattern+1, { Step: }, _step, { Part: }, _part, { Voice1: }, (NoteName voice1[_notepos], YES)
          endif
      endfor  
    endfor  
  endfor
 
@End

@OnPadDoubleTap

  if mode_pad_edit = 1
    del_step_part = pad % 8
    del_step = pad_edit_step
    del_step_pos = del_step * step_reso + del_step_part // The note location in the wide grid

    polycount[(active_pattern * sizeof_pattern) + del_step_pos] = 0
  
    LatchPad pad, 0
    LabelPad pad, { }
  else
    del_step = pad
    del_note_part = del_step * step_reso // The note location in the wide grid

    for po = 0 to step_reso
      polycount[(active_pattern * sizeof_pattern) + (del_note_part + po)] = 0
    endfor
  
    LatchPad del_step, 0
    LabelPad del_step, { }
  endif
@End

@OnHostStart
  step = 0
  note_pos = 0
  note_part = 0  
  tickCounter = 0
  total_tickCounter = 0
  CurrentTimerTicks = 0  // "Optimistically" reset timer tick count on host start to reduce prob that it wraps during recording
@End 

@OnMidiNoteOn
  _note_on_ticks = CurrentTimerTicks
  nn = MIDINote
  v = MIDIVelocity

  if transpose AND mode_pad_edit <> 1 
    transposeNote = MIDINote - 48
    LabelPads { Transpose: }, transposeNote
    Exit
  endif
  
  SendMidiThru

  if not ((record and HostRunning) or mode_pad_edit = 1)
    Exit
  endif
  
  if mode_pad_edit = 1
    pad_edit_got_note = YES
    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 

    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part
 
    if not Unassigned pad_edit_part_pad  // Latch and label when editing parts of step
      Log {Latching pad}, pad_edit_part_pad
      LabelPad pad_edit_part_pad, (NoteName nn, YES)
      LatchPad pad_edit_part_pad, 1
    endif
  else
    _step = step
    if quantize = QUANT_STEP
      if step_part > 3 
        _step = (_step  + 1) % 16
      endif
      _note_part = (active_pattern * sizeof_pattern) + _step * step_reso
    else
      _note_part = (active_pattern * sizeof_pattern) + note_part
    endif
  endif
  
  _poly_offset = polycount[_note_part]
 
  if _poly_offset = 0
    voice1[_note_part] = nn
    voice1_velocity[_note_part] = v
  elseif _poly_offset = 1
    voice2[_note_part] = nn
    voice2_velocity[_note_part] = v
  elseif _poly_offset = 2
    voice3[_note_part] = nn
    voice3_velocity[_note_part] = v
  elseif _poly_offset = 3
    voice4[_note_part] = nn
    voice4_velocity[_note_part] = v
  elseif _poly_offset = 4
    voice5[_note_part] = nn
    voice5_velocity[_note_part] = v
  elseif _poly_offset = 5
    voice6[_note_part] = nn
    voice6_velocity[_note_part] = v
  endif

  if _poly_offset < 8
    Inc _poly_offset
  endif

  polycount[_note_part] = _poly_offset
  noteOnTicks[_note_part] = CurrentTimerTicks //total_tickCounter

  if quantize = QUANT_NONE
    noteOnDelayTicks[_note_part] = _note_on_ticks - last_pulse_ticks
  else
    noteOnDelayTicks[_note_part] = 0
  endif

  // Store part so that MidiNoteOff can reference all data of the note being played
  SetNoteState 0, nn, _note_part    

  if not mode_pad_edit
    LabelPad _step, _poly_offset, {:}, (NoteName nn, YES) 
    LatchPad _step, 1
  endif

  Log {ON: step: }, _step,{ note_part: }, _note_part, {CPS: }‚Äö countPerStep, { tickCounter: }, tickCounter,  { Note: }, (Notename nn, YES)

  last_note = nn      // for single-tap edit
  last_velocity = nn  
@End 

@OnMidiNoteOff
  SendMidiThru

  if not ((record and HostRunning) or mode_pad_edit = 1)
    Exit
  endif

  nn = MIDINote
  v = MIDIVelocity

  _note_part = GetNoteState 0, nn

  // Dont store anything unless state was set to <> -1. 
  if _note_part = -1
    Exit
  endif
  // Reset state to prevent OnMidiOff action when notes are played with recording off 
  SetNoteState 0, nn, -1

  _note_pad = Div (_note_part - active_pattern * sizeof_pattern), step_reso
  Log {OFF: pad:}, _note_pad, { np:}, _note_part, { ap:},  active_pattern, { sp:}, sizeof_pattern, { sr:}, step_reso
  _on_ticks = noteOnTicks[_note_part]
  _off_ticks = CurrentTimerTicks // total_tickCounter
  _elapsed_ticks = _off_ticks - _on_ticks

  // Special case:
  // if transport is stopped or we have long steps (like 2 bars) we might get 0 ticks so we default to 1 step for these cases.
  // we might also get negative elapse ticks if timer wrapped around the 16-bit int limit, so we just say 100% elapsed as a safeguard
  if _elapsed_ticks <= 0
    _elapsed_pct = 100
  else
    _elapsed_pct = _elapsed_ticks * timer_tick_resolution / noteTime * 100
  endif

  if not mode_pad_edit
    LabelPad _note_pad, (NoteName nn, YES), {:}, Round(_elapsed_pct) 
  endif
  noteTimeX[_note_part] = _elapsed_pct  // elapsed as percentage of notetime
@End

@OnKnobChange

  if currentDivisor = 0
    LabelKnob 0, {1/32}
  elseif currentDivisor = 1
    LabelKnob 0, {1/16}
  elseif currentDivisor = 2
    LabelKnob 0, {1/8t}
  elseif currentDivisor = 3
    LabelKnob 0, {1/8}
  elseif currentDivisor = 4
    LabelKnob 0, {1/4}
  elseif currentDivisor = 5
    LabelKnob 0, {1/2}
  elseif currentDivisor = 6
    LabelKnob 0, {bar}
  elseif currentDivisor = 7
    LabelKnob 0, {2 bar}
  endif

  if LastKnob = 0
    currentDivisor = Round ((GetKnobValue 0) / 16)
    if currentDivisor = 0
      LabelKnobs {1/32}
    elseif currentDivisor = 1
      LabelKnobs {1/16}
    elseif currentDivisor = 2
      LabelKnobs {1/8t}
    elseif currentDivisor = 3
      LabelKnobs {1/8}
    elseif currentDivisor = 4
      LabelKnobs {1/4}
    elseif currentDivisor = 5
      LabelKnobs {1/2}
    elseif currentDivisor = 6
      LabelKnobs {bar}
    elseif currentDivisor = 7
      LabelKnobs {2 bar}
    endif

  elseif LastKnob = 1
    noteTimeX_knob = Round((GetKnobValue 1) / 127 * 800)  
    if noteTimeX_knob < 6.25
      noteTimeX_knob = 6.25     // So noteTimeX_knox will be between 6.25 (equiv of a 1/64 note) and 800 of the note time, scaled down to % (1/100) later
    endif
  
    if mode_pad_edit = 1
      noteTimeX[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = noteTimeX_knob
    else
      noteTimeX[(active_pattern * sizeof_pattern) + note_part] = noteTimeX_knob
    endif
    LabelKnobs noteTimeX_knob*1.000, {%}

  elseif LastKnob = 2  
    _probability = (GetKnobValue 2) / 127 * 100
    if mode_pad_edit = 1
      note_probability[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _probability
    else
      note_probability[(active_pattern * sizeof_pattern) + note_part] = _probability
    endif

    probability_knob = _probability
    LabelKnobs (Round probability_knob), {%}

  elseif LastKnob = 3
    swing = (GetKnobValue 3) / 127
  endif

  call @ComputeTimes
  call @UpdateGUI
@End

@UpdateGUI
  if uiMode = UIMODE_PADS AND mode_pad_edit = 1
    call @GUI_PadEditMode

  elseif uiMode = UIMODE_PADS
    call @GUI_PadMode

  elseif uiMode = UIMODE_BUTTONS
    call @GUI_ButtonMode 
    LabelKnobs {P}, active_pattern+1, { settings}
 
  elseif uiMode = UIMODE_VOICES
     call @GUI_VoicesMode
  endif
@End

@GUI_VoicesMode
  ShowLayout 3
  _edit_note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso) + pad_edit_part

  _n = voice1[_edit_note_part]
  _n1 = _n
  LabelKnob 0, (NoteName _n, YES)
  SetKnobValue 0, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice2[_edit_note_part]
  LabelKnob 1, (NoteName _n, YES)
  SetKnobValue 1, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice3[_edit_note_part]
  LabelKnob 2, (NoteName _n, YES)
  SetKnobValue 2, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice4[_edit_note_part]
  LabelKnob 3, (NoteName _n, YES)
  SetKnobValue 3, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice5[_edit_note_part]
  LabelKnob 4, (NoteName _n, YES)
  SetKnobValue 4, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  _n = voice6[_edit_note_part]
  LabelKnob 5, (NoteName _n, YES)
  SetKnobValue 5, (TranslateScale _n, _n1-24, _n1+24, 0, 127) 

  LabelKnob 6, {Note time}
  SetKnobValue 6, (TranslateScale noteTimeX[_edit_note_part], 0, 800, 0, 127)

  LabelKnob 7, {Probability}
  SetKnobValue 6, (TranslateScale note_probability[_edit_note_part], 0, 100, 0, 127)
@End

@GUI_PadMode
  Call @GUI_LabelKnobs
  for _step = 0 to 15
    _voice_cnt = 0
    _part_cnt = 0
    for _part = 0 to step_reso-1
      _voice_part_cnt = polycount[(active_pattern * sizeof_pattern) + (_step * step_reso + _part)]
      if _voice_part_cnt > 0
        _voice_cnt = _voice_cnt + _voice_part_cnt
        Inc _part_cnt
      endif
    endfor

    if _part_cnt > 0
      LatchPad _step, 1
      LabelPad _step, _part_cnt, {:}, _voice_cnt, {:}, Round(noteTimeX[(active_pattern * sizeof_pattern) + (_step * step_reso)])
    else
      LatchPad _step, 0
      LabelPad _step, { }
    endif
  endfor
  
  if transpose and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ ‚ö™Ô∏è }, { transpose: }, transpose, { Play: Multi}, { quant: }, quantize
  elseif transpose
    LabelPads  {P}, active_pattern+1,{ ‚ö™Ô∏è SOLO}, { transpose: }, transpose, { quant: }, quantize
  elseif record and mode_multi_pattern
    LabelPads  {P}, active_pattern+1,{ üî¥ }, { Play: Multi}, { quant: }, quantize
  elseif record
    LabelPads  {P}, active_pattern+1,{ üî¥ SOLO}, { quant: }, quantize
  endif

@End

@GUI_PadEditMode
  if pad_edit_step <= 7
    _pad_offset = 8
  else
    _pad_offset = 0
  endif

  for the_part = 0 to step_reso-1
    _note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso + the_part)
    _cnt = polycount[_note_part]
    _pad = the_part + _pad_offset
    if _cnt > 0
      LabelPad _pad, {üîµ}, _cnt, {:}, (NoteName voice1[_note_part], YES), {:}, (Round noteTimeX[_note_part])
      LatchPad _pad, 1
    else
      LatchPad _pad, 0
      LabelPad _pad, {‚ö™Ô∏è}
    endif
  endfor

  _note_part = (active_pattern * sizeof_pattern) + pad_edit_step * step_reso + (pad_edit_part_pad % step_reso)
  if voice1[_note_part] > -1
    LabelPad pad_edit_part_pad, {üî¥}, (NoteName voice1[_note_part], YES), {:}, polycount[_note_part]
  else
    LabelPad pad_edit_part_pad, {üî¥}
  endif
  LabelPad pad_edit_step, {‚úÖ Done}
  LabelPads {‚ö†Ô∏è Editing }, pad_edit_step, {:} , pad_edit_part, {  ‚ÑπÔ∏è SHIFT for voices }
  LabelKnobs {Note settings}

  Call @GUI_LabelKnobs
@End

@GUI_ButtonMode
  
  for po = 0 to 15
    LabelPad po, { }
    LatchPad po, 0
  endfor

  LabelPad BTN_TRANSPOSE, {Transpose:}, transpose
  LabelPad BTN_CLEAR_ALL, {Clear all}
  LabelPad BTN_RECORD, {Live rec:}, record
  LabelPad BTN_DUMP, {Dump}
  LabelPad BTN_COPY_PATTERN, {Copy pattern}
  LabelPad BTN_CLEAR_ARMED, {Clear armed}

  if quantize = QUANT_NONE
    LabelPad BTN_QUANTIZE, {Quant: None} 
  elseif quantize = QUANT_PART
    LabelPad BTN_QUANTIZE, {Quant: Part} 
  else // QUANT_STEP
    LabelPad BTN_QUANTIZE, {Quant: Step} 
  endif

  if mode_multi_pattern  
    LabelPad BTN_MULTI_PATTERN, {Play: Multi}
    for _pattern = 0 to 6
      if playing_patterns[_pattern] = 1 and active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, {üî¥ ON}
      elseif playing_patterns[_pattern] = 1 and active_pattern <> _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, {ON}
      elseif playing_patterns[_pattern] = 0 and active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, {üî¥ OFF}
      else
        LabelPad _pattern + 8, {P}, _pattern+1, {OFF}
      endif
    endfor
  else
    LabelPad BTN_MULTI_PATTERN, {Play: Solo}
    for _pattern = 0 to 6
      if active_pattern = _pattern
        LabelPad _pattern + 8, {P}, _pattern+1, { SOLO}
      else
        LabelPad _pattern + 8, {P}, _pattern+1
      endif
    endfor
  endif

  LatchPad 8+active_pattern, 1
  LabelPads {Tap pattern to arm. ‚ÑπÔ∏è SHIFT exits.}
@End

@GUI_LabelKnobs
  LabelKnob 0, {Step}
  LabelKnob 1, {Note time}
  LabelKnob 2, {Probability}
@End


@GUI_LabelKnobs_old
  if currentDivisor = 0
    LabelKnob 0, {1/32}
  elseif currentDivisor = 1
    LabelKnob 0, {1/16}
  elseif currentDivisor = 2
    LabelKnob 0, {1/8t}
  elseif currentDivisor = 3
    LabelKnob 0, {1/8}
  elseif currentDivisor = 4
    LabelKnob 0, {1/4}
  elseif currentDivisor = 5
    LabelKnob 0, {1/2}
  elseif currentDivisor = 6
    LabelKnob 0, {bar}
  elseif currentDivisor = 7
    LabelKnob 0, {2 bar}
  endif

  LabelKnob 1, noteTimeX_knob*1.000
  LabelKnob 2, Round probability_knob
@End

@PadManagerOnLoad
  
  // The following vars CAN be set before @InitPadManager. 
  // If they are not defined here, they will be automatically 
  // defined with their defaults in @InitPadManager
  //
  // In the most basic use-case, just Call @InitPadManager 
  // in your OnLoad without setting any of them. 
  
  pmAnalyseTime = 200 
  // Length of double tap / tap-and-hold time window in msec
    
  pmManageTimer = YES
  // Set to NO if your script wants to controll the timer.
  // Your timer needs to run continously and with an update
  // interval faster than 50, otherwise the pad manager 
  // wont work. Also set pmTickInterval accordingly.

  pmTickInterval = timer_tick_resolution    // Update interval for the timer in msec.

  //  pmExcludePads = [7,15]
  pmExcludeCnt = 0

  // List of pad ids and length of list to be excluded from
  // analysis. For these pads OnSingleTap will be called 
  // immediately in 'OnPadDown' without the analysis delay.

  Call @InitPadManager
@End



// ========= Pad Manager V2 =========
// -ki  01.06.2019

@InitPadManager  

  // Apply defaults, if the vars are not yet defined

  if Unassigned pmAnalyseTime
    pmAnalyseTime = 200 
  endif
  if Unassigned pmManageTimer
    pmManageTimer = YES
  endif
  if Unassigned pmTickInterval
    pmTickInterval = 25
  endif
  if Unassigned pmExcludePads
    pmExcludePads = []
  endif
  if Unassigned pmExcludeCnt
    pmExcludeCnt = 0
  endif
  
  padsActiveCnt = 0  
  padMaxId = 15
  for pad = 0 to padMaxId
    Call @InitPadState
  endfor

  if pmExcludeCnt>0
    for pad = 0 to pmExcludeCnt-1
      padExclude[ pmExcludePads[pad] ] = YES
    endfor
  endif

  padAnalyseTicks = pmAnalyseTime / pmTickInterval

  if pmManageTimer
    SetTimerInterval pmTickInterval
  endif
  
  Log {PadManager started (},pmExcludeCnt,{ excluded pads, timer=}, pmTickInterval,{msec)}
@End

@InitPadState // Param: pad
  padActive[pad] = NO
  padTicks[pad] = 0
  padTaps[pad] = 0
  padHold[pad] = NO
  padExclude[pad] = NO
@End

@ReleasePadState // Param: pad
  Dec padsActiveCnt
  if pmManageTimer and padsActiveCnt = 0
//    StopTimer 
  endif
  Call @InitPadState
 @End

@OnPadDown 
  if padExclude[LastPad]
    pad = LastPad
    Call @OnPadSingleTap
  else
    if pmManageTimer and padsActiveCnt = 0
//      StartTimer 
    endif
    if not padActive[LastPad]
      Inc padsActiveCnt
      padActive[LastPad] = YES
    endif
    inc padTaps[LastPad]
  endif
@End 

@OnPadUp 
  if padTaps[LastPad] = 1 and padTicks[LastPad] < padAnalyseTicks
    padHold[LastPad] = YES
  endif

  if pad_edit_hold and LastPad = pad_edit_step
    pad_edit_got_note = NO
    pad_edit_hold = 0
    mode_pad_edit = 0
    Log {PadUp for pad }, LastPad, {, exiting mode_pad_edit}
    Call @UpdateGUI
  endif
@End 

@OnTimer 
  CurrentTimerTicks = (CurrentTimerTicks + 1) % 65534  // Wraps around every ~10 minutes

//  If CurrentTimerTicks % 100 = 0
//    Log {CTT: }, CurrentTimerTicks
//  Endif   

  for pad = 0 to padMaxId
    if padActive[pad]
      Inc padTicks[pad]

      if padTicks[pad] > padAnalyseTicks
        if padTaps[pad] = 1
          if padHold[pad]
            Call @OnPadSingleTap
          else
            Call @OnPadHold
          endif
        else
            Call @OnPadDoubleTap
        endif

        Call @ReleasePadState
      endif
    endif
  endfor
@End 

// <<<<<<<<< end of Pad Manager script code >>>>>

@Description
  Multi-pattern two-level midi sequencer/looper for Mozaic by peblin.
  Featuring:

  - 16 steps with 8 subdivisions (parts) each
  - 7 patterns with pattern copy
  - 6 voice polyphony per part
  - From 1/32 to 2 bar step length
  - Live recording, including note durations
  - Individual step / part editing
  - Note probability
  - Note duration can be set by knob per part
  - Transpose mode
  - Manual triggering of steps using single tap
    
  Inspired by OP-Z and https://patchstorage.com/infinity
  Thanks to -ki for https://patchstorage.com/pad-manager-include

@End