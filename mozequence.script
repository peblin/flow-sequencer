@Onload

  ShowLayout 2

  Call @PadManagerOnLoad

  step_reso = 8  // Grid/parts per step
  poly = 6       // Max polyphony per part
  patterns = 16*8   // Size of storing all step parts in an array

  poly_offset = 0
  note_pos = 0
  note_part = 0
  step = 0
  pad_edit_step = 0

  // states for UI
  
  resetStepOnNewStep = 0
  pad_edit = 0
  uiMode = 1 // "Pad mode"
  if Unassigned record
    record = 1 // Rec enabled by default
    transpose = NO
    transposeNote = 0
  endif

  PPQN = [8*step_reso, 4*step_reso, 3*step_reso, 2*step_reso, step_reso, step_reso/2, step_reso/4, step_reso/8]

  // init knob defaults
  if Unassigned currentDivisor
    currentDivisor = 0
    count = 1
    tickCounter = 0
    gate = 0.75
    swing = 0
  endif

  SetKnobValue 0, 0
  SetKnobValue 1, 0
  SetKnobValue 2, 100
  SetKnobValue 3, 64

  call @ComputeTimes

  Call @InitSequencer
  if Unassigned last_active_pattern
    last_active_pattern = 1
  endif

  active_pattern = 0

  call @UpdateGUI

@End

@InitSequencer
  if Unassigned notes
    FillArray notes, -1 // clear our notes buffer
    FillArray velocity, 0 // clear the velocity buffer
    FillArray polycount, 0
  endif

  FillArray voice1, -1 // clear our notes buffer
  FillArray voice1_velocity, 0 // clear the velocity buffer

  FillArray voice2, -1 // clear our notes buffer
  FillArray voice2_velocity, 0 // clear the velocity buffer

  FillArray voice3, -1 // clear our notes buffer
  FillArray voice3_velocity, 0 // clear the velocity buffer

  FillArray voice4, -1 // clear our notes buffer
  FillArray voice4_velocity, 0 // clear the velocity buffer

  FillArray voice5, -1 // clear our notes buffer
  FillArray voice5_velocity, 0 // clear the velocity buffer

  FillArray voice6, -1 // clear our notes buffer
  FillArray voice6_velocity, 0 // clear the velocity buffer

@End

@ClearSequencer
  FillArray polycount, 0
@End

@OnMetroPulse 

  Call @IncrementSequencer
  step_part = RoundDown(tickCounter / countPerStep) * step_reso 
  note_part = (step * step_reso + step_part) // The note location in the wide grid
 
  if voice1[note_part] >= 0 
    _transposeNote = 0
    if transpose 
      _transposeNote = transposeNote
    endif

    _polycount = polycount[(active_pattern * patterns) + note_part]
    if _polycount > 5
      SendMIDINoteOn 0, voice6[note_part] + _transposeNote, voice6_velocity[note_part]      
      SendMIDINoteOff 0, voice6[note_part], 0, noteTime
    endif
    if _polycount > 4
      SendMIDINoteOn 0, voice5[note_part] + _transposeNote, voice5_velocity[note_part]      
      SendMIDINoteOff 0, voice5[note_part], 0, noteTime
    endif
    if _polycount > 3
      SendMIDINoteOn 0, voice4[note_part] + _transposeNote, voice4_velocity[note_part]      
      SendMIDINoteOff 0, voice4[note_part], 0, noteTime
    endif
    if _polycount > 2
      SendMIDINoteOn 0, voice3[note_part] + _transposeNote, voice3_velocity[note_part]      
      SendMIDINoteOff 0, voice3[note_part], 0, noteTime
    endif
    if _polycount > 1
      SendMIDINoteOn 0, voice2[note_part] + _transposeNote, voice2_velocity[note_part]      
      SendMIDINoteOff 0, voice2[note_part], 0, noteTime
    endif
    if _polycount > 0
      SendMIDINoteOn 0, voice1[note_part] + _transposeNote, voice1_velocity[note_part]      
      SendMIDINoteOff 0, voice1[note_part], 1, noteTime
    endif
  endif

  FlashPad step

@End

@OnShiftDown
  uiMode = 2 // "button" mode
  Call @UpdateGUI
@End 

@OnShiftUp
  uiMode = 1 // pad mode
  Call @UpdateGUI
@End 

@OnPadHold
  pad_edit_step = pad
  pad_edit = 1
  pad_edit_part = 0
  Log {Pad held: }, pad
  LabelPad pad, {Editing...} 
  Call @UpdateGUI
@End


@OnPadSingleTap // param: pad

  if uiMode = 1 and pad_edit = 1
    pad_edit_part = pad % step_reso // Only step_reso parts
    pad_edit_part_pad = pad // for UI usage like latching pad etc during edit
    LabelPad pad, { Edit }
    LabelPads {Editing step:part -- }, pad_edit_step, {:} , pad_edit_part

  elseif uiMode = 1  // pads
    Log {Pad singletapped: }, pad
    reset_step = pad
    resetStepOnNewStep = 1
    
  elseif uiMode = 2 // buttons
    
    if pad = 0 // Transpose
      transpose = not transpose
      LabelPad 0, { Transpose: }, transpose

      if transpose = 0
        LabelPads { Hello }
      endif

    elseif pad = 1 // Erase All
      Call @ClearSequencer    
      
    elseif pad = 2 // Record
      record = not record
      LabelPad 2, { Rec: }, record
  
    elseif pad = 3 // Dump
      Call @DumpNotes
    
    elseif pad = 8 // Pattern 1
      last_active_pattern = active_pattern
      active_pattern = 0
 
    elseif pad = 9 // Pattern 2
      last_active_pattern = active_pattern
      active_pattern = 1
 
    elseif pad = 10 // Pattern 3
      last_active_pattern = active_pattern
      active_pattern = 2

    elseif pad = 11 // Pattern 4
      last_active_pattern = active_pattern
      active_pattern = 3

    endif
  endif
@End

@DumpNotes

  for stp = 0 to 15
    for stp_p = 0 to step_reso - 1
      stp_notepart = stp * step_reso + stp_p
      stp_notepos = stp_notepart * poly
      if notes[stp_notepos] >= 0
        for stp_pn = 0 to polycount[stp_notepart] - 1
           Log { Step: }, stp, { Part: }, stp_p, { Note: }, NoteName notes[stp_notepos + stp_pn]
        endfor
      endif
    endfor  
  endfor

@End

@OnPadDoubleTap

  if pad_edit = 1
    del_step_part = pad % 8
    del_step = pad_edit_step
    del_step_pos = del_step * step_reso + del_step_part // The note location in the wide grid

    polycount[(active_pattern * patterns) + del_step_pos] = 0
  
    LatchPad pad, 0
    LabelPad pad, { }
  else
    del_step = pad
    del_note_part = del_step * step_reso // The note location in the wide grid

    for po = 0 to step_reso
      polycount[(active_pattern * patterns) + (del_note_part + po)] = 0
    endfor
  
    LatchPad del_step, 0
    LabelPad del_step, { }
  endif
@End

@OnHostStart
  step = 0
  note_pos = 0
  note_part = 0  
  tickCounter = 0
@End 

@OnMidiNoteOn

  log {Midi Note On: }, MIDINote, { Vel: }, MIDIVelocity
  nn = MIDINote
  v = MIDIVelocity

  if transpose AND pad_edit <> 1 
    transposeNote = MIDINote - 48
    LabelPads { Transpose: }, transposeNote
    Exit
  endif
  
  SendMIDINoteOn 0, nn, v
  SendMIDINoteOff 0, nn, 0, noteTime

  if not record  
    Exit
  endif
  
  if pad_edit = 1

    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 

    _step = pad_edit_step
    _note_part = pad_note_part
 
    if not Unassigned pad_edit_part_pad  // Latch and label when editing parts of step
      LabelPad pad_edit_part_pad, nn
      LatchPad pad_edit_part_pad, 1
    endif
  else
    _step = step
    _note_part = note_part
  endif
  
  _poly_offset = polycount[(active_pattern * patterns) + _note_part]
 
  if _poly_offset = 0
    voice1[_note_part] = nn
    voice1_velocity[_note_part] = nn
  elseif _poly_offset = 1
    voice2[_note_part] = nn
    voice2_velocity[_note_part] = nn
  elseif _poly_offset = 2
    voice3[_note_part] = nn
    voice3_velocity[_note_part] = nn
  elseif _poly_offset = 3
    voice4[_note_part] = nn
    voice4_velocity[_note_part] = nn
  elseif _poly_offset = 4
    voice5[_note_part] = nn
    voice5_velocity[_note_part] = nn
  elseif _poly_offset = 5
    voice6[_note_part] = nn
    voice6_velocity[_note_part] = nn
  endif

  if _poly_offset < 8
    Inc _poly_offset
  endif

  polycount[(active_pattern * patterns) + _note_part] = _poly_offset

  LabelPad _step, _poly_offset, {:}, (NoteName nn, YES) 
  Log {CPS: }â€š countPerStep, {tickCounter: }, tickCounter, { step: }, step,{ note_part: }, note_part, { note_pos: }, note_pos, { Note: }, (Notename nn, YES)

  last_note = nn      // for single-tap edit
  last_velocity = nn  

@End 


@IncrementSequencer
  Inc tickCounter
  if tickCounter >= countPerStep
    tickCounter = 0
    
    if resetStepOnNewStep = 1
      resetStepOnNewStep = 0
      step = reset_step
    else
      Inc step
      if step > 15
        step = 0
      endif
    endif
  endif
@End 

@OnKnobChange
  currentDivisor = Round ((GetKnobValue 0) / 16)
  count = Round (((GetKnobValue 1)) / 4) + 1
  gate = (GetKnobValue 2) / 100
  swing = (GetKnobValue 3) / 127

  call @ComputeTimes
  call @UpdateGUI
@End


@ComputeTimes
  stepTime = QuarterNote / PPQN[currentDivisor] * step_reso * count
  countPerStep = step_reso 
  
  noteTime = stepTime * gate
  Log {ComputeTimes: }, {stepTime: }, stepTime, { noteTime: }, noteTime, { ppqn: }, PPQN[currentDivisor], { CPS: }, countPerStep
  SetMetroPPQN PPQN[currentDivisor]
@End

@UpdateGUI
  if uiMode = 1 AND pad_edit = 1
    call @GUI_PadEditMode
    LabelPads {Editing step:part -- }, pad_edit_step, {:} , pad_edit_part

  elseif uiMode = 1
    call @GUI_PadMode
    LabelPads {Rec: }, record, { Transpose: }, transpose

  elseif uiMode = 2
    call @GUI_ButtonMode 
    LabelPads {Menu}
  endif
@End

@GUI_PadEditMode
  if pad_edit_step <= 7
    for the_part = 0 to step_reso
      _cnt = polycount[(active_pattern * patterns) + (pad_edit_step * step_reso + the_part)]
      LabelPad (the_part + 8), _cnt, {:}, (NoteName voice1[(pad_edit_step * step_reso + the_part) * active_pattern], YES)
      if _cnt > 0
        LatchPad (the_part + 8), 1
      else
        LatchPad (the_part + 8), 0
      endif
    endfor
  else
    for the_part = 0 to step_reso
      _cnt = polycount[(active_pattern * patterns) + (pad_edit_step * step_reso + the_part)]
      LabelPad the_part, _cnt, {:}, (NoteName voice1[(pad_edit_step * step_reso + the_part)], YES)
      if _cnt > 0
        LatchPad (the_part), 1
      else
        LatchPad (the_part), 0
      endif
    endfor  
  endif
@End

@GUI_ButtonMode
  
  for po = 0 to 15
    LabelPad po, { }
    LatchPad po, 0
  endfor
      
  LabelPad 0, { Transpose: }, transpose
  LabelPad 1, { Clear all }
  LabelPad 2, { Rec: }, record
  LabelPad 3, { Dump }
  
  LabelPad 8, { Pattern 1}
  LabelPad 9, { Pattern 2}
  LabelPad 10, { Pattern 3}
  LabelPad 11, { Pattern 4}
  
  LatchPad 8+active_pattern, 1

@End

@GUI_PadMode
  if currentDivisor = 0
    LabelKnob 0, {1/32}
  elseif currentDivisor = 1
    LabelKnob 0, {1/16}
  elseif currentDivisor = 2
    LabelKnob 0, {1/8t}
  elseif currentDivisor = 3
    LabelKnob 0, {1/8}
  elseif currentDivisor = 4
    LabelKnob 0, {1/4}
  elseif currentDivisor = 5
    LabelKnob 0, {1/2}
  elseif currentDivisor = 6
    LabelKnob 0, {bar}
  elseif currentDivisor = 7
    LabelKnob 0, {2 bar}
  endif
  LabelKnob 1, {x}, count
  LabelKnob 2, (Round gate*1000)/10, {%}

  for _step = 0 to 15
    _voice_cnt = 0
    _part_cnt = 0
    for _part = 0 to step_reso-1
      _voice_part_cnt = polycount[(active_pattern * patterns) + (_step * step_reso + _part)]
      if _voice_part_cnt > 0
        _voice_cnt = _voice_cnt + _voice_part_cnt
        Inc _part_cnt
      endif
    endfor
    LabelPad _step, _part_cnt, {:}, _voice_cnt
    if _part_cnt > 0
      LatchPad _step, 1
    else
      LatchPad _step, 0
    endif
  endfor

@End

@PadManagerOnLoad
  
  // The following vars CAN be set before @InitPadManager. 
  // If they are not defined here, they will be automatically 
  // defined with their defaults in @InitPadManager
  //
  // In the most basic use-case, just Call @InitPadManager 
  // in your OnLoad without setting any of them. 
  
  pmAnalyseTime = 150 
  // Length of double tap / tap-and-hold time window in msec
    
  pmManageTimer = YES
  // Set to NO if your script wants to controll the timer.
  // Your timer needs to run continously and with an update
  // interval faster than 50, otherwise the pad manager 
  // wont work. Also set pmTickInterval accordingly.

  pmTickInterval = 50
  // Update interval for the timer in msec.

  //  pmExcludePads = [7,15]
  pmExcludeCnt = 0
  // List of pad ids and length of list to be excluded from
  // analysis. For these pads OnSingleTap will be called 
  // immediately in 'OnPadDown' without the analysis delay.

  Call @InitPadManager
@End



// ========= Pad Manager V2 =========
// -ki  01.06.2019

@InitPadManager  

  // Apply defaults, if the vars are not yet defined

  if Unassigned pmAnalyseTime
    pmAnalyseTime = 200 
  endif
  if Unassigned pmManageTimer
    pmManageTimer = YES
  endif
  if Unassigned pmTickInterval
    pmTickInterval = 25
  endif
  if Unassigned pmExcludePads
    pmExcludePads = []
  endif
  if Unassigned pmExcludeCnt
    pmExcludeCnt = 0
  endif
  
  padsActiveCnt = 0  
  padMaxId = 15
  for pad = 0 to padMaxId
    Call @InitPadState
  endfor

  if pmExcludeCnt>0
    for pad = 0 to pmExcludeCnt-1
      padExclude[ pmExcludePads[pad] ] = YES
    endfor
  endif

  padAnalyseTicks = pmAnalyseTime / pmTickInterval

  if pmManageTimer
    SetTimerInterval pmTickInterval
  endif
  
  Log {PadManager started (},pmExcludeCnt,{ excluded pads, timer=}, pmTickInterval,{msec)}
@End

@InitPadState // Param: pad
  padActive[pad] = NO
  padTicks[pad] = 0
  padTaps[pad] = 0
  padHold[pad] = NO
  padExclude[pad] = NO
@End

@ReleasePadState // Param: pad
  Dec padsActiveCnt
  if pmManageTimer and padsActiveCnt = 0
    StopTimer 
  endif
  Call @InitPadState
 @End

@OnPadDown 
  if padExclude[LastPad]
    pad = LastPad
    Call @OnPadSingleTap
  else
    if pmManageTimer and padsActiveCnt = 0
      StartTimer 
    endif
    if not padActive[LastPad]
      Inc padsActiveCnt
      padActive[LastPad] = YES
    endif
    inc padTaps[LastPad]
  endif
@End 

@OnPadUp 
  if padTaps[LastPad] = 1 and padTicks[LastPad] < padAnalyseTicks
    padHold[LastPad] = YES
  endif
 
  if pad_edit = 1 AND LastPad = pad_edit_step
    Log { Exiting Pad Edit mode }
    pad_edit = 0
    Call @UpdateGUI
  endif
@End 

@OnTimer 
  for pad = 0 to padMaxId
    if padActive[pad]
      Inc padTicks[pad]

      if padTicks[pad] > padAnalyseTicks
        if padTaps[pad] = 1
          if padHold[pad]
            Call @OnPadSingleTap
          else
            Call @OnPadHold
          endif
        else
            Call @OnPadDoubleTap
        endif

        Call @ReleasePadState
      endif
    endif
  endfor
@End 

// <<<<<<<<< end of Pad Manager script code >>>>>

@Description
  Multi-pattern sequencer for Mozaic.
  
  Inspired by OP-Z and https://patchstorage.com/infinity
  Thanks to -ki for https://patchstorage.com/pad-manager-include
@End
