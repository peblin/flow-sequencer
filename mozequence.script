@Onload
  ShowLayout 2
  Call @PadManagerOnLoad

  step_reso = 8  // Grid/parts per step
  poly = 6       // Max polyphony per part
  sizeof_pattern = 16*8   // Size of storing all step parts in an array

  poly_offset = 0
  note_pos = 0
  note_part = 0
  step = 0
  pad_edit_step = 0
  total_tickCounter = 0  // tracks total ticks since start of transport. might wrap, but that wont kill anyone....i think

  // states for UI
  
  resetStepOnNewStep = 0
  pad_edit = 0
  uiMode = 1 // "Pad mode"
  if Unassigned record
    record = 1 // Rec enabled by default
    transpose = NO
    transposeNote = 0
    copyPattern = NO
  endif

  PPQN = [8*step_reso, 4*step_reso, 3*step_reso, 2*step_reso, step_reso, step_reso/2, step_reso/4, step_reso/8]

  // init knob defaults
  if Unassigned currentDivisor
    currentDivisor = 0
    count = 1
    tickCounter = 0
    gate = 0.75
    swing = 0
    noteTimeX_knob = 100
    probability_knob = 100
  endif

  SetKnobValue 0, 0
  SetKnobValue 1, 64
  SetKnobValue 2, 127
  SetKnobValue 3, 64

  call @ComputeTimes
  Call @InitSequencer

  if Unassigned last_active_pattern
    last_active_pattern = 1
  endif
  active_pattern = 0

  call @UpdateGUI
@End

// Refactor pad_edit -> part_edit
// Break up OnPad events into smaller functions
// Explicit "mode_pad_edit" mode variables keeping UI state
// Explicit "end action and return to pad view" call at end of pattern actions (clear, copy etc)
// Rec should only affect live recording

@InitSequencer
  if Unassigned polycount
    Call @ClearSequencer
  endif
@End

@ClearSequencer
    FillArray polycount, 0
    FillArray voice1, -1 // clear our notes buffer
    FillArray voice1_velocity, 0 // clear the velocity buffer

    FillArray voice2, -1 // clear our notes buffer
    FillArray voice2_velocity, 0 // clear the velocity buffer

    FillArray voice3, -1 // clear our notes buffer
    FillArray voice3_velocity, 0 // clear the velocity buffer

    FillArray voice4, -1 // clear our notes buffer
    FillArray voice4_velocity, 0 // clear the velocity buffer

    FillArray voice5, -1 // clear our notes buffer
    FillArray voice5_velocity, 0 // clear the velocity buffer

    FillArray voice6, -1 // clear our notes buffer
    FillArray voice6_velocity, 0 // clear the velocity buffer
    FillArray noteTimeX, 100
    FillArray noteOnTicks, 0
    FillArray note_probability, 100
@End

@OnMetroPulse 

  step_part = RoundDown(tickCounter / countPerStep) * step_reso 
  note_part = (step * step_reso + step_part) // The note location in the wide grid
 
  _note_part = (active_pattern * sizeof_pattern) + note_part
  FlashPad step
  
  if voice1[_note_part] >= 0 and ((Random 1, 100) < note_probability[_note_part])
    _transposeNote = 0
    if transpose 
      _transposeNote = transposeNote
    endif

    _polycount = polycount[_note_part]
    _noteTime = noteTime * (noteTimeX[_note_part] / 100)

    if _polycount > 5
      SendMIDINoteOn 0, voice6[_note_part] + _transposeNote, voice6_velocity[_note_part]      
      SendMIDINoteOff 0, voice6[_note_part] + _transposeNote, 0, _noteTime
    endif
    if _polycount > 4
      SendMIDINoteOn 0, voice5[_note_part] + _transposeNote, voice5_velocity[_note_part]      
      SendMIDINoteOff 0, voice5[_note_part] + _transposeNote, 0, _noteTime
    endif
    if _polycount > 3
      SendMIDINoteOn 0, voice4[_note_part] + _transposeNote, voice4_velocity[_note_part]      
      SendMIDINoteOff 0, voice4[_note_part] + _transposeNote, 0, _noteTime
    endif
    if _polycount > 2
      SendMIDINoteOn 0, voice3[_note_part] + _transposeNote, voice3_velocity[_note_part]      
      SendMIDINoteOff 0, voice3[_note_part] + _transposeNote, 0, _noteTime
    endif
    if _polycount > 1
      SendMIDINoteOn 0, voice2[_note_part] + _transposeNote, voice2_velocity[_note_part]      
      SendMIDINoteOff 0, voice2[_note_part] + _transposeNote, 0, _noteTime
    endif
    if _polycount > 0
      SendMIDINoteOn 0, voice1[_note_part] + _transposeNote, voice1_velocity[_note_part]      
      SendMIDINoteOff 0, voice1[_note_part] + _transposeNote, 0, _noteTime
    endif
  endif

  Call @IncrementSequencer

@End

@OnShiftDown
  if uiMode = 1 and pad_edit = 1
      Log { Exiting Pad Edit mode }
      pad_edit = 0
  elseif uiMode = 1
    uiMode = 2 // "button" mode
    copyPattern = NO
  elseif uiMode = 2
    uiMode = 1 // pad mode
    copyPattern = NO
  endif
  Call @UpdateGUI
@End 

@OnShiftUp
@End 

@OnPadHold
  pad_edit_step = pad
  pad_edit = 1
  pad_edit_part = 0
  Log {Pad held: }, pad
  LabelPad pad, {Editing...} 
  Call @UpdateGUI
@End


@OnPadSingleTap // param: pad

  if uiMode = 1 and pad_edit = 1
    if (pad_edit_step > 7 AND pad > 7) OR (pad_edit_step < 7 AND pad < 7)    // pad and tapped pad are on the same row  
      Log { Exiting Pad Edit mode }
      pad_edit = 0
      Call @UpdateGUI
    else
      pad_edit_part = pad % step_reso // Only step_reso parts
      pad_edit_part_pad = pad // for UI usage like latching pad etc during edit
      LabelPad pad, { Edit }
      LabelPads {Editing step:part -- }, pad_edit_step, {:} , pad_edit_part, { -- SHIFT or step pad to exit }
    endif
  elseif uiMode = 1  // pads
    Log {Pad singletapped: }, pad
    reset_step = pad
    resetStepOnNewStep = 1
  elseif uiMode = 2 and copyPattern = YES
    copyPattern = NO

    if pad < 8
      exit
    endif
    
    _pattern = pad - 8
    _src_pattern_pos = active_pattern * sizeof_pattern
    _dest_pattern_pos = _pattern * sizeof_pattern
  
    CopyArray voice1[_src_pattern_pos], voice1[_dest_pattern_pos], sizeof_pattern
    CopyArray voice2[_src_pattern_pos], voice2[_dest_pattern_pos], sizeof_pattern
    CopyArray voice3[_src_pattern_pos], voice3[_dest_pattern_pos], sizeof_pattern
    CopyArray voice4[_src_pattern_pos], voice4[_dest_pattern_pos], sizeof_pattern
    CopyArray voice5[_src_pattern_pos], voice5[_dest_pattern_pos], sizeof_pattern
    CopyArray voice6[_src_pattern_pos], voice6[_dest_pattern_pos], sizeof_pattern
    CopyArray voice1_velocity[_src_pattern_pos], voice1_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice2_velocity[_src_pattern_pos], voice2_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice3_velocity[_src_pattern_pos], voice3_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice4_velocity[_src_pattern_pos], voice4_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice5_velocity[_src_pattern_pos], voice5_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray voice6_velocity[_src_pattern_pos], voice6_velocity[_dest_pattern_pos], sizeof_pattern
    CopyArray polycount[_src_pattern_pos], polycount[_dest_pattern_pos], sizeof_pattern
    CopyArray noteTimeX[_src_pattern_pos], noteTimeX[_dest_pattern_pos], sizeof_pattern
    CopyArray noteOnTicks[_src_pattern_pos], noteOnTicks[_dest_pattern_pos], sizeof_pattern
    CopyArray note_probability[_src_pattern_pos], note_probability[_dest_pattern_pos], sizeof_pattern

    LabelPad _pattern + 8, {Copied }, active_pattern+1 
  elseif uiMode = 2 // buttons
    if pad = 0 // Transpose
      transpose = not transpose
      LabelPad 0, { Transpose: }, transpose

      if transpose = 0
        LabelPads { Hello }
      endif

    elseif pad = 1 // Erase All
      Call @ClearSequencer    
      
    elseif pad = 2 // Record
      record = not record
      LabelPad 2, { Rec: }, record
  
    elseif pad = 3 // Dump
      Call @DumpNotes
      
    elseif pad = 4 // Copy pattern
      LabelPads { Select pattern to copy active pattern to }
      copyPattern = YES

    elseif pad = 8 // Pattern 1
      last_active_pattern = active_pattern
      active_pattern = 0
 
    elseif pad = 9 // Pattern 2
      last_active_pattern = active_pattern
      active_pattern = 1
 
    elseif pad = 10 // Pattern 3
      last_active_pattern = active_pattern
      active_pattern = 2

    elseif pad = 11 // Pattern 4
      last_active_pattern = active_pattern
      active_pattern = 3

    elseif pad = 12 // Pattern 5
      last_active_pattern = active_pattern
      active_pattern = 4
 
    elseif pad = 13 // Pattern 6
      last_active_pattern = active_pattern
      active_pattern = 5

    elseif pad = 14 // Pattern 7
      last_active_pattern = active_pattern
      active_pattern = 6

    endif
    
    if pad >= 8
      LatchPad last_active_pattern + 8, 0
      LatchPad active_pattern + 8, 1
    endif
  endif
  
@End


@DumpNotes

  for _pattern = 0 to 7
    for _step = 0 to 15
       for _part = 0 to step_reso - 1
          _notepart = _step * step_reso + _part
          _notepos = (_pattern * sizeof_pattern) + _notepart
          if voice1[_notepos] >= 0
              Log { Pattern: }, _pattern+1, { Step: }, _step, { Part: }, _part, { Voice1: }, (NoteName voice1[_notepos], YES)
          endif
      endfor  
    endfor  
  endfor

@End

@OnPadDoubleTap

  if pad_edit = 1
    del_step_part = pad % 8
    del_step = pad_edit_step
    del_step_pos = del_step * step_reso + del_step_part // The note location in the wide grid

    polycount[(active_pattern * sizeof_pattern) + del_step_pos] = 0
  
    LatchPad pad, 0
    LabelPad pad, { }
  else
    del_step = pad
    del_note_part = del_step * step_reso // The note location in the wide grid

    for po = 0 to step_reso
      polycount[(active_pattern * sizeof_pattern) + (del_note_part + po)] = 0
    endfor
  
    LatchPad del_step, 0
    LabelPad del_step, { }
  endif
@End

@OnHostStart
  step = 0
  note_pos = 0
  note_part = 0  
  tickCounter = 0
  total_tickCounter = 0
@End 

@OnMidiNoteOn

  log {Midi Note On: }, MIDINote, { Vel: }, MIDIVelocity
  nn = MIDINote
  v = MIDIVelocity

  if transpose AND pad_edit <> 1 
    transposeNote = MIDINote - 48
    LabelPads { Transpose: }, transposeNote
    Exit
  endif
  
//  SendMIDINoteOn 0, nn, v
//  SendMIDINoteOff 0, nn, 0, noteTime

  SendMidiThru

  if not record and not pad_edit = 1
    Exit
  endif
  
  if pad_edit = 1

    pad_note_part = pad_edit_step * step_reso + pad_edit_part // The note location for the pad being edited. 

    _step = pad_edit_step
    _note_part = (active_pattern * sizeof_pattern) + pad_note_part
 
    if not Unassigned pad_edit_part_pad  // Latch and label when editing parts of step
      LabelPad pad_edit_part_pad, nn
      LatchPad pad_edit_part_pad, 1
    endif
  else
    _step = step
    _note_part = (active_pattern * sizeof_pattern) + note_part
  endif
  
  _poly_offset = polycount[_note_part]
 
  if _poly_offset = 0
    voice1[_note_part] = nn
    voice1_velocity[_note_part] = nn
  elseif _poly_offset = 1
    voice2[_note_part] = nn
    voice2_velocity[_note_part] = nn
  elseif _poly_offset = 2
    voice3[_note_part] = nn
    voice3_velocity[_note_part] = nn
  elseif _poly_offset = 3
    voice4[_note_part] = nn
    voice4_velocity[_note_part] = nn
  elseif _poly_offset = 4
    voice5[_note_part] = nn
    voice5_velocity[_note_part] = nn
  elseif _poly_offset = 5
    voice6[_note_part] = nn
    voice6_velocity[_note_part] = nn
  endif

  if _poly_offset < 8
    Inc _poly_offset
  endif

  polycount[_note_part] = _poly_offset
  noteOnTicks[_note_part] = total_tickCounter
  SetNoteState 0, nn, _note_part    // So that MidiNoteOff can reference all data of the note being played

  LabelPad _step, _poly_offset, {:}, (NoteName nn, YES) 
  LatchPad _step, 1
  Log {CPS: }â€š countPerStep, {tickCounter: }, tickCounter, { step: }, step,{ note_part: }, note_part, { note_pos: }, note_pos, { Note: }, (Notename nn, YES)

  last_note = nn      // for single-tap edit
  last_velocity = nn  

@End 

@OnMidiNoteOff
  nn = MIDINote
  v = MIDIVelocity

  SendMidiThru

  _note_part = GetNoteState 0, nn
  _on_ticks = noteOnTicks[_note_part]
  _off_ticks = total_tickCounter
  _elapsed_ticks = _off_ticks - _on_ticks

  // Special case if transport is stopped or we have long steps (like 2 bars) we might get 0 ticks so we default to 1 step for these cases.
  if _elapsed_ticks = 0
    _elapsed_pct = 100
  elseif 
    _elapsed_pct = tickTime * _elapsed_ticks / noteTime * 100
  endif

  Log { Note On: }, _on_ticks, { Off: }, _off_ticks, { Elapsed: }, _elapsed_ticks, { = }, _elapsed_pct
  noteTimeX[_note_part] = _elapsed_pct  // elapsed as percentage of notetime
@End

@OnKnobChange
  if LastKnob = 0
    currentDivisor = Round ((GetKnobValue 0) / 16)
  elseif LastKnob = 1
    noteTimeX_knob = Round((GetKnobValue 1) / 127 * 800)  
    if noteTimeX_knob < 6.25
      noteTimeX_knob = 6.25     // So noteTimeX_knox will be between 6.25 (equiv of a 1/64 note) and 800 of the note time, scaled down to % (1/100) later
    endif
  
    if pad_edit = 1
      noteTimeX[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = noteTimeX_knob
    else
      noteTimeX[(active_pattern * sizeof_pattern) + note_part] = noteTimeX_knob
    endif
//  elseif LastKnob = 2  
//    gate = (GetKnobValue 2) / 100
  elseif LastKnob = 2  
    _probability = (GetKnobValue 2) / 127 * 100
    if pad_edit = 1
      note_probability[(active_pattern * sizeof_pattern) + (pad_edit_step*step_reso) + pad_edit_part] = _probability
    else
      note_probability[(active_pattern * sizeof_pattern) + note_part] = _probability
    endif

    probability_knob = _probability
    
  elseif LastKnob = 3
    swing = (GetKnobValue 3) / 127
  endif

  call @ComputeTimes
  call @UpdateGUI
@End

@IncrementSequencer
  Inc tickCounter
  Inc total_tickCounter

  if tickCounter >= countPerStep
    tickCounter = 0
    
    if resetStepOnNewStep = 1
      resetStepOnNewStep = 0
      step = reset_step
    else
      Inc step
      if step > 15
        step = 0
      endif
    endif
  endif
@End 

@ComputeTimes
  tickTime = QuarterNote / PPQN[currentDivisor]
  stepTime = tickTime * step_reso
  countPerStep = step_reso 

  noteTime = stepTime * gate
  SetMetroPPQN PPQN[currentDivisor]
@End

@UpdateGUI
  if uiMode = 1 AND pad_edit = 1
    call @GUI_PadEditMode
    LabelPads {Editing step:part -- }, pad_edit_step, {:} , pad_edit_part, { -- SHIFT or step pad to exit }

  elseif uiMode = 1
    call @GUI_PadMode
    LabelPads {Rec: }, record, { Transpose: }, transpose

  elseif uiMode = 2
    call @GUI_ButtonMode 
    LabelPads {Menu}
  endif
@End

@GUI_PadEditMode
  if pad_edit_step <= 7
    _pad_offset = 8
  else
    _pad_offset = 0
  endif

  for the_part = 0 to step_reso
    _note_part = (active_pattern * sizeof_pattern) + (pad_edit_step * step_reso + the_part)
    _cnt = polycount[_note_part]
    _pad = the_part + _pad_offset
    if _cnt > 0
      LabelPad _pad, _cnt, {:}, (NoteName voice1[_note_part], YES), {:}, noteTimeX[_note_part]
      LatchPad _pad, 1
    else
      LatchPad _pad, 0
      LabelPad _pad, {-}
    endif
  endfor

  Call @GUI_LabelKnobs
@End


 //, {:}, noteTimeX[(active_pattern * sizeof_pattern) + (pad_edit_step * step_reso + the_part)]



@GUI_ButtonMode
  
  for po = 0 to 15
    LabelPad po, { }
    LatchPad po, 0
  endfor
      
  LabelPad 0, { Transpose: }, transpose
  LabelPad 1, { Clear all }
  LabelPad 2, { Rec: }, record
  LabelPad 3, { Dump }
  LabelPad 4, { Copy pattern }
  
  LabelPad 8, { Pattern 1}
  LabelPad 9, { Pattern 2}
  LabelPad 10, { Pattern 3}
  LabelPad 11, { Pattern 4}
  LabelPad 12, { Pattern 5}
  LabelPad 13, { Pattern 6}
  LabelPad 14, { Pattern 7}
  LatchPad 8+active_pattern, 1

@End

@GUI_LabelKnobs
  if currentDivisor = 0
    LabelKnob 0, {1/32}
  elseif currentDivisor = 1
    LabelKnob 0, {1/16}
  elseif currentDivisor = 2
    LabelKnob 0, {1/8t}
  elseif currentDivisor = 3
    LabelKnob 0, {1/8}
  elseif currentDivisor = 4
    LabelKnob 0, {1/4}
  elseif currentDivisor = 5
    LabelKnob 0, {1/2}
  elseif currentDivisor = 6
    LabelKnob 0, {bar}
  elseif currentDivisor = 7
    LabelKnob 0, {2 bar}
  endif

  LabelKnob 1, noteTimeX_knob*1.000
  LabelKnob 2, Round probability_knob
@End

@GUI_PadMode

  Call @GUI_LabelKnobs

  for _step = 0 to 15
    _voice_cnt = 0
    _part_cnt = 0
    for _part = 0 to step_reso-1
      _voice_part_cnt = polycount[(active_pattern * sizeof_pattern) + (_step * step_reso + _part)]
      if _voice_part_cnt > 0
        _voice_cnt = _voice_cnt + _voice_part_cnt
        Inc _part_cnt
      endif
    endfor

    if _part_cnt > 0
      LatchPad _step, 1
      LabelPad _step, _part_cnt, {:}, _voice_cnt, {:}, noteTimeX[(active_pattern * sizeof_pattern) + (_step * step_reso)]
    else
      LatchPad _step, 0
      LabelPad _step, { }
    endif
  endfor

@End

@PadManagerOnLoad
  
  // The following vars CAN be set before @InitPadManager. 
  // If they are not defined here, they will be automatically 
  // defined with their defaults in @InitPadManager
  //
  // In the most basic use-case, just Call @InitPadManager 
  // in your OnLoad without setting any of them. 
  
  pmAnalyseTime = 150 
  // Length of double tap / tap-and-hold time window in msec
    
  pmManageTimer = YES
  // Set to NO if your script wants to controll the timer.
  // Your timer needs to run continously and with an update
  // interval faster than 50, otherwise the pad manager 
  // wont work. Also set pmTickInterval accordingly.

  pmTickInterval = 50
  // Update interval for the timer in msec.

  //  pmExcludePads = [7,15]
  pmExcludeCnt = 0
  // List of pad ids and length of list to be excluded from
  // analysis. For these pads OnSingleTap will be called 
  // immediately in 'OnPadDown' without the analysis delay.

  Call @InitPadManager
@End



// ========= Pad Manager V2 =========
// -ki  01.06.2019

@InitPadManager  

  // Apply defaults, if the vars are not yet defined

  if Unassigned pmAnalyseTime
    pmAnalyseTime = 200 
  endif
  if Unassigned pmManageTimer
    pmManageTimer = YES
  endif
  if Unassigned pmTickInterval
    pmTickInterval = 25
  endif
  if Unassigned pmExcludePads
    pmExcludePads = []
  endif
  if Unassigned pmExcludeCnt
    pmExcludeCnt = 0
  endif
  
  padsActiveCnt = 0  
  padMaxId = 15
  for pad = 0 to padMaxId
    Call @InitPadState
  endfor

  if pmExcludeCnt>0
    for pad = 0 to pmExcludeCnt-1
      padExclude[ pmExcludePads[pad] ] = YES
    endfor
  endif

  padAnalyseTicks = pmAnalyseTime / pmTickInterval

  if pmManageTimer
    SetTimerInterval pmTickInterval
  endif
  
  Log {PadManager started (},pmExcludeCnt,{ excluded pads, timer=}, pmTickInterval,{msec)}
@End

@InitPadState // Param: pad
  padActive[pad] = NO
  padTicks[pad] = 0
  padTaps[pad] = 0
  padHold[pad] = NO
  padExclude[pad] = NO
@End

@ReleasePadState // Param: pad
  Dec padsActiveCnt
  if pmManageTimer and padsActiveCnt = 0
    StopTimer 
  endif
  Call @InitPadState
 @End

@OnPadDown 
  if padExclude[LastPad]
    pad = LastPad
    Call @OnPadSingleTap
  else
    if pmManageTimer and padsActiveCnt = 0
      StartTimer 
    endif
    if not padActive[LastPad]
      Inc padsActiveCnt
      padActive[LastPad] = YES
    endif
    inc padTaps[LastPad]
  endif
@End 

@OnPadUp 
  if padTaps[LastPad] = 1 and padTicks[LastPad] < padAnalyseTicks
    padHold[LastPad] = YES
  endif

@End 

@OnTimer 
  for pad = 0 to padMaxId
    if padActive[pad]
      Inc padTicks[pad]

      if padTicks[pad] > padAnalyseTicks
        if padTaps[pad] = 1
          if padHold[pad]
            Call @OnPadSingleTap
          else
            Call @OnPadHold
          endif
        else
            Call @OnPadDoubleTap
        endif

        Call @ReleasePadState
      endif
    endif
  endfor
@End 

// <<<<<<<<< end of Pad Manager script code >>>>>

@Description
  Multi-pattern two-level midi sequencer/looper for Mozaic by peblin.
  Featuring:

  - 16 steps with 8 subdivisions (parts) each
  - 7 patterns with pattern copy
  - 6 voice polyphony per part
  - From 1/32 to 2 bar step length
  - Live recording, including note durations
  - Individual step / part editing
  - Note probability
  - Note duration can be set by knob per part
  - Transpose mode
  - Manual triggering of steps using single tap
    
  Inspired by OP-Z and https://patchstorage.com/infinity
  Thanks to -ki for https://patchstorage.com/pad-manager-include
@End